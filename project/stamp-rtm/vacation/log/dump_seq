
./vacation.seq:     file format elf64-x86-64


Disassembly of section .init:

0000000000400bc0 <_init>:
  400bc0:	48 83 ec 08          	sub    $0x8,%rsp
  400bc4:	e8 2f 0b 00 00       	callq  4016f8 <call_gmon_start>
  400bc9:	e8 22 0c 00 00       	callq  4017f0 <frame_dummy>
  400bce:	e8 0d 7f 00 00       	callq  408ae0 <__do_global_ctors_aux>
  400bd3:	48 83 c4 08          	add    $0x8,%rsp
  400bd7:	c3                   	retq   

Disassembly of section .plt:

0000000000400be0 <pthread_getspecific@plt-0x10>:
  400be0:	ff 35 22 b6 20 00    	pushq  0x20b622(%rip)        # 60c208 <_GLOBAL_OFFSET_TABLE_+0x8>
  400be6:	ff 25 24 b6 20 00    	jmpq   *0x20b624(%rip)        # 60c210 <_GLOBAL_OFFSET_TABLE_+0x10>
  400bec:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400bf0 <pthread_getspecific@plt>:
  400bf0:	ff 25 22 b6 20 00    	jmpq   *0x20b622(%rip)        # 60c218 <_GLOBAL_OFFSET_TABLE_+0x18>
  400bf6:	68 00 00 00 00       	pushq  $0x0
  400bfb:	e9 e0 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c00 <printf@plt>:
  400c00:	ff 25 1a b6 20 00    	jmpq   *0x20b61a(%rip)        # 60c220 <_GLOBAL_OFFSET_TABLE_+0x20>
  400c06:	68 01 00 00 00       	pushq  $0x1
  400c0b:	e9 d0 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c10 <pthread_setspecific@plt>:
  400c10:	ff 25 12 b6 20 00    	jmpq   *0x20b612(%rip)        # 60c228 <_GLOBAL_OFFSET_TABLE_+0x28>
  400c16:	68 02 00 00 00       	pushq  $0x2
  400c1b:	e9 c0 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c20 <puts@plt>:
  400c20:	ff 25 0a b6 20 00    	jmpq   *0x20b60a(%rip)        # 60c230 <_GLOBAL_OFFSET_TABLE_+0x30>
  400c26:	68 03 00 00 00       	pushq  $0x3
  400c2b:	e9 b0 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c30 <pthread_cond_signal@plt>:
  400c30:	ff 25 02 b6 20 00    	jmpq   *0x20b602(%rip)        # 60c238 <_GLOBAL_OFFSET_TABLE_+0x38>
  400c36:	68 04 00 00 00       	pushq  $0x4
  400c3b:	e9 a0 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c40 <exit@plt>:
  400c40:	ff 25 fa b5 20 00    	jmpq   *0x20b5fa(%rip)        # 60c240 <_GLOBAL_OFFSET_TABLE_+0x40>
  400c46:	68 05 00 00 00       	pushq  $0x5
  400c4b:	e9 90 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c50 <__assert_fail@plt>:
  400c50:	ff 25 f2 b5 20 00    	jmpq   *0x20b5f2(%rip)        # 60c248 <_GLOBAL_OFFSET_TABLE_+0x48>
  400c56:	68 06 00 00 00       	pushq  $0x6
  400c5b:	e9 80 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c60 <gettimeofday@plt>:
  400c60:	ff 25 ea b5 20 00    	jmpq   *0x20b5ea(%rip)        # 60c250 <_GLOBAL_OFFSET_TABLE_+0x50>
  400c66:	68 07 00 00 00       	pushq  $0x7
  400c6b:	e9 70 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c70 <getopt@plt>:
  400c70:	ff 25 e2 b5 20 00    	jmpq   *0x20b5e2(%rip)        # 60c258 <_GLOBAL_OFFSET_TABLE_+0x58>
  400c76:	68 08 00 00 00       	pushq  $0x8
  400c7b:	e9 60 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c80 <malloc@plt>:
  400c80:	ff 25 da b5 20 00    	jmpq   *0x20b5da(%rip)        # 60c260 <_GLOBAL_OFFSET_TABLE_+0x60>
  400c86:	68 09 00 00 00       	pushq  $0x9
  400c8b:	e9 50 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400c90 <__libc_start_main@plt>:
  400c90:	ff 25 d2 b5 20 00    	jmpq   *0x20b5d2(%rip)        # 60c268 <_GLOBAL_OFFSET_TABLE_+0x68>
  400c96:	68 0a 00 00 00       	pushq  $0xa
  400c9b:	e9 40 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400ca0 <pthread_mutex_init@plt>:
  400ca0:	ff 25 ca b5 20 00    	jmpq   *0x20b5ca(%rip)        # 60c270 <_GLOBAL_OFFSET_TABLE_+0x70>
  400ca6:	68 0b 00 00 00       	pushq  $0xb
  400cab:	e9 30 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400cb0 <free@plt>:
  400cb0:	ff 25 c2 b5 20 00    	jmpq   *0x20b5c2(%rip)        # 60c278 <_GLOBAL_OFFSET_TABLE_+0x78>
  400cb6:	68 0c 00 00 00       	pushq  $0xc
  400cbb:	e9 20 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400cc0 <pthread_create@plt>:
  400cc0:	ff 25 ba b5 20 00    	jmpq   *0x20b5ba(%rip)        # 60c280 <_GLOBAL_OFFSET_TABLE_+0x80>
  400cc6:	68 0d 00 00 00       	pushq  $0xd
  400ccb:	e9 10 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400cd0 <pthread_cond_init@plt>:
  400cd0:	ff 25 b2 b5 20 00    	jmpq   *0x20b5b2(%rip)        # 60c288 <_GLOBAL_OFFSET_TABLE_+0x88>
  400cd6:	68 0e 00 00 00       	pushq  $0xe
  400cdb:	e9 00 ff ff ff       	jmpq   400be0 <_init+0x20>

0000000000400ce0 <pthread_join@plt>:
  400ce0:	ff 25 aa b5 20 00    	jmpq   *0x20b5aa(%rip)        # 60c290 <_GLOBAL_OFFSET_TABLE_+0x90>
  400ce6:	68 0f 00 00 00       	pushq  $0xf
  400ceb:	e9 f0 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400cf0 <strtol@plt>:
  400cf0:	ff 25 a2 b5 20 00    	jmpq   *0x20b5a2(%rip)        # 60c298 <_GLOBAL_OFFSET_TABLE_+0x98>
  400cf6:	68 10 00 00 00       	pushq  $0x10
  400cfb:	e9 e0 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d00 <pthread_cond_wait@plt>:
  400d00:	ff 25 9a b5 20 00    	jmpq   *0x20b59a(%rip)        # 60c2a0 <_GLOBAL_OFFSET_TABLE_+0xa0>
  400d06:	68 11 00 00 00       	pushq  $0x11
  400d0b:	e9 d0 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d10 <pthread_attr_init@plt>:
  400d10:	ff 25 92 b5 20 00    	jmpq   *0x20b592(%rip)        # 60c2a8 <_GLOBAL_OFFSET_TABLE_+0xa8>
  400d16:	68 12 00 00 00       	pushq  $0x12
  400d1b:	e9 c0 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d20 <pthread_mutex_lock@plt>:
  400d20:	ff 25 8a b5 20 00    	jmpq   *0x20b58a(%rip)        # 60c2b0 <_GLOBAL_OFFSET_TABLE_+0xb0>
  400d26:	68 13 00 00 00       	pushq  $0x13
  400d2b:	e9 b0 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d30 <pthread_key_create@plt>:
  400d30:	ff 25 82 b5 20 00    	jmpq   *0x20b582(%rip)        # 60c2b8 <_GLOBAL_OFFSET_TABLE_+0xb8>
  400d36:	68 14 00 00 00       	pushq  $0x14
  400d3b:	e9 a0 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d40 <fprintf@plt>:
  400d40:	ff 25 7a b5 20 00    	jmpq   *0x20b57a(%rip)        # 60c2c0 <_GLOBAL_OFFSET_TABLE_+0xc0>
  400d46:	68 15 00 00 00       	pushq  $0x15
  400d4b:	e9 90 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d50 <pthread_mutex_unlock@plt>:
  400d50:	ff 25 72 b5 20 00    	jmpq   *0x20b572(%rip)        # 60c2c8 <_GLOBAL_OFFSET_TABLE_+0xc8>
  400d56:	68 16 00 00 00       	pushq  $0x16
  400d5b:	e9 80 fe ff ff       	jmpq   400be0 <_init+0x20>

0000000000400d60 <fflush@plt>:
  400d60:	ff 25 6a b5 20 00    	jmpq   *0x20b56a(%rip)        # 60c2d0 <_GLOBAL_OFFSET_TABLE_+0xd0>
  400d66:	68 17 00 00 00       	pushq  $0x17
  400d6b:	e9 70 fe ff ff       	jmpq   400be0 <_init+0x20>

Disassembly of section .text:

0000000000400d70 <reserve.part.0>:
 * -- Customer is not allowed to reserve same (type, id) multiple times
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
static bool_t
reserve (TM_ARGDECL
  400d70:	50                   	push   %rax
            (long)TM_SHARED_READ(reservationPtr->price)))
    {
        /* Undo previous successful reservation */
        bool_t status = RESERVATION_CANCEL(reservationPtr);
        if (status == FALSE) {
            TM_RESTART();
  400d71:	b9 37 8d 40 00       	mov    $0x408d37,%ecx
  400d76:	ba 9f 02 00 00       	mov    $0x29f,%edx
  400d7b:	be 32 8c 40 00       	mov    $0x408c32,%esi
  400d80:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  400d85:	e8 c6 fe ff ff       	callq  400c50 <__assert_fail@plt>

0000000000400d8a <cancel.part.1>:
 * -- Customer is not allowed to cancel multiple times
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
static bool_t
cancel (TM_ARGDECL
  400d8a:	52                   	push   %rdx

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
        /* Undo previous successful cancellation */
        bool_t status = RESERVATION_MAKE(reservationPtr);
        if (status == FALSE) {
            TM_RESTART();
  400d8b:	b9 30 8d 40 00       	mov    $0x408d30,%ecx
  400d90:	ba ff 02 00 00       	mov    $0x2ff,%edx
  400d95:	be 32 8c 40 00       	mov    $0x408c32,%esi
  400d9a:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  400d9f:	e8 ac fe ff ff       	callq  400c50 <__assert_fail@plt>

0000000000400da4 <checkReservation.part.0>:
 * checkReservation
 * -- Check if consistent
 * =============================================================================
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
  400da4:	50                   	push   %rax
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
    if (numUsed < 0) {
        TM_RESTART();
  400da5:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  400daa:	ba 93 00 00 00       	mov    $0x93,%edx
  400daf:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  400db4:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  400db9:	e8 92 fe ff ff       	callq  400c50 <__assert_fail@plt>

0000000000400dbe <checkReservation_seq.part.1>:
#define CHECK_RESERVATION(reservation) \
    checkReservation(TM_ARG  reservation)


static void
checkReservation_seq (reservation_t* reservationPtr)
  400dbe:	52                   	push   %rdx
{
    assert(reservationPtr->numUsed >= 0);
  400dbf:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  400dc4:	ba b1 00 00 00       	mov    $0xb1,%edx
  400dc9:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  400dce:	bf de 8d 40 00       	mov    $0x408dde,%edi
  400dd3:	e8 78 fe ff ff       	callq  400c50 <__assert_fail@plt>
  400dd8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  400ddf:	00 

0000000000400de0 <main>:
/* =============================================================================
 * main
 * =============================================================================
 */
MAIN(argc, argv)
{
  400de0:	41 57                	push   %r15
  400de2:	41 56                	push   %r14
  400de4:	41 55                	push   %r13
  400de6:	41 bd 01 00 00 00    	mov    $0x1,%r13d
  400dec:	41 54                	push   %r12
  400dee:	41 89 fc             	mov    %edi,%r12d
  400df1:	55                   	push   %rbp
  400df2:	48 89 f5             	mov    %rsi,%rbp
  400df5:	53                   	push   %rbx
  400df6:	48 83 ec 68          	sub    $0x68,%rsp
parseArgs (long argc, char* const argv[])
{
    long i;
    long opt;

    opterr = 0;
  400dfa:	c7 05 04 b5 20 00 00 	movl   $0x0,0x20b504(%rip)        # 60c308 <opterr@@GLIBC_2.2.5>
  400e01:	00 00 00 
 * =============================================================================
 */
static void
setDefaultParams ()
{
    global_params[PARAM_CLIENTS]      = PARAM_DEFAULT_CLIENTS;
  400e04:	f2 0f 10 25 a4 85 00 	movsd  0x85a4(%rip),%xmm4        # 4093b0 <__PRETTY_FUNCTION__.3923+0x1e>
  400e0b:	00 
    global_params[PARAM_NUMBER]       = PARAM_DEFAULT_NUMBER;
  400e0c:	f2 0f 10 2d a4 85 00 	movsd  0x85a4(%rip),%xmm5        # 4093b8 <__PRETTY_FUNCTION__.3923+0x26>
  400e13:	00 
 * =============================================================================
 */
static void
setDefaultParams ()
{
    global_params[PARAM_CLIENTS]      = PARAM_DEFAULT_CLIENTS;
  400e14:	f2 0f 11 25 1c b9 20 	movsd  %xmm4,0x20b91c(%rip)        # 60c738 <global_params+0x318>
  400e1b:	00 
    global_params[PARAM_NUMBER]       = PARAM_DEFAULT_NUMBER;
  400e1c:	f2 0f 11 2d 6c b9 20 	movsd  %xmm5,0x20b96c(%rip)        # 60c790 <global_params+0x370>
  400e23:	00 
    global_params[PARAM_QUERIES]      = PARAM_DEFAULT_QUERIES;
  400e24:	f2 0f 10 35 94 85 00 	movsd  0x8594(%rip),%xmm6        # 4093c0 <__PRETTY_FUNCTION__.3923+0x2e>
  400e2b:	00 
    global_params[PARAM_RELATIONS]    = PARAM_DEFAULT_RELATIONS;
  400e2c:	f2 0f 10 3d 94 85 00 	movsd  0x8594(%rip),%xmm7        # 4093c8 <__PRETTY_FUNCTION__.3923+0x36>
  400e33:	00 
    global_params[PARAM_TRANSACTIONS] = PARAM_DEFAULT_TRANSACTIONS;
  400e34:	f2 0f 10 25 94 85 00 	movsd  0x8594(%rip),%xmm4        # 4093d0 <__PRETTY_FUNCTION__.3923+0x3e>
  400e3b:	00 
    global_params[PARAM_USER]         = PARAM_DEFAULT_USER;
  400e3c:	f2 0f 10 2d 94 85 00 	movsd  0x8594(%rip),%xmm5        # 4093d8 <__PRETTY_FUNCTION__.3923+0x46>
  400e43:	00 
static void
setDefaultParams ()
{
    global_params[PARAM_CLIENTS]      = PARAM_DEFAULT_CLIENTS;
    global_params[PARAM_NUMBER]       = PARAM_DEFAULT_NUMBER;
    global_params[PARAM_QUERIES]      = PARAM_DEFAULT_QUERIES;
  400e44:	f2 0f 11 35 5c b9 20 	movsd  %xmm6,0x20b95c(%rip)        # 60c7a8 <global_params+0x388>
  400e4b:	00 
    global_params[PARAM_RELATIONS]    = PARAM_DEFAULT_RELATIONS;
  400e4c:	f2 0f 11 3d 5c b9 20 	movsd  %xmm7,0x20b95c(%rip)        # 60c7b0 <global_params+0x390>
  400e53:	00 
    global_params[PARAM_TRANSACTIONS] = PARAM_DEFAULT_TRANSACTIONS;
  400e54:	f2 0f 11 25 64 b9 20 	movsd  %xmm4,0x20b964(%rip)        # 60c7c0 <global_params+0x3a0>
  400e5b:	00 
    global_params[PARAM_USER]         = PARAM_DEFAULT_USER;
  400e5c:	f2 0f 11 2d 64 b9 20 	movsd  %xmm5,0x20b964(%rip)        # 60c7c8 <global_params+0x3a8>
  400e63:	00 
  400e64:	0f 1f 40 00          	nopl   0x0(%rax)

    opterr = 0;

    setDefaultParams();

    while ((opt = getopt(argc, argv, "c:n:q:r:t:u:")) != -1) {
  400e68:	ba 06 8f 40 00       	mov    $0x408f06,%edx
  400e6d:	48 89 ee             	mov    %rbp,%rsi
  400e70:	44 89 e7             	mov    %r12d,%edi
  400e73:	e8 f8 fd ff ff       	callq  400c70 <getopt@plt>
  400e78:	48 63 d8             	movslq %eax,%rbx
  400e7b:	83 fb ff             	cmp    $0xffffffff,%ebx
  400e7e:	74 48                	je     400ec8 <main+0xe8>
  400e80:	8d 4b 9d             	lea    -0x63(%rbx),%ecx
  400e83:	83 f9 12             	cmp    $0x12,%ecx
  400e86:	77 0d                	ja     400e95 <main+0xb5>
  400e88:	4c 89 e8             	mov    %r13,%rax
  400e8b:	48 d3 e0             	shl    %cl,%rax
  400e8e:	a9 01 c8 06 00       	test   $0x6c801,%eax
  400e93:	75 0b                	jne    400ea0 <main+0xc0>
            case 'u':
                global_params[(unsigned char)opt] = atol(optarg);
                break;
            case '?':
            default:
                opterr++;
  400e95:	83 05 6c b4 20 00 01 	addl   $0x1,0x20b46c(%rip)        # 60c308 <opterr@@GLIBC_2.2.5>
  400e9c:	eb ca                	jmp    400e68 <main+0x88>
  400e9e:	66 90                	xchg   %ax,%ax
  return (int) strtol (__nptr, (char **) NULL, 10);
}
__extern_inline long int
__NTH (atol (__const char *__nptr))
{
  return strtol (__nptr, (char **) NULL, 10);
  400ea0:	48 8b 3d 79 b4 20 00 	mov    0x20b479(%rip),%rdi        # 60c320 <optarg@@GLIBC_2.2.5>
  400ea7:	ba 0a 00 00 00       	mov    $0xa,%edx
  400eac:	31 f6                	xor    %esi,%esi
  400eae:	e8 3d fe ff ff       	callq  400cf0 <strtol@plt>
            case 'n':
            case 'q':
            case 'r':
            case 't':
            case 'u':
                global_params[(unsigned char)opt] = atol(optarg);
  400eb3:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  400eb8:	f2 0f 11 04 dd 20 c4 	movsd  %xmm0,0x60c420(,%rbx,8)
  400ebf:	60 00 
  400ec1:	eb a5                	jmp    400e68 <main+0x88>
  400ec3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                opterr++;
                break;
        }
    }

    for (i = optind; i < argc; i++) {
  400ec8:	8b 05 32 b4 20 00    	mov    0x20b432(%rip),%eax        # 60c300 <optind@@GLIBC_2.2.5>
  400ece:	4d 63 ec             	movslq %r12d,%r13
  400ed1:	41 39 c4             	cmp    %eax,%r12d
  400ed4:	48 63 d8             	movslq %eax,%rbx
  400ed7:	0f 8e 69 06 00 00    	jle    401546 <main+0x766>
  400edd:	0f 1f 00             	nopl   (%rax)
        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
  400ee0:	48 8b 54 dd 00       	mov    0x0(%rbp,%rbx,8),%rdx
  400ee5:	48 8b 3d 3c b4 20 00 	mov    0x20b43c(%rip),%rdi        # 60c328 <stderr@@GLIBC_2.2.5>
  400eec:	31 c0                	xor    %eax,%eax
  400eee:	be 13 8f 40 00       	mov    $0x408f13,%esi
  400ef3:	48 83 c3 01          	add    $0x1,%rbx
  400ef7:	e8 44 fe ff ff       	callq  400d40 <fprintf@plt>
        opterr++;
  400efc:	8b 05 06 b4 20 00    	mov    0x20b406(%rip),%eax        # 60c308 <opterr@@GLIBC_2.2.5>
  400f02:	83 c0 01             	add    $0x1,%eax
                opterr++;
                break;
        }
    }

    for (i = optind; i < argc; i++) {
  400f05:	4c 39 eb             	cmp    %r13,%rbx
        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
        opterr++;
  400f08:	89 05 fa b3 20 00    	mov    %eax,0x20b3fa(%rip)        # 60c308 <opterr@@GLIBC_2.2.5>
                opterr++;
                break;
        }
    }

    for (i = optind; i < argc; i++) {
  400f0e:	75 d0                	jne    400ee0 <main+0x100>
        fprintf(stderr, "Non-option argument: %s\n", argv[i]);
        opterr++;
    }

    if (opterr) {
  400f10:	85 c0                	test   %eax,%eax
  400f12:	0f 85 de 06 00 00    	jne    4015f6 <main+0x816>
        &addCustomer
    };
    long t;
    long numTable = sizeof(manager_add) / sizeof(manager_add[0]);

    printf("Initializing manager... ");
  400f18:	bf 41 8f 40 00       	mov    $0x408f41,%edi
  400f1d:	31 c0                	xor    %eax,%eax
    manager_t* managerPtr;
    long i;
    long numRelation;
    random_t* randomPtr;
    long* ids;
    bool_t (*manager_add[])(manager_t*, long, long, long) = {
  400f1f:	48 c7 44 24 40 f0 24 	movq   $0x4024f0,0x40(%rsp)
  400f26:	40 00 
  400f28:	48 c7 44 24 48 c0 2a 	movq   $0x402ac0,0x48(%rsp)
  400f2f:	40 00 
  400f31:	48 c7 44 24 50 d0 27 	movq   $0x4027d0,0x50(%rsp)
  400f38:	40 00 
  400f3a:	48 c7 44 24 58 e0 39 	movq   $0x4039e0,0x58(%rsp)
  400f41:	40 00 
        &addCustomer
    };
    long t;
    long numTable = sizeof(manager_add) / sizeof(manager_add[0]);

    printf("Initializing manager... ");
  400f43:	e8 b8 fc ff ff       	callq  400c00 <printf@plt>
    fflush(stdout);
  400f48:	48 8b 3d e1 b3 20 00 	mov    0x20b3e1(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  400f4f:	e8 0c fe ff ff       	callq  400d60 <fflush@plt>

    randomPtr = random_alloc();
  400f54:	31 c0                	xor    %eax,%eax
  400f56:	e8 a5 41 00 00       	callq  405100 <random_alloc>
    assert(randomPtr != NULL);
  400f5b:	48 85 c0             	test   %rax,%rax
    long numTable = sizeof(manager_add) / sizeof(manager_add[0]);

    printf("Initializing manager... ");
    fflush(stdout);

    randomPtr = random_alloc();
  400f5e:	48 89 c5             	mov    %rax,%rbp
    assert(randomPtr != NULL);
  400f61:	0f 84 76 06 00 00    	je     4015dd <main+0x7fd>

    managerPtr = manager_alloc();
  400f67:	31 c0                	xor    %eax,%eax
  400f69:	e8 22 11 00 00       	callq  402090 <manager_alloc>
    assert(managerPtr != NULL);
  400f6e:	48 85 c0             	test   %rax,%rax
    fflush(stdout);

    randomPtr = random_alloc();
    assert(randomPtr != NULL);

    managerPtr = manager_alloc();
  400f71:	48 89 04 24          	mov    %rax,(%rsp)
    assert(managerPtr != NULL);
  400f75:	0f 84 05 07 00 00    	je     401680 <main+0x8a0>

    numRelation = (long)global_params[PARAM_RELATIONS];
  400f7b:	f2 44 0f 10 15 2c b8 	movsd  0x20b82c(%rip),%xmm10        # 60c7b0 <global_params+0x390>
  400f82:	20 00 
  400f84:	f2 49 0f 2c da       	cvttsd2si %xmm10,%rbx
    ids = (long*)malloc(numRelation * sizeof(long));
  400f89:	48 8d 3c dd 00 00 00 	lea    0x0(,%rbx,8),%rdi
  400f90:	00 
  400f91:	e8 ea fc ff ff       	callq  400c80 <malloc@plt>
    for (i = 0; i < numRelation; i++) {
  400f96:	48 85 db             	test   %rbx,%rbx

    managerPtr = manager_alloc();
    assert(managerPtr != NULL);

    numRelation = (long)global_params[PARAM_RELATIONS];
    ids = (long*)malloc(numRelation * sizeof(long));
  400f99:	49 89 c4             	mov    %rax,%r12
    for (i = 0; i < numRelation; i++) {
  400f9c:	0f 8e 53 01 00 00    	jle    4010f5 <main+0x315>
  400fa2:	48 c1 e0 3c          	shl    $0x3c,%rax
  400fa6:	48 c1 e8 3f          	shr    $0x3f,%rax
  400faa:	48 39 c3             	cmp    %rax,%rbx
  400fad:	48 0f 46 c3          	cmovbe %rbx,%rax
  400fb1:	48 83 fb 0a          	cmp    $0xa,%rbx
  400fb5:	48 89 c2             	mov    %rax,%rdx
  400fb8:	48 89 d8             	mov    %rbx,%rax
  400fbb:	0f 87 70 05 00 00    	ja     401531 <main+0x751>
  400fc1:	48 83 f8 01          	cmp    $0x1,%rax
        ids[i] = i + 1;
  400fc5:	49 c7 04 24 01 00 00 	movq   $0x1,(%r12)
  400fcc:	00 
  400fcd:	0f 86 ce 05 00 00    	jbe    4015a1 <main+0x7c1>
  400fd3:	48 83 f8 02          	cmp    $0x2,%rax
  400fd7:	49 c7 44 24 08 02 00 	movq   $0x2,0x8(%r12)
  400fde:	00 00 
  400fe0:	0f 86 93 05 00 00    	jbe    401579 <main+0x799>
  400fe6:	48 83 f8 03          	cmp    $0x3,%rax
  400fea:	49 c7 44 24 10 03 00 	movq   $0x3,0x10(%r12)
  400ff1:	00 00 
  400ff3:	0f 86 8a 05 00 00    	jbe    401583 <main+0x7a3>
  400ff9:	48 83 f8 04          	cmp    $0x4,%rax
  400ffd:	49 c7 44 24 18 04 00 	movq   $0x4,0x18(%r12)
  401004:	00 00 
  401006:	0f 86 45 05 00 00    	jbe    401551 <main+0x771>
  40100c:	48 83 f8 05          	cmp    $0x5,%rax
  401010:	49 c7 44 24 20 05 00 	movq   $0x5,0x20(%r12)
  401017:	00 00 
  401019:	0f 86 3c 05 00 00    	jbe    40155b <main+0x77b>
  40101f:	48 83 f8 06          	cmp    $0x6,%rax
  401023:	49 c7 44 24 28 06 00 	movq   $0x6,0x28(%r12)
  40102a:	00 00 
  40102c:	0f 86 33 05 00 00    	jbe    401565 <main+0x785>
  401032:	48 83 f8 07          	cmp    $0x7,%rax
  401036:	49 c7 44 24 30 07 00 	movq   $0x7,0x30(%r12)
  40103d:	00 00 
  40103f:	0f 86 2a 05 00 00    	jbe    40156f <main+0x78f>
  401045:	48 83 f8 08          	cmp    $0x8,%rax
  401049:	49 c7 44 24 38 08 00 	movq   $0x8,0x38(%r12)
  401050:	00 00 
  401052:	0f 86 35 05 00 00    	jbe    40158d <main+0x7ad>
  401058:	48 83 f8 09          	cmp    $0x9,%rax
  40105c:	49 c7 44 24 40 09 00 	movq   $0x9,0x40(%r12)
  401063:	00 00 
  401065:	0f 86 2c 05 00 00    	jbe    401597 <main+0x7b7>
  40106b:	49 c7 44 24 48 0a 00 	movq   $0xa,0x48(%r12)
  401072:	00 00 
  401074:	b9 0a 00 00 00       	mov    $0xa,%ecx
  401079:	48 39 c3             	cmp    %rax,%rbx
  40107c:	74 77                	je     4010f5 <main+0x315>
  40107e:	48 89 df             	mov    %rbx,%rdi
  401081:	48 29 c7             	sub    %rax,%rdi
  401084:	48 89 fe             	mov    %rdi,%rsi
  401087:	48 d1 ee             	shr    %rsi
  40108a:	49 89 f0             	mov    %rsi,%r8
  40108d:	4d 01 c0             	add    %r8,%r8
  401090:	74 5b                	je     4010ed <main+0x30d>
  401092:	48 8d 51 01          	lea    0x1(%rcx),%rdx
    managerPtr = manager_alloc();
    assert(managerPtr != NULL);

    numRelation = (long)global_params[PARAM_RELATIONS];
    ids = (long*)malloc(numRelation * sizeof(long));
    for (i = 0; i < numRelation; i++) {
  401096:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  40109b:	f3 0f 7e 44 24 10    	movq   0x10(%rsp),%xmm0
  4010a1:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  4010a6:	49 8d 14 c4          	lea    (%r12,%rax,8),%rdx
  4010aa:	31 c0                	xor    %eax,%eax
  4010ac:	66 0f 6f 1d 3c 83 00 	movdqa 0x833c(%rip),%xmm3        # 4093f0 <__PRETTY_FUNCTION__.3923+0x5e>
  4010b3:	00 
  4010b4:	0f 16 44 24 08       	movhps 0x8(%rsp),%xmm0
  4010b9:	66 0f 6f 15 3f 83 00 	movdqa 0x833f(%rip),%xmm2        # 409400 <__PRETTY_FUNCTION__.3923+0x6e>
  4010c0:	00 
  4010c1:	66 0f 6f c8          	movdqa %xmm0,%xmm1
  4010c5:	48 83 c0 01          	add    $0x1,%rax
        ids[i] = i + 1;
  4010c9:	66 0f d4 c2          	paddq  %xmm2,%xmm0
  4010cd:	48 83 c2 10          	add    $0x10,%rdx
  4010d1:	66 0f 7f 42 f0       	movdqa %xmm0,-0x10(%rdx)
  4010d6:	66 0f d4 cb          	paddq  %xmm3,%xmm1
  4010da:	48 39 c6             	cmp    %rax,%rsi
  4010dd:	76 06                	jbe    4010e5 <main+0x305>
  4010df:	66 0f 6f c1          	movdqa %xmm1,%xmm0
  4010e3:	eb dc                	jmp    4010c1 <main+0x2e1>
  4010e5:	4c 01 c1             	add    %r8,%rcx
  4010e8:	4c 39 c7             	cmp    %r8,%rdi
  4010eb:	74 08                	je     4010f5 <main+0x315>
  4010ed:	48 8d 41 01          	lea    0x1(%rcx),%rax
  4010f1:	49 89 04 cc          	mov    %rax,(%r12,%rcx,8)
  4010f5:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  4010fa:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    }

    for (t = 0; t < numTable; t++) {

        /* Shuffle ids */
        for (i = 0; i < numRelation; i++) {
  4010ff:	48 85 db             	test   %rbx,%rbx
  401102:	0f 8e df 00 00 00    	jle    4011e7 <main+0x407>
  401108:	45 31 ed             	xor    %r13d,%r13d
  40110b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            long x = random_generate(randomPtr) % numRelation;
  401110:	48 89 ef             	mov    %rbp,%rdi
    }

    for (t = 0; t < numTable; t++) {

        /* Shuffle ids */
        for (i = 0; i < numRelation; i++) {
  401113:	49 83 c5 01          	add    $0x1,%r13
            long x = random_generate(randomPtr) % numRelation;
  401117:	e8 a4 40 00 00       	callq  4051c0 <random_generate>
  40111c:	31 d2                	xor    %edx,%edx
            long y = random_generate(randomPtr) % numRelation;
  40111e:	48 89 ef             	mov    %rbp,%rdi

    for (t = 0; t < numTable; t++) {

        /* Shuffle ids */
        for (i = 0; i < numRelation; i++) {
            long x = random_generate(randomPtr) % numRelation;
  401121:	48 f7 f3             	div    %rbx
  401124:	49 89 d6             	mov    %rdx,%r14
            long y = random_generate(randomPtr) % numRelation;
  401127:	e8 94 40 00 00       	callq  4051c0 <random_generate>
  40112c:	31 d2                	xor    %edx,%edx
            long tmp = ids[x];
  40112e:	4b 8d 0c f4          	lea    (%r12,%r14,8),%rcx
    for (t = 0; t < numTable; t++) {

        /* Shuffle ids */
        for (i = 0; i < numRelation; i++) {
            long x = random_generate(randomPtr) % numRelation;
            long y = random_generate(randomPtr) % numRelation;
  401132:	48 f7 f3             	div    %rbx
            long tmp = ids[x];
  401135:	48 8b 31             	mov    (%rcx),%rsi
    }

    for (t = 0; t < numTable; t++) {

        /* Shuffle ids */
        for (i = 0; i < numRelation; i++) {
  401138:	49 39 dd             	cmp    %rbx,%r13
            long x = random_generate(randomPtr) % numRelation;
            long y = random_generate(randomPtr) % numRelation;
            long tmp = ids[x];
            ids[x] = ids[y];
  40113b:	49 8d 04 d4          	lea    (%r12,%rdx,8),%rax
  40113f:	48 8b 10             	mov    (%rax),%rdx
  401142:	48 89 11             	mov    %rdx,(%rcx)
            ids[y] = tmp;
  401145:	48 89 30             	mov    %rsi,(%rax)
    }

    for (t = 0; t < numTable; t++) {

        /* Shuffle ids */
        for (i = 0; i < numRelation; i++) {
  401148:	75 c6                	jne    401110 <main+0x330>
  40114a:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  40114f:	45 31 ff             	xor    %r15d,%r15d
  401152:	48 8b 00             	mov    (%rax),%rax
  401155:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40115a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
  401160:	48 89 ef             	mov    %rbp,%rdi
        }

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
  401163:	4f 8b 34 fc          	mov    (%r12,%r15,8),%r14
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
  401167:	e8 54 40 00 00       	callq  4051c0 <random_generate>
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
  40116c:	48 89 ef             	mov    %rbp,%rdi

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
  40116f:	49 89 c5             	mov    %rax,%r13
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
  401172:	e8 49 40 00 00       	callq  4051c0 <random_generate>
  401177:	48 89 c1             	mov    %rax,%rcx
  40117a:	48 b8 cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rax
  401181:	cc cc cc 

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
  401184:	4d 89 e9             	mov    %r13,%r9
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
  401187:	48 f7 e1             	mul    %rcx
            status = manager_add[t](managerPtr, id, num, price);
  40118a:	4c 89 f6             	mov    %r14,%rsi
  40118d:	48 8b 3c 24          	mov    (%rsp),%rdi
        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
  401191:	48 c1 ea 02          	shr    $0x2,%rdx
  401195:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  401199:	48 29 c1             	sub    %rax,%rcx
  40119c:	48 8d 04 89          	lea    (%rcx,%rcx,4),%rax
  4011a0:	48 8d 4c 00 32       	lea    0x32(%rax,%rax,1),%rcx

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
  4011a5:	48 b8 cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rax
  4011ac:	cc cc cc 
  4011af:	49 f7 e5             	mul    %r13
  4011b2:	48 c1 ea 02          	shr    $0x2,%rdx
  4011b6:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  4011ba:	49 29 c1             	sub    %rax,%r9
  4011bd:	4b 8d 44 89 05       	lea    0x5(%r9,%r9,4),%rax
  4011c2:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
            status = manager_add[t](managerPtr, id, num, price);
  4011c6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
  4011cb:	48 c1 e2 02          	shl    $0x2,%rdx
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
            status = manager_add[t](managerPtr, id, num, price);
  4011cf:	ff d0                	callq  *%rax
            assert(status);
  4011d1:	48 85 c0             	test   %rax,%rax
  4011d4:	0f 84 d1 03 00 00    	je     4015ab <main+0x7cb>
            ids[x] = ids[y];
            ids[y] = tmp;
        }

        /* Populate table */
        for (i = 0; i < numRelation; i++) {
  4011da:	49 83 c7 01          	add    $0x1,%r15
  4011de:	49 39 df             	cmp    %rbx,%r15
  4011e1:	0f 85 79 ff ff ff    	jne    401160 <main+0x380>
  4011e7:	48 83 44 24 10 08    	addq   $0x8,0x10(%rsp)
    ids = (long*)malloc(numRelation * sizeof(long));
    for (i = 0; i < numRelation; i++) {
        ids[i] = i + 1;
    }

    for (t = 0; t < numTable; t++) {
  4011ed:	48 8d 44 24 60       	lea    0x60(%rsp),%rax
  4011f2:	48 39 44 24 10       	cmp    %rax,0x10(%rsp)
  4011f7:	0f 85 02 ff ff ff    	jne    4010ff <main+0x31f>
            assert(status);
        }

    } /* for t */

    puts("done.");
  4011fd:	bf 00 8f 40 00       	mov    $0x408f00,%edi
  401202:	e8 19 fa ff ff       	callq  400c20 <puts@plt>
    fflush(stdout);
  401207:	48 8b 3d 22 b1 20 00 	mov    0x20b122(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  40120e:	e8 4d fb ff ff       	callq  400d60 <fflush@plt>

    random_free(randomPtr);
  401213:	48 89 ef             	mov    %rbp,%rdi
  401216:	e8 65 3f 00 00       	callq  405180 <random_free>
    free(ids);
  40121b:	4c 89 e7             	mov    %r12,%rdi
  40121e:	e8 8d fa ff ff       	callq  400cb0 <free@plt>
{
    random_t* randomPtr;
    client_t** clients;
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
    long numTransaction = (long)global_params[PARAM_TRANSACTIONS];
  401223:	f2 0f 10 2d 95 b5 20 	movsd  0x20b595(%rip),%xmm5        # 60c7c0 <global_params+0x3a0>
  40122a:	00 
    long numRelation = (long)global_params[PARAM_RELATIONS];
    long percentQuery = (long)global_params[PARAM_QUERIES];
    long queryRange;
    long percentUser = (long)global_params[PARAM_USER];

    printf("Initializing clients... ");
  40122b:	bf 73 8f 40 00       	mov    $0x408f73,%edi
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
    long numTransaction = (long)global_params[PARAM_TRANSACTIONS];
    long numTransactionPerClient;
    long numQueryPerTransaction = (long)global_params[PARAM_NUMBER];
    long numRelation = (long)global_params[PARAM_RELATIONS];
  401230:	f2 0f 10 3d 78 b5 20 	movsd  0x20b578(%rip),%xmm7        # 60c7b0 <global_params+0x390>
  401237:	00 
{
    random_t* randomPtr;
    client_t** clients;
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
    long numTransaction = (long)global_params[PARAM_TRANSACTIONS];
  401238:	f2 48 0f 2c c5       	cvttsd2si %xmm5,%rax
    long numTransactionPerClient;
    long numQueryPerTransaction = (long)global_params[PARAM_NUMBER];
    long numRelation = (long)global_params[PARAM_RELATIONS];
    long percentQuery = (long)global_params[PARAM_QUERIES];
  40123d:	f2 44 0f 10 05 62 b5 	movsd  0x20b562(%rip),%xmm8        # 60c7a8 <global_params+0x388>
  401244:	20 00 
    long queryRange;
    long percentUser = (long)global_params[PARAM_USER];
  401246:	f2 44 0f 10 0d 79 b5 	movsd  0x20b579(%rip),%xmm9        # 60c7c8 <global_params+0x3a8>
  40124d:	20 00 
initializeClients (manager_t* managerPtr)
{
    random_t* randomPtr;
    client_t** clients;
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
  40124f:	f2 0f 10 25 e1 b4 20 	movsd  0x20b4e1(%rip),%xmm4        # 60c738 <global_params+0x318>
  401256:	00 
    long numTransaction = (long)global_params[PARAM_TRANSACTIONS];
    long numTransactionPerClient;
    long numQueryPerTransaction = (long)global_params[PARAM_NUMBER];
  401257:	f2 0f 10 35 31 b5 20 	movsd  0x20b531(%rip),%xmm6        # 60c790 <global_params+0x370>
  40125e:	00 
initializeClients (manager_t* managerPtr)
{
    random_t* randomPtr;
    client_t** clients;
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
  40125f:	f2 48 0f 2c ec       	cvttsd2si %xmm4,%rbp
    long numTransaction = (long)global_params[PARAM_TRANSACTIONS];
    long numTransactionPerClient;
    long numQueryPerTransaction = (long)global_params[PARAM_NUMBER];
  401264:	f2 4c 0f 2c fe       	cvttsd2si %xmm6,%r15
{
    random_t* randomPtr;
    client_t** clients;
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
    long numTransaction = (long)global_params[PARAM_TRANSACTIONS];
  401269:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    long numTransactionPerClient;
    long numQueryPerTransaction = (long)global_params[PARAM_NUMBER];
    long numRelation = (long)global_params[PARAM_RELATIONS];
  40126e:	f2 48 0f 2c c7       	cvttsd2si %xmm7,%rax
  401273:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
    long percentQuery = (long)global_params[PARAM_QUERIES];
  401278:	f2 49 0f 2c c0       	cvttsd2si %xmm8,%rax
  40127d:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    long queryRange;
    long percentUser = (long)global_params[PARAM_USER];
  401282:	f2 49 0f 2c c1       	cvttsd2si %xmm9,%rax
  401287:	48 89 44 24 08       	mov    %rax,0x8(%rsp)

    printf("Initializing clients... ");
  40128c:	31 c0                	xor    %eax,%eax
  40128e:	e8 6d f9 ff ff       	callq  400c00 <printf@plt>
    fflush(stdout);
  401293:	48 8b 3d 96 b0 20 00 	mov    0x20b096(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  40129a:	e8 c1 fa ff ff       	callq  400d60 <fflush@plt>

    randomPtr = random_alloc();
  40129f:	31 c0                	xor    %eax,%eax
  4012a1:	e8 5a 3e 00 00       	callq  405100 <random_alloc>
    assert(randomPtr != NULL);
  4012a6:	48 85 c0             	test   %rax,%rax
    long percentUser = (long)global_params[PARAM_USER];

    printf("Initializing clients... ");
    fflush(stdout);

    randomPtr = random_alloc();
  4012a9:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
    assert(randomPtr != NULL);
  4012ae:	0f 84 e5 03 00 00    	je     401699 <main+0x8b9>

    clients = (client_t**)malloc(numClient * sizeof(client_t*));
  4012b4:	48 8d 3c ed 00 00 00 	lea    0x0(,%rbp,8),%rdi
  4012bb:	00 
  4012bc:	e8 bf f9 ff ff       	callq  400c80 <malloc@plt>
    assert(clients != NULL);
  4012c1:	48 85 c0             	test   %rax,%rax
    fflush(stdout);

    randomPtr = random_alloc();
    assert(randomPtr != NULL);

    clients = (client_t**)malloc(numClient * sizeof(client_t*));
  4012c4:	48 89 c3             	mov    %rax,%rbx
    assert(clients != NULL);
  4012c7:	0f 84 e5 03 00 00    	je     4016b2 <main+0x8d2>
    numTransactionPerClient = (long)((double)numTransaction / (double)numClient + 0.5);
  4012cd:	f2 48 0f 2a cd       	cvtsi2sd %rbp,%xmm1
  4012d2:	f2 48 0f 2a 44 24 10 	cvtsi2sdq 0x10(%rsp),%xmm0
    queryRange = (long)((double)percentQuery / 100.0 * (double)numRelation + 0.5);
  4012d9:	f2 48 0f 2a 54 24 18 	cvtsi2sdq 0x18(%rsp),%xmm2

    for (i = 0; i < numClient; i++) {
  4012e0:	45 31 e4             	xor    %r12d,%r12d
  4012e3:	48 85 ed             	test   %rbp,%rbp
    randomPtr = random_alloc();
    assert(randomPtr != NULL);

    clients = (client_t**)malloc(numClient * sizeof(client_t*));
    assert(clients != NULL);
    numTransactionPerClient = (long)((double)numTransaction / (double)numClient + 0.5);
  4012e6:	f2 0f 5e c1          	divsd  %xmm1,%xmm0
  4012ea:	f2 0f 10 0d b6 80 00 	movsd  0x80b6(%rip),%xmm1        # 4093a8 <__PRETTY_FUNCTION__.3923+0x16>
  4012f1:	00 
  4012f2:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  4012f6:	f2 4c 0f 2c e8       	cvttsd2si %xmm0,%r13
    queryRange = (long)((double)percentQuery / 100.0 * (double)numRelation + 0.5);
  4012fb:	f2 48 0f 2a 44 24 20 	cvtsi2sdq 0x20(%rsp),%xmm0
  401302:	f2 0f 5e 05 96 80 00 	divsd  0x8096(%rip),%xmm0        # 4093a0 <__PRETTY_FUNCTION__.3923+0xe>
  401309:	00 
  40130a:	f2 0f 59 c2          	mulsd  %xmm2,%xmm0
  40130e:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  401312:	f2 4c 0f 2c f0       	cvttsd2si %xmm0,%r14

    for (i = 0; i < numClient; i++) {
  401317:	7e 37                	jle    401350 <main+0x570>
  401319:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        clients[i] = client_alloc(i,
  401320:	4c 8b 4c 24 08       	mov    0x8(%rsp),%r9
  401325:	48 8b 34 24          	mov    (%rsp),%rsi
  401329:	4d 89 f0             	mov    %r14,%r8
  40132c:	4c 89 f9             	mov    %r15,%rcx
  40132f:	4c 89 ea             	mov    %r13,%rdx
  401332:	4c 89 e7             	mov    %r12,%rdi
  401335:	e8 e6 04 00 00       	callq  401820 <client_alloc>
                                  managerPtr,
                                  numTransactionPerClient,
                                  numQueryPerTransaction,
                                  queryRange,
                                  percentUser);
        assert(clients[i]  != NULL);
  40133a:	48 85 c0             	test   %rax,%rax
    assert(clients != NULL);
    numTransactionPerClient = (long)((double)numTransaction / (double)numClient + 0.5);
    queryRange = (long)((double)percentQuery / 100.0 * (double)numRelation + 0.5);

    for (i = 0; i < numClient; i++) {
        clients[i] = client_alloc(i,
  40133d:	4a 89 04 e3          	mov    %rax,(%rbx,%r12,8)
                                  managerPtr,
                                  numTransactionPerClient,
                                  numQueryPerTransaction,
                                  queryRange,
                                  percentUser);
        assert(clients[i]  != NULL);
  401341:	0f 84 7d 02 00 00    	je     4015c4 <main+0x7e4>
    clients = (client_t**)malloc(numClient * sizeof(client_t*));
    assert(clients != NULL);
    numTransactionPerClient = (long)((double)numTransaction / (double)numClient + 0.5);
    queryRange = (long)((double)percentQuery / 100.0 * (double)numRelation + 0.5);

    for (i = 0; i < numClient; i++) {
  401347:	49 83 c4 01          	add    $0x1,%r12
  40134b:	49 39 ec             	cmp    %rbp,%r12
  40134e:	75 d0                	jne    401320 <main+0x540>
                                  queryRange,
                                  percentUser);
        assert(clients[i]  != NULL);
    }

    puts("done.");
  401350:	bf 00 8f 40 00       	mov    $0x408f00,%edi
  401355:	e8 c6 f8 ff ff       	callq  400c20 <puts@plt>
    printf("    Transactions        = %li\n", numTransaction);
  40135a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40135f:	bf 58 92 40 00       	mov    $0x409258,%edi
  401364:	31 c0                	xor    %eax,%eax
  401366:	e8 95 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Clients             = %li\n", numClient);
  40136b:	48 89 ee             	mov    %rbp,%rsi
  40136e:	bf 78 92 40 00       	mov    $0x409278,%edi
  401373:	31 c0                	xor    %eax,%eax
  401375:	e8 86 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Transactions/client = %li\n", numTransactionPerClient);
  40137a:	4c 89 ee             	mov    %r13,%rsi
  40137d:	bf 98 92 40 00       	mov    $0x409298,%edi
  401382:	31 c0                	xor    %eax,%eax
  401384:	e8 77 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Queries/transaction = %li\n", numQueryPerTransaction);
  401389:	4c 89 fe             	mov    %r15,%rsi
  40138c:	bf b8 92 40 00       	mov    $0x4092b8,%edi
  401391:	31 c0                	xor    %eax,%eax
  401393:	e8 68 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Relations           = %li\n", numRelation);
  401398:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  40139d:	bf d8 92 40 00       	mov    $0x4092d8,%edi
  4013a2:	31 c0                	xor    %eax,%eax
  4013a4:	e8 57 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Query percent       = %li\n", percentQuery);
  4013a9:	48 8b 74 24 20       	mov    0x20(%rsp),%rsi
  4013ae:	bf f8 92 40 00       	mov    $0x4092f8,%edi
  4013b3:	31 c0                	xor    %eax,%eax
  4013b5:	e8 46 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Query range         = %li\n", queryRange);
  4013ba:	4c 89 f6             	mov    %r14,%rsi
  4013bd:	bf 18 93 40 00       	mov    $0x409318,%edi
  4013c2:	31 c0                	xor    %eax,%eax
  4013c4:	e8 37 f8 ff ff       	callq  400c00 <printf@plt>
    printf("    Percent user        = %li\n", percentUser);
  4013c9:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  4013ce:	bf 38 93 40 00       	mov    $0x409338,%edi
  4013d3:	31 c0                	xor    %eax,%eax
  4013d5:	e8 26 f8 ff ff       	callq  400c00 <printf@plt>
    fflush(stdout);
  4013da:	48 8b 3d 4f af 20 00 	mov    0x20af4f(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  4013e1:	e8 7a f9 ff ff       	callq  400d60 <fflush@plt>

    random_free(randomPtr);
  4013e6:	48 8b 7c 24 28       	mov    0x28(%rsp),%rdi
  4013eb:	e8 90 3d 00 00       	callq  405180 <random_free>
    SIM_GET_NUM_CPU(global_params[PARAM_CLIENTS]);
    managerPtr = initializeManager();
    assert(managerPtr != NULL);
    clients = initializeClients(managerPtr);
    assert(clients != NULL);
    long numThread = global_params[PARAM_CLIENTS];
  4013f0:	f2 0f 10 15 40 b3 20 	movsd  0x20b340(%rip),%xmm2        # 60c738 <global_params+0x318>
  4013f7:	00 
    printf("numThread = %ld\n", numThread);
  4013f8:	bf a3 8f 40 00       	mov    $0x408fa3,%edi
  4013fd:	31 c0                	xor    %eax,%eax
    SIM_GET_NUM_CPU(global_params[PARAM_CLIENTS]);
    managerPtr = initializeManager();
    assert(managerPtr != NULL);
    clients = initializeClients(managerPtr);
    assert(clients != NULL);
    long numThread = global_params[PARAM_CLIENTS];
  4013ff:	f2 48 0f 2c ea       	cvttsd2si %xmm2,%rbp
    printf("numThread = %ld\n", numThread);
  401404:	48 89 ee             	mov    %rbp,%rsi
  401407:	e8 f4 f7 ff ff       	callq  400c00 <printf@plt>
    TM_STARTUP(numThread);
    P_MEMORY_STARTUP(numThread);
    thread_startup(numThread);
  40140c:	48 89 ef             	mov    %rbp,%rdi
  40140f:	e8 ec 6d 00 00       	callq  408200 <thread_startup>

    /* Run transactions */
    printf("Running clients... ");
  401414:	bf b4 8f 40 00       	mov    $0x408fb4,%edi
  401419:	31 c0                	xor    %eax,%eax
  40141b:	e8 e0 f7 ff ff       	callq  400c00 <printf@plt>
    fflush(stdout);
  401420:	48 8b 3d 09 af 20 00 	mov    0x20af09(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  401427:	e8 34 f9 ff ff       	callq  400d60 <fflush@plt>
    TIMER_READ(start);
  40142c:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  401431:	31 f6                	xor    %esi,%esi
  401433:	e8 28 f8 ff ff       	callq  400c60 <gettimeofday@plt>
#pragma omp parallel
    {
        client_run(clients);
    }
#else
    thread_start(client_run, (void*)clients);
  401438:	48 89 de             	mov    %rbx,%rsi
  40143b:	bf c0 18 40 00       	mov    $0x4018c0,%edi
  401440:	e8 4b 75 00 00       	callq  408990 <thread_start>
#endif
    GOTO_REAL();
    TIMER_READ(stop);
  401445:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
  40144a:	31 f6                	xor    %esi,%esi
  40144c:	e8 0f f8 ff ff       	callq  400c60 <gettimeofday@plt>
    puts("done.");
  401451:	bf 00 8f 40 00       	mov    $0x408f00,%edi
  401456:	e8 c5 f7 ff ff       	callq  400c20 <puts@plt>
    printf("Time = %0.6lf\n",
           TIMER_DIFF_SECONDS(start, stop));
  40145b:	f2 48 0f 2a 4c 24 48 	cvtsi2sdq 0x48(%rsp),%xmm1
  401462:	f2 48 0f 2a 54 24 38 	cvtsi2sdq 0x38(%rsp),%xmm2
  401469:	f2 0f 10 1d 6f 7f 00 	movsd  0x7f6f(%rip),%xmm3        # 4093e0 <__PRETTY_FUNCTION__.3923+0x4e>
  401470:	00 
  401471:	f2 48 0f 2a 44 24 40 	cvtsi2sdq 0x40(%rsp),%xmm0
    thread_start(client_run, (void*)clients);
#endif
    GOTO_REAL();
    TIMER_READ(stop);
    puts("done.");
    printf("Time = %0.6lf\n",
  401478:	bf c8 8f 40 00       	mov    $0x408fc8,%edi
  40147d:	b8 01 00 00 00       	mov    $0x1,%eax
           TIMER_DIFF_SECONDS(start, stop));
  401482:	f2 0f 5e cb          	divsd  %xmm3,%xmm1
  401486:	f2 0f 5e d3          	divsd  %xmm3,%xmm2
  40148a:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  40148e:	f2 48 0f 2a 4c 24 30 	cvtsi2sdq 0x30(%rsp),%xmm1
  401495:	f2 0f 58 ca          	addsd  %xmm2,%xmm1
    thread_start(client_run, (void*)clients);
#endif
    GOTO_REAL();
    TIMER_READ(stop);
    puts("done.");
    printf("Time = %0.6lf\n",
  401499:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
  40149d:	e8 5e f7 ff ff       	callq  400c00 <printf@plt>
           TIMER_DIFF_SECONDS(start, stop));
    fflush(stdout);
  4014a2:	48 8b 3d 87 ae 20 00 	mov    0x20ae87(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  4014a9:	e8 b2 f8 ff ff       	callq  400d60 <fflush@plt>
    checkTables(managerPtr);
  4014ae:	48 8b 3c 24          	mov    (%rsp),%rdi
  4014b2:	e8 39 25 00 00       	callq  4039f0 <checkTables>

    /* Clean up */
    printf("Deallocating memory... ");
  4014b7:	bf d7 8f 40 00       	mov    $0x408fd7,%edi
  4014bc:	31 c0                	xor    %eax,%eax
freeClients (client_t** clients)
{
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];

    for (i = 0; i < numClient; i++) {
  4014be:	31 ed                	xor    %ebp,%ebp
           TIMER_DIFF_SECONDS(start, stop));
    fflush(stdout);
    checkTables(managerPtr);

    /* Clean up */
    printf("Deallocating memory... ");
  4014c0:	e8 3b f7 ff ff       	callq  400c00 <printf@plt>
    fflush(stdout);
  4014c5:	48 8b 3d 64 ae 20 00 	mov    0x20ae64(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  4014cc:	e8 8f f8 ff ff       	callq  400d60 <fflush@plt>
 */
static void
freeClients (client_t** clients)
{
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];
  4014d1:	f2 0f 10 1d 5f b2 20 	movsd  0x20b25f(%rip),%xmm3        # 60c738 <global_params+0x318>
  4014d8:	00 
  4014d9:	f2 4c 0f 2c e3       	cvttsd2si %xmm3,%r12

    for (i = 0; i < numClient; i++) {
  4014de:	4d 85 e4             	test   %r12,%r12
  4014e1:	7e 17                	jle    4014fa <main+0x71a>
  4014e3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        client_t* clientPtr = clients[i];
        client_free(clientPtr);
  4014e8:	48 8b 3c eb          	mov    (%rbx,%rbp,8),%rdi
freeClients (client_t** clients)
{
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];

    for (i = 0; i < numClient; i++) {
  4014ec:	48 83 c5 01          	add    $0x1,%rbp
        client_t* clientPtr = clients[i];
        client_free(clientPtr);
  4014f0:	e8 bb 03 00 00       	callq  4018b0 <client_free>
freeClients (client_t** clients)
{
    long i;
    long numClient = (long)global_params[PARAM_CLIENTS];

    for (i = 0; i < numClient; i++) {
  4014f5:	4c 39 e5             	cmp    %r12,%rbp
  4014f8:	75 ee                	jne    4014e8 <main+0x708>
    fflush(stdout);
    freeClients(clients);
    /*
     * TODO: The contents of the manager's table need to be deallocated.
     */
    manager_free(managerPtr);
  4014fa:	48 8b 3c 24          	mov    (%rsp),%rdi
  4014fe:	e8 6d 0c 00 00       	callq  402170 <manager_free>
    puts("done.");
  401503:	bf 00 8f 40 00       	mov    $0x408f00,%edi
  401508:	e8 13 f7 ff ff       	callq  400c20 <puts@plt>
    fflush(stdout);
  40150d:	48 8b 3d 1c ae 20 00 	mov    0x20ae1c(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  401514:	e8 47 f8 ff ff       	callq  400d60 <fflush@plt>
    TM_SHUTDOWN();
    P_MEMORY_SHUTDOWN();

    GOTO_SIM();

    thread_shutdown();
  401519:	31 c0                	xor    %eax,%eax
  40151b:	e8 c0 73 00 00       	callq  4088e0 <thread_shutdown>

    MAIN_RETURN(0);
}
  401520:	48 83 c4 68          	add    $0x68,%rsp
  401524:	31 c0                	xor    %eax,%eax
  401526:	5b                   	pop    %rbx
  401527:	5d                   	pop    %rbp
  401528:	41 5c                	pop    %r12
  40152a:	41 5d                	pop    %r13
  40152c:	41 5e                	pop    %r14
  40152e:	41 5f                	pop    %r15
  401530:	c3                   	retq   
    managerPtr = manager_alloc();
    assert(managerPtr != NULL);

    numRelation = (long)global_params[PARAM_RELATIONS];
    ids = (long*)malloc(numRelation * sizeof(long));
    for (i = 0; i < numRelation; i++) {
  401531:	31 c0                	xor    %eax,%eax
  401533:	31 c9                	xor    %ecx,%ecx
  401535:	48 85 d2             	test   %rdx,%rdx
  401538:	0f 84 40 fb ff ff    	je     40107e <main+0x29e>
  40153e:	48 89 d0             	mov    %rdx,%rax
  401541:	e9 7b fa ff ff       	jmpq   400fc1 <main+0x1e1>
  401546:	8b 05 bc ad 20 00    	mov    0x20adbc(%rip),%eax        # 60c308 <opterr@@GLIBC_2.2.5>
  40154c:	e9 bf f9 ff ff       	jmpq   400f10 <main+0x130>
        ids[i] = i + 1;
  401551:	b9 04 00 00 00       	mov    $0x4,%ecx
  401556:	e9 1e fb ff ff       	jmpq   401079 <main+0x299>
  40155b:	b9 05 00 00 00       	mov    $0x5,%ecx
  401560:	e9 14 fb ff ff       	jmpq   401079 <main+0x299>
  401565:	b9 06 00 00 00       	mov    $0x6,%ecx
  40156a:	e9 0a fb ff ff       	jmpq   401079 <main+0x299>
  40156f:	b9 07 00 00 00       	mov    $0x7,%ecx
  401574:	e9 00 fb ff ff       	jmpq   401079 <main+0x299>
  401579:	b9 02 00 00 00       	mov    $0x2,%ecx
  40157e:	e9 f6 fa ff ff       	jmpq   401079 <main+0x299>
  401583:	b9 03 00 00 00       	mov    $0x3,%ecx
  401588:	e9 ec fa ff ff       	jmpq   401079 <main+0x299>
  40158d:	b9 08 00 00 00       	mov    $0x8,%ecx
  401592:	e9 e2 fa ff ff       	jmpq   401079 <main+0x299>
  401597:	b9 09 00 00 00       	mov    $0x9,%ecx
  40159c:	e9 d8 fa ff ff       	jmpq   401079 <main+0x299>
  4015a1:	b9 01 00 00 00       	mov    $0x1,%ecx
  4015a6:	e9 ce fa ff ff       	jmpq   401079 <main+0x299>
            bool_t status;
            long id = ids[i];
            long num = ((random_generate(randomPtr) % 5) + 1) * 100;
            long price = ((random_generate(randomPtr) % 5) * 10) + 50;
            status = manager_add[t](managerPtr, id, num, price);
            assert(status);
  4015ab:	b9 80 93 40 00       	mov    $0x409380,%ecx
  4015b0:	ba 03 01 00 00       	mov    $0x103,%edx
  4015b5:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  4015ba:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  4015bf:	e8 8c f6 ff ff       	callq  400c50 <__assert_fail@plt>
                                  managerPtr,
                                  numTransactionPerClient,
                                  numQueryPerTransaction,
                                  queryRange,
                                  percentUser);
        assert(clients[i]  != NULL);
  4015c4:	b9 60 93 40 00       	mov    $0x409360,%ecx
  4015c9:	ba 37 01 00 00       	mov    $0x137,%edx
  4015ce:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  4015d3:	bf ef 8f 40 00       	mov    $0x408fef,%edi
  4015d8:	e8 73 f6 ff ff       	callq  400c50 <__assert_fail@plt>

    printf("Initializing manager... ");
    fflush(stdout);

    randomPtr = random_alloc();
    assert(randomPtr != NULL);
  4015dd:	b9 80 93 40 00       	mov    $0x409380,%ecx
  4015e2:	ba e6 00 00 00       	mov    $0xe6,%edx
  4015e7:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  4015ec:	bf 5a 8f 40 00       	mov    $0x408f5a,%edi
  4015f1:	e8 5a f6 ff ff       	callq  400c50 <__assert_fail@plt>
 * =============================================================================
 */
static void
displayUsage (const char* appName)
{
    printf("Usage: %s [options]\n", appName);
  4015f6:	48 8b 75 00          	mov    0x0(%rbp),%rsi
  4015fa:	bf 2c 8f 40 00       	mov    $0x408f2c,%edi
  4015ff:	31 c0                	xor    %eax,%eax
  401601:	e8 fa f5 ff ff       	callq  400c00 <printf@plt>
    puts("\nOptions:                                             (defaults)\n");
  401606:	bf 90 90 40 00       	mov    $0x409090,%edi
  40160b:	e8 10 f6 ff ff       	callq  400c20 <puts@plt>
    printf("    c <UINT>   Number of [c]lients                   (%i)\n",
  401610:	be 01 00 00 00       	mov    $0x1,%esi
  401615:	bf d8 90 40 00       	mov    $0x4090d8,%edi
  40161a:	31 c0                	xor    %eax,%eax
  40161c:	e8 df f5 ff ff       	callq  400c00 <printf@plt>
           PARAM_DEFAULT_CLIENTS);
    printf("    n <UINT>   [n]umber of user queries/transaction  (%i)\n",
  401621:	be 0a 00 00 00       	mov    $0xa,%esi
  401626:	bf 18 91 40 00       	mov    $0x409118,%edi
  40162b:	31 c0                	xor    %eax,%eax
  40162d:	e8 ce f5 ff ff       	callq  400c00 <printf@plt>
           PARAM_DEFAULT_NUMBER);
    printf("    q <UINT>   Percentage of relations [q]ueried     (%i)\n",
  401632:	be 5a 00 00 00       	mov    $0x5a,%esi
  401637:	bf 58 91 40 00       	mov    $0x409158,%edi
  40163c:	31 c0                	xor    %eax,%eax
  40163e:	e8 bd f5 ff ff       	callq  400c00 <printf@plt>
           PARAM_DEFAULT_QUERIES);
    printf("    r <UINT>   Number of possible [r]elations        (%i)\n",
  401643:	be 00 00 01 00       	mov    $0x10000,%esi
  401648:	bf 98 91 40 00       	mov    $0x409198,%edi
  40164d:	31 c0                	xor    %eax,%eax
  40164f:	e8 ac f5 ff ff       	callq  400c00 <printf@plt>
           PARAM_DEFAULT_RELATIONS);
    printf("    t <UINT>   Number of [t]ransactions              (%i)\n",
  401654:	be 00 00 00 04       	mov    $0x4000000,%esi
  401659:	bf d8 91 40 00       	mov    $0x4091d8,%edi
  40165e:	31 c0                	xor    %eax,%eax
  401660:	e8 9b f5 ff ff       	callq  400c00 <printf@plt>
           PARAM_DEFAULT_TRANSACTIONS);
    printf("    u <UINT>   Percentage of [u]ser transactions     (%i)\n",
  401665:	bf 18 92 40 00       	mov    $0x409218,%edi
  40166a:	be 50 00 00 00       	mov    $0x50,%esi
  40166f:	31 c0                	xor    %eax,%eax
  401671:	e8 8a f5 ff ff       	callq  400c00 <printf@plt>
           PARAM_DEFAULT_USER);
    exit(1);
  401676:	bf 01 00 00 00       	mov    $0x1,%edi
  40167b:	e8 c0 f5 ff ff       	callq  400c40 <exit@plt>

    randomPtr = random_alloc();
    assert(randomPtr != NULL);

    managerPtr = manager_alloc();
    assert(managerPtr != NULL);
  401680:	b9 80 93 40 00       	mov    $0x409380,%ecx
  401685:	ba e9 00 00 00       	mov    $0xe9,%edx
  40168a:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  40168f:	bf 3c 8c 40 00       	mov    $0x408c3c,%edi
  401694:	e8 b7 f5 ff ff       	callq  400c50 <__assert_fail@plt>

    printf("Initializing clients... ");
    fflush(stdout);

    randomPtr = random_alloc();
    assert(randomPtr != NULL);
  401699:	b9 60 93 40 00       	mov    $0x409360,%ecx
  40169e:	ba 29 01 00 00       	mov    $0x129,%edx
  4016a3:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  4016a8:	bf 5a 8f 40 00       	mov    $0x408f5a,%edi
  4016ad:	e8 9e f5 ff ff       	callq  400c50 <__assert_fail@plt>

    clients = (client_t**)malloc(numClient * sizeof(client_t*));
    assert(clients != NULL);
  4016b2:	b9 60 93 40 00       	mov    $0x409360,%ecx
  4016b7:	ba 2c 01 00 00       	mov    $0x12c,%edx
  4016bc:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  4016c1:	bf 8c 8f 40 00       	mov    $0x408f8c,%edi
  4016c6:	e8 85 f5 ff ff       	callq  400c50 <__assert_fail@plt>
  4016cb:	90                   	nop

00000000004016cc <_start>:
  4016cc:	31 ed                	xor    %ebp,%ebp
  4016ce:	49 89 d1             	mov    %rdx,%r9
  4016d1:	5e                   	pop    %rsi
  4016d2:	48 89 e2             	mov    %rsp,%rdx
  4016d5:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4016d9:	50                   	push   %rax
  4016da:	54                   	push   %rsp
  4016db:	49 c7 c0 40 8a 40 00 	mov    $0x408a40,%r8
  4016e2:	48 c7 c1 50 8a 40 00 	mov    $0x408a50,%rcx
  4016e9:	48 c7 c7 e0 0d 40 00 	mov    $0x400de0,%rdi
  4016f0:	e8 9b f5 ff ff       	callq  400c90 <__libc_start_main@plt>
  4016f5:	f4                   	hlt    
  4016f6:	90                   	nop
  4016f7:	90                   	nop

00000000004016f8 <call_gmon_start>:
  4016f8:	48 83 ec 08          	sub    $0x8,%rsp
  4016fc:	48 8b 05 f5 aa 20 00 	mov    0x20aaf5(%rip),%rax        # 60c1f8 <_DYNAMIC+0x1d0>
  401703:	48 85 c0             	test   %rax,%rax
  401706:	74 02                	je     40170a <call_gmon_start+0x12>
  401708:	ff d0                	callq  *%rax
  40170a:	48 83 c4 08          	add    $0x8,%rsp
  40170e:	c3                   	retq   
  40170f:	90                   	nop

0000000000401710 <deregister_tm_clones>:
  401710:	b8 ff c2 60 00       	mov    $0x60c2ff,%eax
  401715:	55                   	push   %rbp
  401716:	48 2d f8 c2 60 00    	sub    $0x60c2f8,%rax
  40171c:	48 83 f8 0e          	cmp    $0xe,%rax
  401720:	48 89 e5             	mov    %rsp,%rbp
  401723:	77 02                	ja     401727 <deregister_tm_clones+0x17>
  401725:	5d                   	pop    %rbp
  401726:	c3                   	retq   
  401727:	b8 00 00 00 00       	mov    $0x0,%eax
  40172c:	48 85 c0             	test   %rax,%rax
  40172f:	74 f4                	je     401725 <deregister_tm_clones+0x15>
  401731:	5d                   	pop    %rbp
  401732:	bf f8 c2 60 00       	mov    $0x60c2f8,%edi
  401737:	ff e0                	jmpq   *%rax
  401739:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000401740 <register_tm_clones>:
  401740:	b8 f8 c2 60 00       	mov    $0x60c2f8,%eax
  401745:	55                   	push   %rbp
  401746:	48 2d f8 c2 60 00    	sub    $0x60c2f8,%rax
  40174c:	48 c1 f8 03          	sar    $0x3,%rax
  401750:	48 89 e5             	mov    %rsp,%rbp
  401753:	48 89 c2             	mov    %rax,%rdx
  401756:	48 c1 ea 3f          	shr    $0x3f,%rdx
  40175a:	48 01 d0             	add    %rdx,%rax
  40175d:	48 d1 f8             	sar    %rax
  401760:	75 02                	jne    401764 <register_tm_clones+0x24>
  401762:	5d                   	pop    %rbp
  401763:	c3                   	retq   
  401764:	ba 00 00 00 00       	mov    $0x0,%edx
  401769:	48 85 d2             	test   %rdx,%rdx
  40176c:	74 f4                	je     401762 <register_tm_clones+0x22>
  40176e:	5d                   	pop    %rbp
  40176f:	48 89 c6             	mov    %rax,%rsi
  401772:	bf f8 c2 60 00       	mov    $0x60c2f8,%edi
  401777:	ff e2                	jmpq   *%rdx
  401779:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000401780 <__do_global_dtors_aux>:
  401780:	80 3d b1 ab 20 00 00 	cmpb   $0x0,0x20abb1(%rip)        # 60c338 <completed.6300>
  401787:	75 5f                	jne    4017e8 <__do_global_dtors_aux+0x68>
  401789:	55                   	push   %rbp
  40178a:	48 89 e5             	mov    %rsp,%rbp
  40178d:	53                   	push   %rbx
  40178e:	bb 18 c0 60 00       	mov    $0x60c018,%ebx
  401793:	48 81 eb 10 c0 60 00 	sub    $0x60c010,%rbx
  40179a:	48 83 ec 08          	sub    $0x8,%rsp
  40179e:	48 8b 05 9b ab 20 00 	mov    0x20ab9b(%rip),%rax        # 60c340 <dtor_idx.6302>
  4017a5:	48 c1 fb 03          	sar    $0x3,%rbx
  4017a9:	48 83 eb 01          	sub    $0x1,%rbx
  4017ad:	48 39 d8             	cmp    %rbx,%rax
  4017b0:	73 24                	jae    4017d6 <__do_global_dtors_aux+0x56>
  4017b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4017b8:	48 83 c0 01          	add    $0x1,%rax
  4017bc:	48 89 05 7d ab 20 00 	mov    %rax,0x20ab7d(%rip)        # 60c340 <dtor_idx.6302>
  4017c3:	ff 14 c5 10 c0 60 00 	callq  *0x60c010(,%rax,8)
  4017ca:	48 8b 05 6f ab 20 00 	mov    0x20ab6f(%rip),%rax        # 60c340 <dtor_idx.6302>
  4017d1:	48 39 d8             	cmp    %rbx,%rax
  4017d4:	72 e2                	jb     4017b8 <__do_global_dtors_aux+0x38>
  4017d6:	e8 35 ff ff ff       	callq  401710 <deregister_tm_clones>
  4017db:	c6 05 56 ab 20 00 01 	movb   $0x1,0x20ab56(%rip)        # 60c338 <completed.6300>
  4017e2:	48 83 c4 08          	add    $0x8,%rsp
  4017e6:	5b                   	pop    %rbx
  4017e7:	5d                   	pop    %rbp
  4017e8:	c3                   	retq   
  4017e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000004017f0 <frame_dummy>:
  4017f0:	48 83 3d 28 a8 20 00 	cmpq   $0x0,0x20a828(%rip)        # 60c020 <__JCR_END__>
  4017f7:	00 
  4017f8:	74 1e                	je     401818 <frame_dummy+0x28>
  4017fa:	b8 00 00 00 00       	mov    $0x0,%eax
  4017ff:	48 85 c0             	test   %rax,%rax
  401802:	74 14                	je     401818 <frame_dummy+0x28>
  401804:	55                   	push   %rbp
  401805:	bf 20 c0 60 00       	mov    $0x60c020,%edi
  40180a:	48 89 e5             	mov    %rsp,%rbp
  40180d:	ff d0                	callq  *%rax
  40180f:	5d                   	pop    %rbp
  401810:	e9 2b ff ff ff       	jmpq   401740 <register_tm_clones>
  401815:	0f 1f 00             	nopl   (%rax)
  401818:	e9 23 ff ff ff       	jmpq   401740 <register_tm_clones>
  40181d:	0f 1f 00             	nopl   (%rax)

0000000000401820 <client_alloc>:
              manager_t* managerPtr,
              long numOperation,
              long numQueryPerTransaction,
              long queryRange,
              long percentUser)
{
  401820:	41 57                	push   %r15
  401822:	49 89 f7             	mov    %rsi,%r15
  401825:	41 56                	push   %r14
  401827:	49 89 d6             	mov    %rdx,%r14
  40182a:	41 55                	push   %r13
  40182c:	49 89 cd             	mov    %rcx,%r13
  40182f:	41 54                	push   %r12
  401831:	4d 89 c4             	mov    %r8,%r12
  401834:	55                   	push   %rbp
  401835:	53                   	push   %rbx
  401836:	48 89 fb             	mov    %rdi,%rbx
    client_t* clientPtr;

    clientPtr = (client_t*)malloc(sizeof(client_t));
  401839:	bf 38 00 00 00       	mov    $0x38,%edi
              manager_t* managerPtr,
              long numOperation,
              long numQueryPerTransaction,
              long queryRange,
              long percentUser)
{
  40183e:	48 83 ec 18          	sub    $0x18,%rsp
  401842:	4c 89 4c 24 08       	mov    %r9,0x8(%rsp)
    client_t* clientPtr;

    clientPtr = (client_t*)malloc(sizeof(client_t));
  401847:	e8 34 f4 ff ff       	callq  400c80 <malloc@plt>
    if (clientPtr == NULL) {
  40184c:	48 85 c0             	test   %rax,%rax
              long queryRange,
              long percentUser)
{
    client_t* clientPtr;

    clientPtr = (client_t*)malloc(sizeof(client_t));
  40184f:	48 89 c5             	mov    %rax,%rbp
    if (clientPtr == NULL) {
  401852:	74 4c                	je     4018a0 <client_alloc+0x80>
        return NULL;
    }

    clientPtr->randomPtr = random_alloc();
  401854:	31 c0                	xor    %eax,%eax
  401856:	e8 a5 38 00 00       	callq  405100 <random_alloc>
    if (clientPtr->randomPtr == NULL) {
  40185b:	48 85 c0             	test   %rax,%rax
    clientPtr = (client_t*)malloc(sizeof(client_t));
    if (clientPtr == NULL) {
        return NULL;
    }

    clientPtr->randomPtr = random_alloc();
  40185e:	48 89 45 10          	mov    %rax,0x10(%rbp)
    if (clientPtr->randomPtr == NULL) {
  401862:	74 3c                	je     4018a0 <client_alloc+0x80>
        return NULL;
    }

    clientPtr->id = id;
    clientPtr->managerPtr = managerPtr;
    random_seed(clientPtr->randomPtr, id);
  401864:	48 89 c7             	mov    %rax,%rdi
  401867:	48 89 de             	mov    %rbx,%rsi
    clientPtr->randomPtr = random_alloc();
    if (clientPtr->randomPtr == NULL) {
        return NULL;
    }

    clientPtr->id = id;
  40186a:	48 89 5d 00          	mov    %rbx,0x0(%rbp)
    clientPtr->managerPtr = managerPtr;
  40186e:	4c 89 7d 08          	mov    %r15,0x8(%rbp)
    random_seed(clientPtr->randomPtr, id);
  401872:	e8 29 39 00 00       	callq  4051a0 <random_seed>
    clientPtr->numOperation = numOperation;
    clientPtr->numQueryPerTransaction = numQueryPerTransaction;
    clientPtr->queryRange = queryRange;
    clientPtr->percentUser = percentUser;
  401877:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    }

    clientPtr->id = id;
    clientPtr->managerPtr = managerPtr;
    random_seed(clientPtr->randomPtr, id);
    clientPtr->numOperation = numOperation;
  40187c:	4c 89 75 18          	mov    %r14,0x18(%rbp)
    clientPtr->numQueryPerTransaction = numQueryPerTransaction;
  401880:	4c 89 6d 20          	mov    %r13,0x20(%rbp)
    clientPtr->queryRange = queryRange;
  401884:	4c 89 65 28          	mov    %r12,0x28(%rbp)
    clientPtr->percentUser = percentUser;
  401888:	48 89 45 30          	mov    %rax,0x30(%rbp)

    return clientPtr;
  40188c:	48 89 e8             	mov    %rbp,%rax
}
  40188f:	48 83 c4 18          	add    $0x18,%rsp
  401893:	5b                   	pop    %rbx
  401894:	5d                   	pop    %rbp
  401895:	41 5c                	pop    %r12
  401897:	41 5d                	pop    %r13
  401899:	41 5e                	pop    %r14
  40189b:	41 5f                	pop    %r15
  40189d:	c3                   	retq   
  40189e:	66 90                	xchg   %ax,%ax
{
    client_t* clientPtr;

    clientPtr = (client_t*)malloc(sizeof(client_t));
    if (clientPtr == NULL) {
        return NULL;
  4018a0:	31 c0                	xor    %eax,%eax
  4018a2:	eb eb                	jmp    40188f <client_alloc+0x6f>
  4018a4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4018ab:	00 00 00 00 00 

00000000004018b0 <client_free>:
 * =============================================================================
 */
void
client_free (client_t* clientPtr)
{
    free(clientPtr);
  4018b0:	e9 fb f3 ff ff       	jmpq   400cb0 <free@plt>
  4018b5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  4018bc:	00 00 00 00 

00000000004018c0 <client_run>:
 * -- Execute list operations on the database
 * =============================================================================
 */
void
client_run (void* argPtr)
{
  4018c0:	41 57                	push   %r15
    TM_THREAD_ENTER();

    long myId = thread_getId();
  4018c2:	31 c0                	xor    %eax,%eax
 * -- Execute list operations on the database
 * =============================================================================
 */
void
client_run (void* argPtr)
{
  4018c4:	41 56                	push   %r14
  4018c6:	41 55                	push   %r13
  4018c8:	41 54                	push   %r12
  4018ca:	55                   	push   %rbp
  4018cb:	53                   	push   %rbx
  4018cc:	48 89 fb             	mov    %rdi,%rbx
  4018cf:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
    TM_THREAD_ENTER();

    long myId = thread_getId();
  4018d6:	e8 15 71 00 00       	callq  4089f0 <thread_getId>
    client_t* clientPtr = ((client_t**)argPtr)[myId];
  4018db:	48 8b 04 c3          	mov    (%rbx,%rax,8),%rax

    manager_t* managerPtr = clientPtr->managerPtr;
  4018df:	48 8b 70 08          	mov    0x8(%rax),%rsi
    random_t*  randomPtr  = clientPtr->randomPtr;
  4018e3:	48 8b 58 10          	mov    0x10(%rax),%rbx

    long numOperation           = clientPtr->numOperation;
    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
    long queryRange             = clientPtr->queryRange;
  4018e7:	4c 8b 70 28          	mov    0x28(%rax),%r14
    TM_THREAD_ENTER();

    long myId = thread_getId();
    client_t* clientPtr = ((client_t**)argPtr)[myId];

    manager_t* managerPtr = clientPtr->managerPtr;
  4018eb:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
    random_t*  randomPtr  = clientPtr->randomPtr;

    long numOperation           = clientPtr->numOperation;
  4018f0:	48 8b 70 18          	mov    0x18(%rax),%rsi
  4018f4:	49 89 f5             	mov    %rsi,%r13
  4018f7:	48 89 74 24 38       	mov    %rsi,0x38(%rsp)
    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
    long queryRange             = clientPtr->queryRange;
    long percentUser            = clientPtr->percentUser;
  4018fc:	48 8b 70 30          	mov    0x30(%rax),%rsi

    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401900:	48 8b 40 20          	mov    0x20(%rax),%rax
    random_t*  randomPtr  = clientPtr->randomPtr;

    long numOperation           = clientPtr->numOperation;
    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
    long queryRange             = clientPtr->queryRange;
    long percentUser            = clientPtr->percentUser;
  401904:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)

    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401909:	4c 8d 24 c5 00 00 00 	lea    0x0(,%rax,8),%r12
  401910:	00 
  401911:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  401916:	4c 89 e7             	mov    %r12,%rdi
  401919:	e8 62 f3 ff ff       	callq  400c80 <malloc@plt>
    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  40191e:	4c 89 e7             	mov    %r12,%rdi
    long numOperation           = clientPtr->numOperation;
    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
    long queryRange             = clientPtr->queryRange;
    long percentUser            = clientPtr->percentUser;

    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401921:	49 89 c7             	mov    %rax,%r15
    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401924:	e8 57 f3 ff ff       	callq  400c80 <malloc@plt>
    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401929:	4c 89 e7             	mov    %r12,%rdi
    long numQueryPerTransaction = clientPtr->numQueryPerTransaction;
    long queryRange             = clientPtr->queryRange;
    long percentUser            = clientPtr->percentUser;

    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  40192c:	48 89 c5             	mov    %rax,%rbp
    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  40192f:	e8 4c f3 ff ff       	callq  400c80 <malloc@plt>
    long* prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401934:	4c 89 e7             	mov    %r12,%rdi
    long queryRange             = clientPtr->queryRange;
    long percentUser            = clientPtr->percentUser;

    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401937:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    long* prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  40193c:	e8 3f f3 ff ff       	callq  400c80 <malloc@plt>

    long i;

    for (i = 0; i < numOperation; i++) {
  401941:	4d 85 ed             	test   %r13,%r13
    long percentUser            = clientPtr->percentUser;

    long* types  = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* ids    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
  401944:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

    long i;

    for (i = 0; i < numOperation; i++) {
  401949:	0f 8e f7 02 00 00    	jle    401c46 <client_run+0x386>
  40194f:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
  401956:	00 00 

        long r = random_generate(randomPtr) % 100;
  401958:	48 89 df             	mov    %rbx,%rdi
  40195b:	e8 60 38 00 00       	callq  4051c0 <random_generate>
  401960:	48 89 c2             	mov    %rax,%rdx
  401963:	48 89 c1             	mov    %rax,%rcx
  401966:	48 b8 c3 f5 28 5c 8f 	movabs $0x28f5c28f5c28f5c3,%rax
  40196d:	c2 f5 28 
  401970:	48 c1 ea 02          	shr    $0x2,%rdx
  401974:	48 f7 e2             	mul    %rdx
  401977:	48 c1 ea 02          	shr    $0x2,%rdx
  40197b:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  40197f:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
  401983:	48 c1 e0 02          	shl    $0x2,%rax
  401987:	48 29 c1             	sub    %rax,%rcx
static action_t
selectAction (long r, long percentUser)
{
    action_t action;

    if (r < percentUser) {
  40198a:	48 39 4c 24 20       	cmp    %rcx,0x20(%rsp)

    long i;

    for (i = 0; i < numOperation; i++) {

        long r = random_generate(randomPtr) % 100;
  40198f:	48 89 ca             	mov    %rcx,%rdx
static action_t
selectAction (long r, long percentUser)
{
    action_t action;

    if (r < percentUser) {
  401992:	0f 8f 48 01 00 00    	jg     401ae0 <client_run+0x220>
        action = ACTION_MAKE_RESERVATION;
    } else if (r & 1) {
  401998:	83 e2 01             	and    $0x1,%edx
  40199b:	0f 85 5f 02 00 00    	jne    401c00 <client_run+0x340>
                TM_END();
                break;
            }

            case ACTION_UPDATE_TABLES: {
                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
  4019a1:	48 89 df             	mov    %rbx,%rdi
  4019a4:	e8 17 38 00 00       	callq  4051c0 <random_generate>
  4019a9:	31 d2                	xor    %edx,%edx
  4019ab:	48 f7 74 24 28       	divq   0x28(%rsp)
  4019b0:	4c 8d 6a 01          	lea    0x1(%rdx),%r13
                long n;
                for (n = 0; n < numUpdate; n++) {
  4019b4:	4d 85 ed             	test   %r13,%r13
  4019b7:	0f 8e 73 02 00 00    	jle    401c30 <client_run+0x370>
  4019bd:	45 31 e4             	xor    %r12d,%r12d
  4019c0:	eb 13                	jmp    4019d5 <client_run+0x115>
  4019c2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4019c8:	49 83 c4 01          	add    $0x1,%r12
  4019cc:	4d 39 ec             	cmp    %r13,%r12
  4019cf:	0f 84 97 00 00 00    	je     401a6c <client_run+0x1ac>
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
  4019d5:	48 89 df             	mov    %rbx,%rdi
  4019d8:	e8 e3 37 00 00       	callq  4051c0 <random_generate>
  4019dd:	48 89 c1             	mov    %rax,%rcx
  4019e0:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
  4019e7:	aa aa aa 
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
  4019ea:	48 89 df             	mov    %rbx,%rdi

            case ACTION_UPDATE_TABLES: {
                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long n;
                for (n = 0; n < numUpdate; n++) {
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
  4019ed:	48 f7 e1             	mul    %rcx
  4019f0:	48 d1 ea             	shr    %rdx
  4019f3:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax
  4019f7:	48 29 c1             	sub    %rax,%rcx
  4019fa:	4b 89 0c e7          	mov    %rcx,(%r15,%r12,8)
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
  4019fe:	e8 bd 37 00 00       	callq  4051c0 <random_generate>
  401a03:	31 d2                	xor    %edx,%edx
                    ops[n] = random_generate(randomPtr) % 2;
  401a05:	48 89 df             	mov    %rbx,%rdi
            case ACTION_UPDATE_TABLES: {
                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long n;
                for (n = 0; n < numUpdate; n++) {
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
  401a08:	49 f7 f6             	div    %r14
  401a0b:	48 83 c2 01          	add    $0x1,%rdx
  401a0f:	4a 89 54 e5 00       	mov    %rdx,0x0(%rbp,%r12,8)
                    ops[n] = random_generate(randomPtr) % 2;
  401a14:	e8 a7 37 00 00       	callq  4051c0 <random_generate>
  401a19:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
  401a1e:	83 e0 01             	and    $0x1,%eax
                    if (ops[n]) {
  401a21:	48 85 c0             	test   %rax,%rax
                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long n;
                for (n = 0; n < numUpdate; n++) {
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
                    ops[n] = random_generate(randomPtr) % 2;
  401a24:	4a 89 04 e6          	mov    %rax,(%rsi,%r12,8)
                    if (ops[n]) {
  401a28:	74 9e                	je     4019c8 <client_run+0x108>
                        prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
  401a2a:	48 89 df             	mov    %rbx,%rdi
  401a2d:	e8 8e 37 00 00       	callq  4051c0 <random_generate>
  401a32:	48 89 c1             	mov    %rax,%rcx
  401a35:	48 b8 cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rax
  401a3c:	cc cc cc 
  401a3f:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  401a44:	48 f7 e1             	mul    %rcx
  401a47:	48 c1 ea 02          	shr    $0x2,%rdx
  401a4b:	48 8d 04 92          	lea    (%rdx,%rdx,4),%rax
  401a4f:	48 29 c1             	sub    %rax,%rcx
  401a52:	48 8d 04 89          	lea    (%rcx,%rcx,4),%rax
  401a56:	48 8d 44 00 32       	lea    0x32(%rax,%rax,1),%rax
  401a5b:	4a 89 04 e6          	mov    %rax,(%rsi,%r12,8)
            }

            case ACTION_UPDATE_TABLES: {
                long numUpdate = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long n;
                for (n = 0; n < numUpdate; n++) {
  401a5f:	49 83 c4 01          	add    $0x1,%r12
  401a63:	4d 39 ec             	cmp    %r13,%r12
  401a66:	0f 85 69 ff ff ff    	jne    4019d5 <client_run+0x115>
  401a6c:	45 31 e4             	xor    %r12d,%r12d
  401a6f:	48 89 5c 24 40       	mov    %rbx,0x40(%rsp)
  401a74:	4c 89 74 24 48       	mov    %r14,0x48(%rsp)
  401a79:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
  401a7e:	4d 89 e6             	mov    %r12,%r14
  401a81:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
                TM_BEGIN();
                for (n = 0; n < numUpdate; n++) {
                    long t = types[n];
                    long id = ids[n];
                    long doAdd = ops[n];
                    if (doAdd) {
  401a86:	4b 83 3c f4 00       	cmpq   $0x0,(%r12,%r14,8)
                        prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
                    }
                }
                TM_BEGIN();
                for (n = 0; n < numUpdate; n++) {
                    long t = types[n];
  401a8b:	4b 8b 04 f7          	mov    (%r15,%r14,8),%rax
                    long id = ids[n];
  401a8f:	4a 8b 74 f5 00       	mov    0x0(%rbp,%r14,8),%rsi
                    long doAdd = ops[n];
                    if (doAdd) {
  401a94:	0f 84 c6 01 00 00    	je     401c60 <client_run+0x3a0>
                        long newPrice = prices[n];
  401a9a:	48 8b 7c 24 18       	mov    0x18(%rsp),%rdi
                        switch (t) {
  401a9f:	48 83 f8 01          	cmp    $0x1,%rax
                for (n = 0; n < numUpdate; n++) {
                    long t = types[n];
                    long id = ids[n];
                    long doAdd = ops[n];
                    if (doAdd) {
                        long newPrice = prices[n];
  401aa3:	4a 8b 0c f7          	mov    (%rdi,%r14,8),%rcx
                        switch (t) {
  401aa7:	0f 84 83 03 00 00    	je     401e30 <client_run+0x570>
  401aad:	48 83 f8 02          	cmp    $0x2,%rax
  401ab1:	0f 84 99 03 00 00    	je     401e50 <client_run+0x590>
  401ab7:	48 85 c0             	test   %rax,%rax
  401aba:	0f 84 80 03 00 00    	je     401e40 <client_run+0x580>
                                break;
                            case RESERVATION_ROOM:
                                MANAGER_ADD_ROOM(managerPtr, id, 100, newPrice);
                                break;
                            default:
                                assert(0);
  401ac0:	b9 3d 8b 40 00       	mov    $0x408b3d,%ecx
  401ac5:	ba 1d 01 00 00       	mov    $0x11d,%edx
  401aca:	be 34 8b 40 00       	mov    $0x408b34,%esi
  401acf:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  401ad4:	e8 77 f1 ff ff       	callq  400c50 <__assert_fail@plt>
  401ad9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

            case ACTION_MAKE_RESERVATION: {
                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
  401ae0:	48 89 df             	mov    %rbx,%rdi
        action_t action = selectAction(r, percentUser);

        switch (action) {

            case ACTION_MAKE_RESERVATION: {
                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
  401ae3:	48 c7 44 24 60 ff ff 	movq   $0xffffffffffffffff,0x60(%rsp)
  401aea:	ff ff 
  401aec:	48 c7 44 24 68 ff ff 	movq   $0xffffffffffffffff,0x68(%rsp)
  401af3:	ff ff 
  401af5:	48 c7 44 24 70 ff ff 	movq   $0xffffffffffffffff,0x70(%rsp)
  401afc:	ff ff 
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
  401afe:	48 c7 84 24 80 00 00 	movq   $0xffffffffffffffff,0x80(%rsp)
  401b05:	00 ff ff ff ff 
  401b0a:	48 c7 84 24 88 00 00 	movq   $0xffffffffffffffff,0x88(%rsp)
  401b11:	00 ff ff ff ff 
  401b16:	48 c7 84 24 90 00 00 	movq   $0xffffffffffffffff,0x90(%rsp)
  401b1d:	00 ff ff ff ff 
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
  401b22:	e8 99 36 00 00       	callq  4051c0 <random_generate>
  401b27:	31 d2                	xor    %edx,%edx
                long customerId = random_generate(randomPtr) % queryRange + 1;
  401b29:	48 89 df             	mov    %rbx,%rdi

            case ACTION_MAKE_RESERVATION: {
                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
  401b2c:	48 f7 74 24 28       	divq   0x28(%rsp)
  401b31:	49 89 d4             	mov    %rdx,%r12
                long customerId = random_generate(randomPtr) % queryRange + 1;
  401b34:	e8 87 36 00 00       	callq  4051c0 <random_generate>
  401b39:	31 d2                	xor    %edx,%edx

            case ACTION_MAKE_RESERVATION: {
                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
  401b3b:	49 83 c4 01          	add    $0x1,%r12
                long customerId = random_generate(randomPtr) % queryRange + 1;
  401b3f:	49 f7 f6             	div    %r14
                for (n = 0; n < numQuery; n++) {
  401b42:	4d 85 e4             	test   %r12,%r12
            case ACTION_MAKE_RESERVATION: {
                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long customerId = random_generate(randomPtr) % queryRange + 1;
  401b45:	48 8d 42 01          	lea    0x1(%rdx),%rax
  401b49:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
                for (n = 0; n < numQuery; n++) {
  401b4e:	0f 8e dc 00 00 00    	jle    401c30 <client_run+0x370>
  401b54:	45 31 ed             	xor    %r13d,%r13d
  401b57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  401b5e:	00 00 
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
  401b60:	48 89 df             	mov    %rbx,%rdi
  401b63:	e8 58 36 00 00       	callq  4051c0 <random_generate>
  401b68:	48 89 c1             	mov    %rax,%rcx
  401b6b:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
  401b72:	aa aa aa 
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
  401b75:	48 89 df             	mov    %rbx,%rdi
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long customerId = random_generate(randomPtr) % queryRange + 1;
                for (n = 0; n < numQuery; n++) {
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
  401b78:	48 f7 e1             	mul    %rcx
  401b7b:	48 d1 ea             	shr    %rdx
  401b7e:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax
  401b82:	48 29 c1             	sub    %rax,%rcx
  401b85:	4b 89 0c ef          	mov    %rcx,(%r15,%r13,8)
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
  401b89:	e8 32 36 00 00       	callq  4051c0 <random_generate>
  401b8e:	31 d2                	xor    %edx,%edx
  401b90:	49 f7 f6             	div    %r14
  401b93:	48 83 c2 01          	add    $0x1,%rdx
  401b97:	4a 89 54 ed 00       	mov    %rdx,0x0(%rbp,%r13,8)
                long maxPrices[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long maxIds[NUM_RESERVATION_TYPE] = { -1, -1, -1 };
                long n;
                long numQuery = random_generate(randomPtr) % numQueryPerTransaction + 1;
                long customerId = random_generate(randomPtr) % queryRange + 1;
                for (n = 0; n < numQuery; n++) {
  401b9c:	49 83 c5 01          	add    $0x1,%r13
  401ba0:	4d 39 e5             	cmp    %r12,%r13
  401ba3:	75 bb                	jne    401b60 <client_run+0x2a0>
  401ba5:	45 31 ed             	xor    %r13d,%r13d
  401ba8:	4c 89 74 24 58       	mov    %r14,0x58(%rsp)
  401bad:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
  401bb4:	00 00 
  401bb6:	4d 89 ee             	mov    %r13,%r14
  401bb9:	48 89 5c 24 50       	mov    %rbx,0x50(%rsp)
  401bbe:	4d 89 e5             	mov    %r12,%r13
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
                }
                bool_t isFound = FALSE;
                TM_BEGIN();
                for (n = 0; n < numQuery; n++) {
                    long t = types[n];
  401bc1:	4b 8b 1c f7          	mov    (%r15,%r14,8),%rbx
                    long id = ids[n];
  401bc5:	4e 8b 64 f5 00       	mov    0x0(%rbp,%r14,8),%r12
                    long price = -1;
                    switch (t) {
  401bca:	48 83 fb 01          	cmp    $0x1,%rbx
  401bce:	0f 84 f4 00 00 00    	je     401cc8 <client_run+0x408>
  401bd4:	48 83 fb 02          	cmp    $0x2,%rbx
  401bd8:	0f 84 ba 01 00 00    	je     401d98 <client_run+0x4d8>
  401bde:	48 85 db             	test   %rbx,%rbx
  401be1:	0f 84 b9 00 00 00    	je     401ca0 <client_run+0x3e0>
                            if (MANAGER_QUERY_ROOM(managerPtr, id) >= 0) {
                                price = MANAGER_QUERY_ROOM_PRICE(managerPtr, id);
                            }
                            break;
                        default:
                            assert(0);
  401be7:	b9 3d 8b 40 00       	mov    $0x408b3d,%ecx
  401bec:	ba da 00 00 00       	mov    $0xda,%edx
  401bf1:	be 34 8b 40 00       	mov    $0x408b34,%esi
  401bf6:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  401bfb:	e8 50 f0 ff ff       	callq  400c50 <__assert_fail@plt>
                TM_END();
                break;
            }

            case ACTION_DELETE_CUSTOMER: {
                long customerId = random_generate(randomPtr) % queryRange + 1;
  401c00:	48 89 df             	mov    %rbx,%rdi
  401c03:	e8 b8 35 00 00       	callq  4051c0 <random_generate>
  401c08:	31 d2                	xor    %edx,%edx
                TM_BEGIN();
                long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, customerId);
  401c0a:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
                TM_END();
                break;
            }

            case ACTION_DELETE_CUSTOMER: {
                long customerId = random_generate(randomPtr) % queryRange + 1;
  401c0f:	49 f7 f6             	div    %r14
  401c12:	4c 8d 62 01          	lea    0x1(%rdx),%r12
                TM_BEGIN();
                long bill = MANAGER_QUERY_CUSTOMER_BILL(managerPtr, customerId);
  401c16:	4c 89 e6             	mov    %r12,%rsi
  401c19:	e8 a2 13 00 00       	callq  402fc0 <manager_queryCustomerBill>
                if (bill >= 0) {
  401c1e:	48 85 c0             	test   %rax,%rax
  401c21:	78 0d                	js     401c30 <client_run+0x370>
                    MANAGER_DELETE_CUSTOMER(managerPtr, customerId);
  401c23:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401c28:	4c 89 e6             	mov    %r12,%rsi
  401c2b:	e8 30 11 00 00       	callq  402d60 <manager_deleteCustomer>
    long* ops    = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));
    long* prices = (long*)P_MALLOC(numQueryPerTransaction * sizeof(long));

    long i;

    for (i = 0; i < numOperation; i++) {
  401c30:	48 83 44 24 30 01    	addq   $0x1,0x30(%rsp)
  401c36:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
  401c3b:	48 39 44 24 30       	cmp    %rax,0x30(%rsp)
  401c40:	0f 85 12 fd ff ff    	jne    401958 <client_run+0x98>
        } /* switch (action) */

    } /* for i */

    TM_THREAD_EXIT();
}
  401c46:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  401c4d:	5b                   	pop    %rbx
  401c4e:	5d                   	pop    %rbp
  401c4f:	41 5c                	pop    %r12
  401c51:	41 5d                	pop    %r13
  401c53:	41 5e                	pop    %r14
  401c55:	41 5f                	pop    %r15
  401c57:	c3                   	retq   
  401c58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  401c5f:	00 
                                break;
                            default:
                                assert(0);
                        }
                    } else { /* do delete */
                        switch (t) {
  401c60:	48 83 f8 01          	cmp    $0x1,%rax
  401c64:	0f 84 9e 01 00 00    	je     401e08 <client_run+0x548>
  401c6a:	48 83 f8 02          	cmp    $0x2,%rax
  401c6e:	0f 84 64 01 00 00    	je     401dd8 <client_run+0x518>
  401c74:	48 85 c0             	test   %rax,%rax
  401c77:	0f 84 9b 01 00 00    	je     401e18 <client_run+0x558>
                                break;
                            case RESERVATION_ROOM:
                                MANAGER_DELETE_ROOM(managerPtr, id, 100);
                                break;
                            default:
                                assert(0);
  401c7d:	b9 3d 8b 40 00       	mov    $0x408b3d,%ecx
  401c82:	ba 2b 01 00 00       	mov    $0x12b,%edx
  401c87:	be 34 8b 40 00       	mov    $0x408b34,%esi
  401c8c:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  401c91:	e8 ba ef ff ff       	callq  400c50 <__assert_fail@plt>
  401c96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  401c9d:	00 00 00 
                    long t = types[n];
                    long id = ids[n];
                    long price = -1;
                    switch (t) {
                        case RESERVATION_CAR:
                            if (MANAGER_QUERY_CAR(managerPtr, id) >= 0) {
  401ca0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401ca5:	4c 89 e6             	mov    %r12,%rsi
  401ca8:	e8 f3 11 00 00       	callq  402ea0 <manager_queryCar>
  401cad:	48 85 c0             	test   %rax,%rax
  401cb0:	78 2c                	js     401cde <client_run+0x41e>
                                price = MANAGER_QUERY_CAR_PRICE(managerPtr, id);
  401cb2:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401cb7:	4c 89 e6             	mov    %r12,%rsi
  401cba:	e8 11 12 00 00       	callq  402ed0 <manager_queryCarPrice>
  401cbf:	eb 24                	jmp    401ce5 <client_run+0x425>
  401cc1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                            }
                            break;
                        case RESERVATION_FLIGHT:
                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
  401cc8:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401ccd:	4c 89 e6             	mov    %r12,%rsi
  401cd0:	e8 8b 12 00 00       	callq  402f60 <manager_queryFlight>
  401cd5:	48 85 c0             	test   %rax,%rax
  401cd8:	0f 89 e2 00 00 00    	jns    401dc0 <client_run+0x500>
                bool_t isFound = FALSE;
                TM_BEGIN();
                for (n = 0; n < numQuery; n++) {
                    long t = types[n];
                    long id = ids[n];
                    long price = -1;
  401cde:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
                            }
                            break;
                        default:
                            assert(0);
                    }
                    if (price > maxPrices[t]) {
  401ce5:	48 3b 44 dc 60       	cmp    0x60(%rsp,%rbx,8),%rax
  401cea:	7e 16                	jle    401d02 <client_run+0x442>
                        maxPrices[t] = price;
  401cec:	48 89 44 dc 60       	mov    %rax,0x60(%rsp,%rbx,8)
                        maxIds[t] = id;
  401cf1:	4c 89 a4 dc 80 00 00 	mov    %r12,0x80(%rsp,%rbx,8)
  401cf8:	00 
                        isFound = TRUE;
  401cf9:	48 c7 44 24 48 01 00 	movq   $0x1,0x48(%rsp)
  401d00:	00 00 
                    types[n] = random_generate(randomPtr) % NUM_RESERVATION_TYPE;
                    ids[n] = (random_generate(randomPtr) % queryRange) + 1;
                }
                bool_t isFound = FALSE;
                TM_BEGIN();
                for (n = 0; n < numQuery; n++) {
  401d02:	49 83 c6 01          	add    $0x1,%r14
  401d06:	4d 39 f5             	cmp    %r14,%r13
  401d09:	0f 85 b2 fe ff ff    	jne    401bc1 <client_run+0x301>
                        maxPrices[t] = price;
                        maxIds[t] = id;
                        isFound = TRUE;
                    }
                } /* for n */
                if (isFound) {
  401d0f:	48 83 7c 24 48 00    	cmpq   $0x0,0x48(%rsp)
  401d15:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
  401d1a:	4c 8b 74 24 58       	mov    0x58(%rsp),%r14
  401d1f:	74 0f                	je     401d30 <client_run+0x470>
                    MANAGER_ADD_CUSTOMER(managerPtr, customerId);
  401d21:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  401d26:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d2b:	e8 f0 0e 00 00       	callq  402c20 <manager_addCustomer>
  401d30:	48 8b 94 24 80 00 00 	mov    0x80(%rsp),%rdx
  401d37:	00 
  401d38:	4c 8b ac 24 88 00 00 	mov    0x88(%rsp),%r13
  401d3f:	00 
  401d40:	4c 8b a4 24 90 00 00 	mov    0x90(%rsp),%r12
  401d47:	00 
                }
                if (maxIds[RESERVATION_CAR] > 0) {
  401d48:	48 85 d2             	test   %rdx,%rdx
  401d4b:	7e 0f                	jle    401d5c <client_run+0x49c>
                    MANAGER_RESERVE_CAR(managerPtr,
  401d4d:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  401d52:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d57:	e8 94 12 00 00       	callq  402ff0 <manager_reserveCar>
                                        customerId, maxIds[RESERVATION_CAR]);
                }
                if (maxIds[RESERVATION_FLIGHT] > 0) {
  401d5c:	4d 85 ed             	test   %r13,%r13
  401d5f:	7e 12                	jle    401d73 <client_run+0x4b3>
                    MANAGER_RESERVE_FLIGHT(managerPtr,
  401d61:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  401d66:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d6b:	4c 89 ea             	mov    %r13,%rdx
  401d6e:	e8 7d 13 00 00       	callq  4030f0 <manager_reserveFlight>
                                           customerId, maxIds[RESERVATION_FLIGHT]);
                }
                if (maxIds[RESERVATION_ROOM] > 0) {
  401d73:	4d 85 e4             	test   %r12,%r12
  401d76:	0f 8e b4 fe ff ff    	jle    401c30 <client_run+0x370>
                    MANAGER_RESERVE_ROOM(managerPtr,
  401d7c:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  401d81:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d86:	4c 89 e2             	mov    %r12,%rdx
  401d89:	e8 e2 12 00 00       	callq  403070 <manager_reserveRoom>
  401d8e:	e9 9d fe ff ff       	jmpq   401c30 <client_run+0x370>
  401d93:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
                                price = MANAGER_QUERY_FLIGHT_PRICE(managerPtr, id);
                            }
                            break;
                        case RESERVATION_ROOM:
                            if (MANAGER_QUERY_ROOM(managerPtr, id) >= 0) {
  401d98:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401d9d:	4c 89 e6             	mov    %r12,%rsi
  401da0:	e8 5b 11 00 00       	callq  402f00 <manager_queryRoom>
  401da5:	48 85 c0             	test   %rax,%rax
  401da8:	0f 88 30 ff ff ff    	js     401cde <client_run+0x41e>
                                price = MANAGER_QUERY_ROOM_PRICE(managerPtr, id);
  401dae:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401db3:	4c 89 e6             	mov    %r12,%rsi
  401db6:	e8 75 11 00 00       	callq  402f30 <manager_queryRoomPrice>
  401dbb:	e9 25 ff ff ff       	jmpq   401ce5 <client_run+0x425>
                                price = MANAGER_QUERY_CAR_PRICE(managerPtr, id);
                            }
                            break;
                        case RESERVATION_FLIGHT:
                            if (MANAGER_QUERY_FLIGHT(managerPtr, id) >= 0) {
                                price = MANAGER_QUERY_FLIGHT_PRICE(managerPtr, id);
  401dc0:	48 8b 7c 24 10       	mov    0x10(%rsp),%rdi
  401dc5:	4c 89 e6             	mov    %r12,%rsi
  401dc8:	e8 c3 11 00 00       	callq  402f90 <manager_queryFlightPrice>
  401dcd:	e9 13 ff ff ff       	jmpq   401ce5 <client_run+0x425>
  401dd2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                                break;
                            case RESERVATION_FLIGHT:
                                MANAGER_DELETE_FLIGHT(managerPtr, id);
                                break;
                            case RESERVATION_ROOM:
                                MANAGER_DELETE_ROOM(managerPtr, id, 100);
  401dd8:	ba 64 00 00 00       	mov    $0x64,%edx
  401ddd:	48 89 df             	mov    %rbx,%rdi
  401de0:	e8 fb 0a 00 00       	callq  4028e0 <manager_deleteRoom>
  401de5:	0f 1f 00             	nopl   (%rax)
                    if (ops[n]) {
                        prices[n] = ((random_generate(randomPtr) % 5) * 10) + 50;
                    }
                }
                TM_BEGIN();
                for (n = 0; n < numUpdate; n++) {
  401de8:	49 83 c6 01          	add    $0x1,%r14
  401dec:	4d 39 f5             	cmp    %r14,%r13
  401def:	0f 85 91 fc ff ff    	jne    401a86 <client_run+0x1c6>
  401df5:	48 8b 5c 24 40       	mov    0x40(%rsp),%rbx
  401dfa:	4c 8b 74 24 48       	mov    0x48(%rsp),%r14
  401dff:	e9 2c fe ff ff       	jmpq   401c30 <client_run+0x370>
  401e04:	0f 1f 40 00          	nopl   0x0(%rax)
                        switch (t) {
                            case RESERVATION_CAR:
                                MANAGER_DELETE_CAR(managerPtr, id, 100);
                                break;
                            case RESERVATION_FLIGHT:
                                MANAGER_DELETE_FLIGHT(managerPtr, id);
  401e08:	48 89 df             	mov    %rbx,%rdi
  401e0b:	e8 c0 0d 00 00       	callq  402bd0 <manager_deleteFlight>
                                break;
  401e10:	eb d6                	jmp    401de8 <client_run+0x528>
  401e12:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                                assert(0);
                        }
                    } else { /* do delete */
                        switch (t) {
                            case RESERVATION_CAR:
                                MANAGER_DELETE_CAR(managerPtr, id, 100);
  401e18:	ba 64 00 00 00       	mov    $0x64,%edx
  401e1d:	48 89 df             	mov    %rbx,%rdi
  401e20:	e8 db 07 00 00       	callq  402600 <manager_deleteCar>
                                break;
  401e25:	eb c1                	jmp    401de8 <client_run+0x528>
  401e27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  401e2e:	00 00 
                        switch (t) {
                            case RESERVATION_CAR:
                                MANAGER_ADD_CAR(managerPtr, id, 100, newPrice);
                                break;
                            case RESERVATION_FLIGHT:
                                MANAGER_ADD_FLIGHT(managerPtr, id, 100, newPrice);
  401e30:	ba 64 00 00 00       	mov    $0x64,%edx
  401e35:	48 89 df             	mov    %rbx,%rdi
  401e38:	e8 63 0b 00 00       	callq  4029a0 <manager_addFlight>
                                break;
  401e3d:	eb a9                	jmp    401de8 <client_run+0x528>
  401e3f:	90                   	nop
                    long doAdd = ops[n];
                    if (doAdd) {
                        long newPrice = prices[n];
                        switch (t) {
                            case RESERVATION_CAR:
                                MANAGER_ADD_CAR(managerPtr, id, 100, newPrice);
  401e40:	ba 64 00 00 00       	mov    $0x64,%edx
  401e45:	48 89 df             	mov    %rbx,%rdi
  401e48:	e8 83 05 00 00       	callq  4023d0 <manager_addCar>
                                break;
  401e4d:	eb 99                	jmp    401de8 <client_run+0x528>
  401e4f:	90                   	nop
                            case RESERVATION_FLIGHT:
                                MANAGER_ADD_FLIGHT(managerPtr, id, 100, newPrice);
                                break;
                            case RESERVATION_ROOM:
                                MANAGER_ADD_ROOM(managerPtr, id, 100, newPrice);
  401e50:	ba 64 00 00 00       	mov    $0x64,%edx
  401e55:	48 89 df             	mov    %rbx,%rdi
  401e58:	e8 53 08 00 00       	callq  4026b0 <manager_addRoom>
                                break;
  401e5d:	eb 89                	jmp    401de8 <client_run+0x528>
  401e5f:	90                   	nop

0000000000401e60 <compareReservationInfo>:
 * =============================================================================
 */
static long
compareReservationInfo (const void* aPtr, const void* bPtr)
{
    return reservation_info_compare((reservation_info_t*)aPtr,
  401e60:	e9 cb 14 00 00       	jmpq   403330 <reservation_info_compare>
  401e65:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  401e6c:	00 00 00 00 

0000000000401e70 <customer_alloc>:
 * customer_alloc
 * =============================================================================
 */
customer_t*
customer_alloc (TM_ARGDECL  long id)
{
  401e70:	55                   	push   %rbp
  401e71:	48 89 fd             	mov    %rdi,%rbp
    customer_t* customerPtr;

    customerPtr = (customer_t*)TM_MALLOC(sizeof(customer_t));
  401e74:	bf 10 00 00 00       	mov    $0x10,%edi
 * customer_alloc
 * =============================================================================
 */
customer_t*
customer_alloc (TM_ARGDECL  long id)
{
  401e79:	53                   	push   %rbx
  401e7a:	48 83 ec 08          	sub    $0x8,%rsp
    customer_t* customerPtr;

    customerPtr = (customer_t*)TM_MALLOC(sizeof(customer_t));
  401e7e:	e8 fd ed ff ff       	callq  400c80 <malloc@plt>
    assert(customerPtr != NULL);
  401e83:	48 85 c0             	test   %rax,%rax
customer_t*
customer_alloc (TM_ARGDECL  long id)
{
    customer_t* customerPtr;

    customerPtr = (customer_t*)TM_MALLOC(sizeof(customer_t));
  401e86:	48 89 c3             	mov    %rax,%rbx
    assert(customerPtr != NULL);
  401e89:	74 20                	je     401eab <customer_alloc+0x3b>

    customerPtr->id = id;
  401e8b:	48 89 28             	mov    %rbp,(%rax)

    customerPtr->reservationInfoListPtr = TMLIST_ALLOC(&compareReservationInfo);
  401e8e:	bf 60 1e 40 00       	mov    $0x401e60,%edi
  401e93:	e8 78 21 00 00       	callq  404010 <TMlist_alloc>
    assert(customerPtr->reservationInfoListPtr != NULL);
  401e98:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TM_MALLOC(sizeof(customer_t));
    assert(customerPtr != NULL);

    customerPtr->id = id;

    customerPtr->reservationInfoListPtr = TMLIST_ALLOC(&compareReservationInfo);
  401e9b:	48 89 43 08          	mov    %rax,0x8(%rbx)
    assert(customerPtr->reservationInfoListPtr != NULL);
  401e9f:	74 23                	je     401ec4 <customer_alloc+0x54>

    return customerPtr;
}
  401ea1:	48 83 c4 08          	add    $0x8,%rsp
  401ea5:	48 89 d8             	mov    %rbx,%rax
  401ea8:	5b                   	pop    %rbx
  401ea9:	5d                   	pop    %rbp
  401eaa:	c3                   	retq   
customer_alloc (TM_ARGDECL  long id)
{
    customer_t* customerPtr;

    customerPtr = (customer_t*)TM_MALLOC(sizeof(customer_t));
    assert(customerPtr != NULL);
  401eab:	b9 23 8c 40 00       	mov    $0x408c23,%ecx
  401eb0:	ba 69 00 00 00       	mov    $0x69,%edx
  401eb5:	be 48 8b 40 00       	mov    $0x408b48,%esi
  401eba:	bf 53 8b 40 00       	mov    $0x408b53,%edi
  401ebf:	e8 8c ed ff ff       	callq  400c50 <__assert_fail@plt>

    customerPtr->id = id;

    customerPtr->reservationInfoListPtr = TMLIST_ALLOC(&compareReservationInfo);
    assert(customerPtr->reservationInfoListPtr != NULL);
  401ec4:	b9 23 8c 40 00       	mov    $0x408c23,%ecx
  401ec9:	ba 6e 00 00 00       	mov    $0x6e,%edx
  401ece:	be 48 8b 40 00       	mov    $0x408b48,%esi
  401ed3:	bf 70 8b 40 00       	mov    $0x408b70,%edi
  401ed8:	e8 73 ed ff ff       	callq  400c50 <__assert_fail@plt>
  401edd:	0f 1f 00             	nopl   (%rax)

0000000000401ee0 <customer_alloc_seq>:
}


customer_t*
customer_alloc_seq (long id)
{
  401ee0:	55                   	push   %rbp
  401ee1:	48 89 fd             	mov    %rdi,%rbp
    customer_t* customerPtr;

    customerPtr = (customer_t*)malloc(sizeof(customer_t));
  401ee4:	bf 10 00 00 00       	mov    $0x10,%edi
}


customer_t*
customer_alloc_seq (long id)
{
  401ee9:	53                   	push   %rbx
  401eea:	48 83 ec 08          	sub    $0x8,%rsp
    customer_t* customerPtr;

    customerPtr = (customer_t*)malloc(sizeof(customer_t));
  401eee:	e8 8d ed ff ff       	callq  400c80 <malloc@plt>
    assert(customerPtr != NULL);
  401ef3:	48 85 c0             	test   %rax,%rax
customer_t*
customer_alloc_seq (long id)
{
    customer_t* customerPtr;

    customerPtr = (customer_t*)malloc(sizeof(customer_t));
  401ef6:	48 89 c3             	mov    %rax,%rbx
    assert(customerPtr != NULL);
  401ef9:	74 20                	je     401f1b <customer_alloc_seq+0x3b>

    customerPtr->id = id;
  401efb:	48 89 28             	mov    %rbp,(%rax)

    customerPtr->reservationInfoListPtr = list_alloc(&compareReservationInfo);
  401efe:	bf 60 1e 40 00       	mov    $0x401e60,%edi
  401f03:	e8 68 20 00 00       	callq  403f70 <list_alloc>
    assert(customerPtr->reservationInfoListPtr != NULL);
  401f08:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)malloc(sizeof(customer_t));
    assert(customerPtr != NULL);

    customerPtr->id = id;

    customerPtr->reservationInfoListPtr = list_alloc(&compareReservationInfo);
  401f0b:	48 89 43 08          	mov    %rax,0x8(%rbx)
    assert(customerPtr->reservationInfoListPtr != NULL);
  401f0f:	74 23                	je     401f34 <customer_alloc_seq+0x54>

    return customerPtr;
}
  401f11:	48 83 c4 08          	add    $0x8,%rsp
  401f15:	48 89 d8             	mov    %rbx,%rax
  401f18:	5b                   	pop    %rbx
  401f19:	5d                   	pop    %rbp
  401f1a:	c3                   	retq   
customer_alloc_seq (long id)
{
    customer_t* customerPtr;

    customerPtr = (customer_t*)malloc(sizeof(customer_t));
    assert(customerPtr != NULL);
  401f1b:	b9 10 8c 40 00       	mov    $0x408c10,%ecx
  401f20:	ba 7a 00 00 00       	mov    $0x7a,%edx
  401f25:	be 48 8b 40 00       	mov    $0x408b48,%esi
  401f2a:	bf 53 8b 40 00       	mov    $0x408b53,%edi
  401f2f:	e8 1c ed ff ff       	callq  400c50 <__assert_fail@plt>

    customerPtr->id = id;

    customerPtr->reservationInfoListPtr = list_alloc(&compareReservationInfo);
    assert(customerPtr->reservationInfoListPtr != NULL);
  401f34:	b9 10 8c 40 00       	mov    $0x408c10,%ecx
  401f39:	ba 7f 00 00 00       	mov    $0x7f,%edx
  401f3e:	be 48 8b 40 00       	mov    $0x408b48,%esi
  401f43:	bf 70 8b 40 00       	mov    $0x408b70,%edi
  401f48:	e8 03 ed ff ff       	callq  400c50 <__assert_fail@plt>
  401f4d:	0f 1f 00             	nopl   (%rax)

0000000000401f50 <customer_compare>:
 * =============================================================================
 */
long
customer_compare (customer_t* aPtr, customer_t* bPtr)
{
    return (aPtr->id - bPtr->id);
  401f50:	48 8b 07             	mov    (%rdi),%rax
  401f53:	48 2b 06             	sub    (%rsi),%rax
}
  401f56:	c3                   	retq   
  401f57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  401f5e:	00 00 

0000000000401f60 <customer_free>:
 * customer_free
 * =============================================================================
 */
void
customer_free (TM_ARGDECL  customer_t* customerPtr)
{
  401f60:	53                   	push   %rbx
  401f61:	48 89 fb             	mov    %rdi,%rbx
    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);
    TMLIST_FREE(reservationInfoListPtr);
  401f64:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  401f68:	e8 93 23 00 00       	callq  404300 <TMlist_free>
    TM_FREE(customerPtr);
  401f6d:	48 89 df             	mov    %rbx,%rdi
}
  401f70:	5b                   	pop    %rbx
customer_free (TM_ARGDECL  customer_t* customerPtr)
{
    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);
    TMLIST_FREE(reservationInfoListPtr);
    TM_FREE(customerPtr);
  401f71:	e9 3a ed ff ff       	jmpq   400cb0 <free@plt>
  401f76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  401f7d:	00 00 00 

0000000000401f80 <customer_addReservationInfo>:
 */
bool_t
customer_addReservationInfo (TM_ARGDECL
                             customer_t* customerPtr,
                             reservation_type_t type, long id, long price)
{
  401f80:	53                   	push   %rbx
  401f81:	48 89 fb             	mov    %rdi,%rbx
  401f84:	89 f7                	mov    %esi,%edi
  401f86:	48 89 d6             	mov    %rdx,%rsi
  401f89:	48 89 ca             	mov    %rcx,%rdx
    reservation_info_t* reservationInfoPtr;

    reservationInfoPtr = RESERVATION_INFO_ALLOC(type, id, price);
  401f8c:	e8 5f 13 00 00       	callq  4032f0 <reservation_info_alloc>
    assert(reservationInfoPtr != NULL);
  401f91:	48 85 c0             	test   %rax,%rax
  401f94:	74 0d                	je     401fa3 <customer_addReservationInfo+0x23>

    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    return TMLIST_INSERT(reservationInfoListPtr, (void*)reservationInfoPtr);
  401f96:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  401f9a:	48 89 c6             	mov    %rax,%rsi
}
  401f9d:	5b                   	pop    %rbx
    assert(reservationInfoPtr != NULL);

    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    return TMLIST_INSERT(reservationInfoListPtr, (void*)reservationInfoPtr);
  401f9e:	e9 2d 27 00 00       	jmpq   4046d0 <TMlist_insert>
                             reservation_type_t type, long id, long price)
{
    reservation_info_t* reservationInfoPtr;

    reservationInfoPtr = RESERVATION_INFO_ALLOC(type, id, price);
    assert(reservationInfoPtr != NULL);
  401fa3:	b9 f0 8b 40 00       	mov    $0x408bf0,%ecx
  401fa8:	ba ac 00 00 00       	mov    $0xac,%edx
  401fad:	be 48 8b 40 00       	mov    $0x408b48,%esi
  401fb2:	bf a8 8b 40 00       	mov    $0x408ba8,%edi
  401fb7:	e8 94 ec ff ff       	callq  400c50 <__assert_fail@plt>
  401fbc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000401fc0 <customer_removeReservationInfo>:
 */
bool_t
customer_removeReservationInfo (TM_ARGDECL
                                customer_t* customerPtr,
                                reservation_type_t type, long id)
{
  401fc0:	55                   	push   %rbp
  401fc1:	53                   	push   %rbx
  401fc2:	48 83 ec 28          	sub    $0x28,%rsp

    findReservationInfo.type = type;
    findReservationInfo.id = id;
    /* price not used to compare reservation infos */

    list_t* reservationInfoListPtr =
  401fc6:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
                                customer_t* customerPtr,
                                reservation_type_t type, long id)
{
    reservation_info_t findReservationInfo;

    findReservationInfo.type = type;
  401fca:	89 34 24             	mov    %esi,(%rsp)
    /* price not used to compare reservation infos */

    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    reservation_info_t* reservationInfoPtr =
  401fcd:	48 89 e6             	mov    %rsp,%rsi
                                reservation_type_t type, long id)
{
    reservation_info_t findReservationInfo;

    findReservationInfo.type = type;
    findReservationInfo.id = id;
  401fd0:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
    /* price not used to compare reservation infos */

    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    reservation_info_t* reservationInfoPtr =
  401fd5:	48 89 ef             	mov    %rbp,%rdi
  401fd8:	e8 33 25 00 00       	callq  404510 <TMlist_find>
        (reservation_info_t*)TMLIST_FIND(reservationInfoListPtr,
                                         &findReservationInfo);

    if (reservationInfoPtr == NULL) {
  401fdd:	48 85 c0             	test   %rax,%rax
    /* price not used to compare reservation infos */

    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    reservation_info_t* reservationInfoPtr =
  401fe0:	48 89 c3             	mov    %rax,%rbx
        (reservation_info_t*)TMLIST_FIND(reservationInfoListPtr,
                                         &findReservationInfo);

    if (reservationInfoPtr == NULL) {
  401fe3:	74 2b                	je     402010 <customer_removeReservationInfo+0x50>
        return FALSE;
    }

    bool_t status = TMLIST_REMOVE(reservationInfoListPtr,
  401fe5:	48 89 e6             	mov    %rsp,%rsi
  401fe8:	48 89 ef             	mov    %rbp,%rdi
  401feb:	e8 e0 28 00 00       	callq  4048d0 <TMlist_remove>
                                  (void*)&findReservationInfo);
    if (status == FALSE) {
  401ff0:	48 85 c0             	test   %rax,%rax
  401ff3:	74 24                	je     402019 <customer_removeReservationInfo+0x59>
        TM_RESTART();
    }

    RESERVATION_INFO_FREE(reservationInfoPtr);
  401ff5:	48 89 df             	mov    %rbx,%rdi
  401ff8:	e8 23 13 00 00       	callq  403320 <reservation_info_free>

    return TRUE;
}
  401ffd:	48 83 c4 28          	add    $0x28,%rsp
        TM_RESTART();
    }

    RESERVATION_INFO_FREE(reservationInfoPtr);

    return TRUE;
  402001:	b8 01 00 00 00       	mov    $0x1,%eax
}
  402006:	5b                   	pop    %rbx
  402007:	5d                   	pop    %rbp
  402008:	c3                   	retq   
  402009:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  402010:	48 83 c4 28          	add    $0x28,%rsp
    reservation_info_t* reservationInfoPtr =
        (reservation_info_t*)TMLIST_FIND(reservationInfoListPtr,
                                         &findReservationInfo);

    if (reservationInfoPtr == NULL) {
        return FALSE;
  402014:	31 c0                	xor    %eax,%eax
    }

    RESERVATION_INFO_FREE(reservationInfoPtr);

    return TRUE;
}
  402016:	5b                   	pop    %rbx
  402017:	5d                   	pop    %rbp
  402018:	c3                   	retq   
    }

    bool_t status = TMLIST_REMOVE(reservationInfoListPtr,
                                  (void*)&findReservationInfo);
    if (status == FALSE) {
        TM_RESTART();
  402019:	b9 d0 8b 40 00       	mov    $0x408bd0,%ecx
  40201e:	ba d3 00 00 00       	mov    $0xd3,%edx
  402023:	be 48 8b 40 00       	mov    $0x408b48,%esi
  402028:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  40202d:	e8 1e ec ff ff       	callq  400c50 <__assert_fail@plt>
  402032:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402039:	1f 84 00 00 00 00 00 

0000000000402040 <customer_getBill>:
 * -- Returns total cost of reservations
 * =============================================================================
 */
long
customer_getBill (TM_ARGDECL  customer_t* customerPtr)
{
  402040:	55                   	push   %rbp
    long bill = 0;
  402041:	31 ed                	xor    %ebp,%ebp
 * -- Returns total cost of reservations
 * =============================================================================
 */
long
customer_getBill (TM_ARGDECL  customer_t* customerPtr)
{
  402043:	53                   	push   %rbx
  402044:	48 83 ec 18          	sub    $0x18,%rsp
    long bill = 0;
    list_iter_t it;
    list_t* reservationInfoListPtr =
  402048:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
  40204c:	48 89 e7             	mov    %rsp,%rdi
  40204f:	48 89 de             	mov    %rbx,%rsi
  402052:	e8 c9 1e 00 00       	callq  403f20 <TMlist_iter_reset>
    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
  402057:	eb 16                	jmp    40206f <customer_getBill+0x2f>
  402059:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        reservation_info_t* reservationInfoPtr =
  402060:	48 89 de             	mov    %rbx,%rsi
  402063:	48 89 e7             	mov    %rsp,%rdi
  402066:	e8 f5 1e 00 00       	callq  403f60 <TMlist_iter_next>
            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
        bill += reservationInfoPtr->price;
  40206b:	48 03 68 10          	add    0x10(%rax),%rbp
    list_iter_t it;
    list_t* reservationInfoListPtr =
        (list_t*)TM_SHARED_READ(customerPtr->reservationInfoListPtr);

    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
  40206f:	48 89 de             	mov    %rbx,%rsi
  402072:	48 89 e7             	mov    %rsp,%rdi
  402075:	e8 c6 1e 00 00       	callq  403f40 <TMlist_iter_hasNext>
  40207a:	48 85 c0             	test   %rax,%rax
  40207d:	75 e1                	jne    402060 <customer_getBill+0x20>
            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
        bill += reservationInfoPtr->price;
    }

    return bill;
}
  40207f:	48 83 c4 18          	add    $0x18,%rsp
  402083:	48 89 e8             	mov    %rbp,%rax
  402086:	5b                   	pop    %rbx
  402087:	5d                   	pop    %rbp
  402088:	c3                   	retq   
  402089:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402090 <manager_alloc>:
 * manager_alloc
 * =============================================================================
 */
manager_t*
manager_alloc ()
{
  402090:	53                   	push   %rbx
    manager_t* managerPtr;

    managerPtr = (manager_t*)malloc(sizeof(manager_t));
  402091:	bf 20 00 00 00       	mov    $0x20,%edi
  402096:	e8 e5 eb ff ff       	callq  400c80 <malloc@plt>
    assert(managerPtr != NULL);
  40209b:	48 85 c0             	test   %rax,%rax
manager_t*
manager_alloc ()
{
    manager_t* managerPtr;

    managerPtr = (manager_t*)malloc(sizeof(manager_t));
  40209e:	48 89 c3             	mov    %rax,%rbx
    assert(managerPtr != NULL);
  4020a1:	74 49                	je     4020ec <manager_alloc+0x5c>
 * =============================================================================
 */
static MAP_T*
tableAlloc ()
{
    return MAP_ALLOC(NULL, NULL);
  4020a3:	31 ff                	xor    %edi,%edi
  4020a5:	e8 d6 57 00 00       	callq  407880 <rbtree_alloc>
  4020aa:	31 ff                	xor    %edi,%edi
    manager_t* managerPtr;

    managerPtr = (manager_t*)malloc(sizeof(manager_t));
    assert(managerPtr != NULL);

    managerPtr->carTablePtr = tableAlloc();
  4020ac:	48 89 03             	mov    %rax,(%rbx)
 * =============================================================================
 */
static MAP_T*
tableAlloc ()
{
    return MAP_ALLOC(NULL, NULL);
  4020af:	e8 cc 57 00 00       	callq  407880 <rbtree_alloc>
  4020b4:	31 ff                	xor    %edi,%edi

    managerPtr = (manager_t*)malloc(sizeof(manager_t));
    assert(managerPtr != NULL);

    managerPtr->carTablePtr = tableAlloc();
    managerPtr->roomTablePtr = tableAlloc();
  4020b6:	48 89 43 08          	mov    %rax,0x8(%rbx)
 * =============================================================================
 */
static MAP_T*
tableAlloc ()
{
    return MAP_ALLOC(NULL, NULL);
  4020ba:	e8 c1 57 00 00       	callq  407880 <rbtree_alloc>
  4020bf:	31 ff                	xor    %edi,%edi
    managerPtr = (manager_t*)malloc(sizeof(manager_t));
    assert(managerPtr != NULL);

    managerPtr->carTablePtr = tableAlloc();
    managerPtr->roomTablePtr = tableAlloc();
    managerPtr->flightTablePtr = tableAlloc();
  4020c1:	48 89 43 10          	mov    %rax,0x10(%rbx)
 * =============================================================================
 */
static MAP_T*
tableAlloc ()
{
    return MAP_ALLOC(NULL, NULL);
  4020c5:	e8 b6 57 00 00       	callq  407880 <rbtree_alloc>

    managerPtr->carTablePtr = tableAlloc();
    managerPtr->roomTablePtr = tableAlloc();
    managerPtr->flightTablePtr = tableAlloc();
    managerPtr->customerTablePtr = tableAlloc();
    assert(managerPtr->carTablePtr != NULL);
  4020ca:	48 83 3b 00          	cmpq   $0x0,(%rbx)
    assert(managerPtr != NULL);

    managerPtr->carTablePtr = tableAlloc();
    managerPtr->roomTablePtr = tableAlloc();
    managerPtr->flightTablePtr = tableAlloc();
    managerPtr->customerTablePtr = tableAlloc();
  4020ce:	48 89 43 18          	mov    %rax,0x18(%rbx)
    assert(managerPtr->carTablePtr != NULL);
  4020d2:	74 7c                	je     402150 <manager_alloc+0xc0>
    assert(managerPtr->roomTablePtr != NULL);
  4020d4:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
  4020d9:	74 5c                	je     402137 <manager_alloc+0xa7>
    assert(managerPtr->flightTablePtr != NULL);
  4020db:	48 83 7b 10 00       	cmpq   $0x0,0x10(%rbx)
  4020e0:	74 3c                	je     40211e <manager_alloc+0x8e>
    assert(managerPtr->customerTablePtr != NULL);
  4020e2:	48 85 c0             	test   %rax,%rax
  4020e5:	74 1e                	je     402105 <manager_alloc+0x75>

    return managerPtr;
}
  4020e7:	48 89 d8             	mov    %rbx,%rax
  4020ea:	5b                   	pop    %rbx
  4020eb:	c3                   	retq   
manager_alloc ()
{
    manager_t* managerPtr;

    managerPtr = (manager_t*)malloc(sizeof(manager_t));
    assert(managerPtr != NULL);
  4020ec:	b9 c2 8d 40 00       	mov    $0x408dc2,%ecx
  4020f1:	ba 7e 00 00 00       	mov    $0x7e,%edx
  4020f6:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4020fb:	bf 3c 8c 40 00       	mov    $0x408c3c,%edi
  402100:	e8 4b eb ff ff       	callq  400c50 <__assert_fail@plt>
    managerPtr->flightTablePtr = tableAlloc();
    managerPtr->customerTablePtr = tableAlloc();
    assert(managerPtr->carTablePtr != NULL);
    assert(managerPtr->roomTablePtr != NULL);
    assert(managerPtr->flightTablePtr != NULL);
    assert(managerPtr->customerTablePtr != NULL);
  402105:	b9 c2 8d 40 00       	mov    $0x408dc2,%ecx
  40210a:	ba 87 00 00 00       	mov    $0x87,%edx
  40210f:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402114:	bf 00 8d 40 00       	mov    $0x408d00,%edi
  402119:	e8 32 eb ff ff       	callq  400c50 <__assert_fail@plt>
    managerPtr->roomTablePtr = tableAlloc();
    managerPtr->flightTablePtr = tableAlloc();
    managerPtr->customerTablePtr = tableAlloc();
    assert(managerPtr->carTablePtr != NULL);
    assert(managerPtr->roomTablePtr != NULL);
    assert(managerPtr->flightTablePtr != NULL);
  40211e:	b9 c2 8d 40 00       	mov    $0x408dc2,%ecx
  402123:	ba 86 00 00 00       	mov    $0x86,%edx
  402128:	be 32 8c 40 00       	mov    $0x408c32,%esi
  40212d:	bf d0 8c 40 00       	mov    $0x408cd0,%edi
  402132:	e8 19 eb ff ff       	callq  400c50 <__assert_fail@plt>
    managerPtr->carTablePtr = tableAlloc();
    managerPtr->roomTablePtr = tableAlloc();
    managerPtr->flightTablePtr = tableAlloc();
    managerPtr->customerTablePtr = tableAlloc();
    assert(managerPtr->carTablePtr != NULL);
    assert(managerPtr->roomTablePtr != NULL);
  402137:	b9 c2 8d 40 00       	mov    $0x408dc2,%ecx
  40213c:	ba 85 00 00 00       	mov    $0x85,%edx
  402141:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402146:	bf a8 8c 40 00       	mov    $0x408ca8,%edi
  40214b:	e8 00 eb ff ff       	callq  400c50 <__assert_fail@plt>

    managerPtr->carTablePtr = tableAlloc();
    managerPtr->roomTablePtr = tableAlloc();
    managerPtr->flightTablePtr = tableAlloc();
    managerPtr->customerTablePtr = tableAlloc();
    assert(managerPtr->carTablePtr != NULL);
  402150:	b9 c2 8d 40 00       	mov    $0x408dc2,%ecx
  402155:	ba 84 00 00 00       	mov    $0x84,%edx
  40215a:	be 32 8c 40 00       	mov    $0x408c32,%esi
  40215f:	bf 80 8c 40 00       	mov    $0x408c80,%edi
  402164:	e8 e7 ea ff ff       	callq  400c50 <__assert_fail@plt>
  402169:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000402170 <manager_free>:
 * manager_free
 * =============================================================================
 */
void
manager_free (manager_t* managerPtr)
{
  402170:	53                   	push   %rbx
  402171:	48 89 fb             	mov    %rdi,%rbx
 * =============================================================================
 */
static void
tableFree (MAP_T* mapPtr)
{
    MAP_FREE(mapPtr);
  402174:	48 8b 3f             	mov    (%rdi),%rdi
  402177:	e8 64 57 00 00       	callq  4078e0 <rbtree_free>
  40217c:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
  402180:	e8 5b 57 00 00       	callq  4078e0 <rbtree_free>
  402185:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
  402189:	e8 52 57 00 00       	callq  4078e0 <rbtree_free>
  40218e:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
{
    tableFree(managerPtr->carTablePtr);
    tableFree(managerPtr->roomTablePtr);
    tableFree(managerPtr->flightTablePtr);
    tableFree(managerPtr->customerTablePtr);
}
  402192:	5b                   	pop    %rbx
 * =============================================================================
 */
static void
tableFree (MAP_T* mapPtr)
{
    MAP_FREE(mapPtr);
  402193:	e9 48 57 00 00       	jmpq   4078e0 <rbtree_free>
  402198:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40219f:	00 

00000000004021a0 <addReservation>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
  4021a0:	41 56                	push   %r14
  4021a2:	49 89 ce             	mov    %rcx,%r14
  4021a5:	41 55                	push   %r13
  4021a7:	49 89 d5             	mov    %rdx,%r13
  4021aa:	41 54                	push   %r12
  4021ac:	49 89 fc             	mov    %rdi,%r12
  4021af:	55                   	push   %rbp
  4021b0:	48 89 f5             	mov    %rsi,%rbp
  4021b3:	53                   	push   %rbx
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4021b4:	e8 57 5f 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  4021b9:	48 85 c0             	test   %rax,%rax
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4021bc:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  4021bf:	74 47                	je     402208 <addReservation+0x68>
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  4021c1:	4c 89 ee             	mov    %r13,%rsi
  4021c4:	48 89 c7             	mov    %rax,%rdi
  4021c7:	e8 84 12 00 00       	callq  403450 <reservation_addToTotal>
  4021cc:	48 85 c0             	test   %rax,%rax
  4021cf:	74 4f                	je     402220 <addReservation+0x80>
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
  4021d1:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  4021d6:	75 58                	jne    402230 <addReservation+0x90>
            bool_t status = TMMAP_REMOVE(tablePtr, id);
  4021d8:	48 89 ee             	mov    %rbp,%rsi
  4021db:	4c 89 e7             	mov    %r12,%rdi
  4021de:	e8 1d 5b 00 00       	callq  407d00 <TMrbtree_delete>
            if (status == FALSE) {
  4021e3:	48 85 c0             	test   %rax,%rax
  4021e6:	0f 84 93 00 00 00    	je     40227f <addReservation+0xdf>
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
  4021ec:	48 89 df             	mov    %rbx,%rdi
  4021ef:	e8 dc 17 00 00       	callq  4039d0 <reservation_free>
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
}
  4021f4:	5b                   	pop    %rbx
  4021f5:	5d                   	pop    %rbp
  4021f6:	41 5c                	pop    %r12
  4021f8:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  4021fa:	b8 01 00 00 00       	mov    $0x1,%eax
}
  4021ff:	41 5e                	pop    %r14
  402201:	c3                   	retq   
  402202:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402208:	4d 85 ed             	test   %r13,%r13
  40220b:	7e 13                	jle    402220 <addReservation+0x80>
  40220d:	4c 89 f0             	mov    %r14,%rax
  402210:	48 c1 e8 3f          	shr    $0x3f,%rax
  402214:	84 c0                	test   %al,%al
  402216:	74 38                	je     402250 <addReservation+0xb0>
  402218:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40221f:	00 
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
}
  402220:	5b                   	pop    %rbx
  402221:	5d                   	pop    %rbp
  402222:	41 5c                	pop    %r12
  402224:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402226:	31 c0                	xor    %eax,%eax
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
}
  402228:	41 5e                	pop    %r14
  40222a:	c3                   	retq   
  40222b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            if (status == FALSE) {
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
  402230:	4c 89 f6             	mov    %r14,%rsi
  402233:	48 89 df             	mov    %rbx,%rdi
  402236:	e8 35 16 00 00       	callq  403870 <reservation_updatePrice>
        }
    }

    return TRUE;
}
  40223b:	5b                   	pop    %rbx
  40223c:	5d                   	pop    %rbp
  40223d:	41 5c                	pop    %r12
  40223f:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402241:	b8 01 00 00 00       	mov    $0x1,%eax
}
  402246:	41 5e                	pop    %r14
  402248:	c3                   	retq   
  402249:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
  402250:	4c 89 f2             	mov    %r14,%rdx
  402253:	4c 89 ee             	mov    %r13,%rsi
  402256:	48 89 ef             	mov    %rbp,%rdi
  402259:	e8 f2 10 00 00       	callq  403350 <reservation_alloc>
        assert(reservationPtr != NULL);
  40225e:	48 85 c0             	test   %rax,%rax
  402261:	74 35                	je     402298 <addReservation+0xf8>
        TMMAP_INSERT(tablePtr, id, reservationPtr);
  402263:	48 89 ee             	mov    %rbp,%rsi
  402266:	4c 89 e7             	mov    %r12,%rdi
  402269:	48 89 c2             	mov    %rax,%rdx
  40226c:	e8 ff 57 00 00       	callq  407a70 <TMrbtree_insert>
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
}
  402271:	5b                   	pop    %rbx
  402272:	5d                   	pop    %rbp
  402273:	41 5c                	pop    %r12
  402275:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402277:	b8 01 00 00 00       	mov    $0x1,%eax
}
  40227c:	41 5e                	pop    %r14
  40227e:	c3                   	retq   
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
            bool_t status = TMMAP_REMOVE(tablePtr, id);
            if (status == FALSE) {
                TM_RESTART();
  40227f:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  402284:	ba cc 00 00 00       	mov    $0xcc,%edx
  402289:	be 32 8c 40 00       	mov    $0x408c32,%esi
  40228e:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402293:	e8 b8 e9 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
  402298:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  40229d:	ba c2 00 00 00       	mov    $0xc2,%edx
  4022a2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4022a7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  4022ac:	e8 9f e9 ff ff       	callq  400c50 <__assert_fail@plt>
  4022b1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4022b8:	0f 1f 84 00 00 00 00 
  4022bf:	00 

00000000004022c0 <addReservation_seq>:
}


bool_t
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
  4022c0:	41 56                	push   %r14
  4022c2:	49 89 ce             	mov    %rcx,%r14
  4022c5:	41 55                	push   %r13
  4022c7:	49 89 d5             	mov    %rdx,%r13
  4022ca:	41 54                	push   %r12
  4022cc:	49 89 fc             	mov    %rdi,%r12
  4022cf:	55                   	push   %rbp
  4022d0:	48 89 f5             	mov    %rsi,%rbp
  4022d3:	53                   	push   %rbx
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  4022d4:	e8 e7 5d 00 00       	callq  4080c0 <rbtree_get>
    if (reservationPtr == NULL) {
  4022d9:	48 85 c0             	test   %rax,%rax
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  4022dc:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  4022df:	74 3f                	je     402320 <addReservation_seq+0x60>
        assert(reservationPtr != NULL);
        status = MAP_INSERT(tablePtr, id, reservationPtr);
        assert(status);
    } else {
        /* Update existing reservation */
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
  4022e1:	4c 89 ee             	mov    %r13,%rsi
  4022e4:	48 89 c7             	mov    %rax,%rdi
  4022e7:	e8 04 12 00 00       	callq  4034f0 <reservation_addToTotal_seq>
  4022ec:	48 85 c0             	test   %rax,%rax
  4022ef:	74 3f                	je     402330 <addReservation_seq+0x70>
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
  4022f1:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  4022f6:	75 48                	jne    402340 <addReservation_seq+0x80>
            status = MAP_REMOVE(tablePtr, id);
  4022f8:	48 89 ee             	mov    %rbp,%rsi
  4022fb:	4c 89 e7             	mov    %r12,%rdi
  4022fe:	e8 7d 58 00 00       	callq  407b80 <rbtree_delete>
            assert(status);
  402303:	48 85 c0             	test   %rax,%rax
  402306:	0f 84 83 00 00 00    	je     40238f <addReservation_seq+0xcf>
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
}
  40230c:	5b                   	pop    %rbx
  40230d:	5d                   	pop    %rbp
  40230e:	41 5c                	pop    %r12
  402310:	41 5d                	pop    %r13
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
  402312:	b8 01 00 00 00       	mov    $0x1,%eax
}
  402317:	41 5e                	pop    %r14
  402319:	c3                   	retq   
  40231a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402320:	4d 85 ed             	test   %r13,%r13
  402323:	7e 0b                	jle    402330 <addReservation_seq+0x70>
  402325:	4c 89 f0             	mov    %r14,%rax
  402328:	48 c1 e8 3f          	shr    $0x3f,%rax
  40232c:	84 c0                	test   %al,%al
  40232e:	74 20                	je     402350 <addReservation_seq+0x90>
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
}
  402330:	5b                   	pop    %rbx
  402331:	5d                   	pop    %rbp
  402332:	41 5c                	pop    %r12
  402334:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402336:	31 c0                	xor    %eax,%eax
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
}
  402338:	41 5e                	pop    %r14
  40233a:	c3                   	retq   
  40233b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
  402340:	4c 89 f6             	mov    %r14,%rsi
  402343:	48 89 df             	mov    %rbx,%rdi
  402346:	e8 c5 15 00 00       	callq  403910 <reservation_updatePrice_seq>
  40234b:	eb bf                	jmp    40230c <addReservation_seq+0x4c>
  40234d:	0f 1f 00             	nopl   (%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
  402350:	4c 89 f2             	mov    %r14,%rdx
  402353:	4c 89 ee             	mov    %r13,%rsi
  402356:	48 89 ef             	mov    %rbp,%rdi
  402359:	e8 72 10 00 00       	callq  4033d0 <reservation_alloc_seq>
        assert(reservationPtr != NULL);
  40235e:	48 85 c0             	test   %rax,%rax
  402361:	74 45                	je     4023a8 <addReservation_seq+0xe8>
        status = MAP_INSERT(tablePtr, id, reservationPtr);
  402363:	48 89 c2             	mov    %rax,%rdx
  402366:	48 89 ee             	mov    %rbp,%rsi
  402369:	4c 89 e7             	mov    %r12,%rdi
  40236c:	e8 ef 55 00 00       	callq  407960 <rbtree_insert>
        assert(status);
  402371:	48 85 c0             	test   %rax,%rax
  402374:	75 96                	jne    40230c <addReservation_seq+0x4c>
  402376:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  40237b:	ba e7 00 00 00       	mov    $0xe7,%edx
  402380:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402385:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  40238a:	e8 c1 e8 ff ff       	callq  400c50 <__assert_fail@plt>
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
  40238f:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  402394:	ba ef 00 00 00       	mov    $0xef,%edx
  402399:	be 32 8c 40 00       	mov    $0x408c32,%esi
  40239e:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  4023a3:	e8 a8 e8 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
        assert(reservationPtr != NULL);
  4023a8:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  4023ad:	ba e5 00 00 00       	mov    $0xe5,%edx
  4023b2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4023b7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  4023bc:	e8 8f e8 ff ff       	callq  400c50 <__assert_fail@plt>
  4023c1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4023c8:	0f 1f 84 00 00 00 00 
  4023cf:	00 

00000000004023d0 <manager_addCar>:
 * =============================================================================
 */
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
  4023d0:	41 56                	push   %r14
  4023d2:	49 89 ce             	mov    %rcx,%r14
  4023d5:	41 55                	push   %r13
  4023d7:	49 89 d5             	mov    %rdx,%r13
  4023da:	41 54                	push   %r12
  4023dc:	55                   	push   %rbp
  4023dd:	48 89 f5             	mov    %rsi,%rbp
  4023e0:	53                   	push   %rbx
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
  4023e1:	4c 8b 27             	mov    (%rdi),%r12
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4023e4:	4c 89 e7             	mov    %r12,%rdi
  4023e7:	e8 24 5d 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  4023ec:	48 85 c0             	test   %rax,%rax
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4023ef:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  4023f2:	74 44                	je     402438 <manager_addCar+0x68>
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  4023f4:	4c 89 ee             	mov    %r13,%rsi
  4023f7:	48 89 c7             	mov    %rax,%rdi
  4023fa:	e8 51 10 00 00       	callq  403450 <reservation_addToTotal>
  4023ff:	48 85 c0             	test   %rax,%rax
  402402:	74 4c                	je     402450 <manager_addCar+0x80>
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
  402404:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  402409:	75 55                	jne    402460 <manager_addCar+0x90>
            bool_t status = TMMAP_REMOVE(tablePtr, id);
  40240b:	48 89 ee             	mov    %rbp,%rsi
  40240e:	4c 89 e7             	mov    %r12,%rdi
  402411:	e8 ea 58 00 00       	callq  407d00 <TMrbtree_delete>
            if (status == FALSE) {
  402416:	48 85 c0             	test   %rax,%rax
  402419:	0f 84 90 00 00 00    	je     4024af <manager_addCar+0xdf>
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
  40241f:	48 89 df             	mov    %rbx,%rdi
  402422:	e8 a9 15 00 00       	callq  4039d0 <reservation_free>
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  402427:	5b                   	pop    %rbx
  402428:	5d                   	pop    %rbp
  402429:	41 5c                	pop    %r12
  40242b:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  40242d:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  402432:	41 5e                	pop    %r14
  402434:	c3                   	retq   
  402435:	0f 1f 00             	nopl   (%rax)
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402438:	4d 85 ed             	test   %r13,%r13
  40243b:	7e 13                	jle    402450 <manager_addCar+0x80>
  40243d:	4c 89 f0             	mov    %r14,%rax
  402440:	48 c1 e8 3f          	shr    $0x3f,%rax
  402444:	84 c0                	test   %al,%al
  402446:	74 38                	je     402480 <manager_addCar+0xb0>
  402448:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40244f:	00 
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  402450:	5b                   	pop    %rbx
  402451:	5d                   	pop    %rbp
  402452:	41 5c                	pop    %r12
  402454:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402456:	31 c0                	xor    %eax,%eax
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  402458:	41 5e                	pop    %r14
  40245a:	c3                   	retq   
  40245b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            if (status == FALSE) {
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
  402460:	4c 89 f6             	mov    %r14,%rsi
  402463:	48 89 df             	mov    %rbx,%rdi
  402466:	e8 05 14 00 00       	callq  403870 <reservation_updatePrice>
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  40246b:	5b                   	pop    %rbx
  40246c:	5d                   	pop    %rbp
  40246d:	41 5c                	pop    %r12
  40246f:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402471:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  402476:	41 5e                	pop    %r14
  402478:	c3                   	retq   
  402479:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
  402480:	4c 89 f2             	mov    %r14,%rdx
  402483:	4c 89 ee             	mov    %r13,%rsi
  402486:	48 89 ef             	mov    %rbp,%rdi
  402489:	e8 c2 0e 00 00       	callq  403350 <reservation_alloc>
        assert(reservationPtr != NULL);
  40248e:	48 85 c0             	test   %rax,%rax
  402491:	74 35                	je     4024c8 <manager_addCar+0xf8>
        TMMAP_INSERT(tablePtr, id, reservationPtr);
  402493:	48 89 ee             	mov    %rbp,%rsi
  402496:	4c 89 e7             	mov    %r12,%rdi
  402499:	48 89 c2             	mov    %rax,%rdx
  40249c:	e8 cf 55 00 00       	callq  407a70 <TMrbtree_insert>
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  4024a1:	5b                   	pop    %rbx
  4024a2:	5d                   	pop    %rbp
  4024a3:	41 5c                	pop    %r12
  4024a5:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  4024a7:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_addCar (TM_ARGDECL
                manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, numCars, price);
}
  4024ac:	41 5e                	pop    %r14
  4024ae:	c3                   	retq   
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
            bool_t status = TMMAP_REMOVE(tablePtr, id);
            if (status == FALSE) {
                TM_RESTART();
  4024af:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  4024b4:	ba cc 00 00 00       	mov    $0xcc,%edx
  4024b9:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4024be:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4024c3:	e8 88 e7 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
  4024c8:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  4024cd:	ba c2 00 00 00       	mov    $0xc2,%edx
  4024d2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4024d7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  4024dc:	e8 6f e7 ff ff       	callq  400c50 <__assert_fail@plt>
  4024e1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4024e8:	0f 1f 84 00 00 00 00 
  4024ef:	00 

00000000004024f0 <manager_addCar_seq>:
}


bool_t
manager_addCar_seq (manager_t* managerPtr, long carId, long numCars, long price)
{
  4024f0:	41 56                	push   %r14
  4024f2:	49 89 ce             	mov    %rcx,%r14
  4024f5:	41 55                	push   %r13
  4024f7:	49 89 d5             	mov    %rdx,%r13
  4024fa:	41 54                	push   %r12
  4024fc:	55                   	push   %rbp
  4024fd:	48 89 f5             	mov    %rsi,%rbp
  402500:	53                   	push   %rbx
    return addReservation_seq(managerPtr->carTablePtr, carId, numCars, price);
  402501:	4c 8b 27             	mov    (%rdi),%r12
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  402504:	4c 89 e7             	mov    %r12,%rdi
  402507:	e8 b4 5b 00 00       	callq  4080c0 <rbtree_get>
    if (reservationPtr == NULL) {
  40250c:	48 85 c0             	test   %rax,%rax
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  40250f:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  402512:	74 3c                	je     402550 <manager_addCar_seq+0x60>
        assert(reservationPtr != NULL);
        status = MAP_INSERT(tablePtr, id, reservationPtr);
        assert(status);
    } else {
        /* Update existing reservation */
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
  402514:	4c 89 ee             	mov    %r13,%rsi
  402517:	48 89 c7             	mov    %rax,%rdi
  40251a:	e8 d1 0f 00 00       	callq  4034f0 <reservation_addToTotal_seq>
  40251f:	48 85 c0             	test   %rax,%rax
  402522:	74 3c                	je     402560 <manager_addCar_seq+0x70>
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
  402524:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  402529:	75 45                	jne    402570 <manager_addCar_seq+0x80>
            status = MAP_REMOVE(tablePtr, id);
  40252b:	48 89 ee             	mov    %rbp,%rsi
  40252e:	4c 89 e7             	mov    %r12,%rdi
  402531:	e8 4a 56 00 00       	callq  407b80 <rbtree_delete>
            assert(status);
  402536:	48 85 c0             	test   %rax,%rax
  402539:	0f 84 80 00 00 00    	je     4025bf <manager_addCar_seq+0xcf>

bool_t
manager_addCar_seq (manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation_seq(managerPtr->carTablePtr, carId, numCars, price);
}
  40253f:	5b                   	pop    %rbx
  402540:	5d                   	pop    %rbp
  402541:	41 5c                	pop    %r12
  402543:	41 5d                	pop    %r13
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
  402545:	b8 01 00 00 00       	mov    $0x1,%eax

bool_t
manager_addCar_seq (manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation_seq(managerPtr->carTablePtr, carId, numCars, price);
}
  40254a:	41 5e                	pop    %r14
  40254c:	c3                   	retq   
  40254d:	0f 1f 00             	nopl   (%rax)
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402550:	4d 85 ed             	test   %r13,%r13
  402553:	7e 0b                	jle    402560 <manager_addCar_seq+0x70>
  402555:	4c 89 f0             	mov    %r14,%rax
  402558:	48 c1 e8 3f          	shr    $0x3f,%rax
  40255c:	84 c0                	test   %al,%al
  40255e:	74 20                	je     402580 <manager_addCar_seq+0x90>

bool_t
manager_addCar_seq (manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation_seq(managerPtr->carTablePtr, carId, numCars, price);
}
  402560:	5b                   	pop    %rbx
  402561:	5d                   	pop    %rbp
  402562:	41 5c                	pop    %r12
  402564:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402566:	31 c0                	xor    %eax,%eax

bool_t
manager_addCar_seq (manager_t* managerPtr, long carId, long numCars, long price)
{
    return addReservation_seq(managerPtr->carTablePtr, carId, numCars, price);
}
  402568:	41 5e                	pop    %r14
  40256a:	c3                   	retq   
  40256b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
  402570:	4c 89 f6             	mov    %r14,%rsi
  402573:	48 89 df             	mov    %rbx,%rdi
  402576:	e8 95 13 00 00       	callq  403910 <reservation_updatePrice_seq>
  40257b:	eb c2                	jmp    40253f <manager_addCar_seq+0x4f>
  40257d:	0f 1f 00             	nopl   (%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
  402580:	4c 89 f2             	mov    %r14,%rdx
  402583:	4c 89 ee             	mov    %r13,%rsi
  402586:	48 89 ef             	mov    %rbp,%rdi
  402589:	e8 42 0e 00 00       	callq  4033d0 <reservation_alloc_seq>
        assert(reservationPtr != NULL);
  40258e:	48 85 c0             	test   %rax,%rax
  402591:	74 45                	je     4025d8 <manager_addCar_seq+0xe8>
        status = MAP_INSERT(tablePtr, id, reservationPtr);
  402593:	48 89 c2             	mov    %rax,%rdx
  402596:	48 89 ee             	mov    %rbp,%rsi
  402599:	4c 89 e7             	mov    %r12,%rdi
  40259c:	e8 bf 53 00 00       	callq  407960 <rbtree_insert>
        assert(status);
  4025a1:	48 85 c0             	test   %rax,%rax
  4025a4:	75 99                	jne    40253f <manager_addCar_seq+0x4f>
  4025a6:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  4025ab:	ba e7 00 00 00       	mov    $0xe7,%edx
  4025b0:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4025b5:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  4025ba:	e8 91 e6 ff ff       	callq  400c50 <__assert_fail@plt>
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
  4025bf:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  4025c4:	ba ef 00 00 00       	mov    $0xef,%edx
  4025c9:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4025ce:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  4025d3:	e8 78 e6 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
        assert(reservationPtr != NULL);
  4025d8:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  4025dd:	ba e5 00 00 00       	mov    $0xe5,%edx
  4025e2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4025e7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  4025ec:	e8 5f e6 ff ff       	callq  400c50 <__assert_fail@plt>
  4025f1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4025f8:	0f 1f 84 00 00 00 00 
  4025ff:	00 

0000000000402600 <manager_deleteCar>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
  402600:	41 55                	push   %r13
  402602:	49 89 d5             	mov    %rdx,%r13
  402605:	41 54                	push   %r12
  402607:	49 89 f4             	mov    %rsi,%r12
  40260a:	55                   	push   %rbp
  40260b:	53                   	push   %rbx
  40260c:	48 83 ec 08          	sub    $0x8,%rsp
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
  402610:	48 8b 2f             	mov    (%rdi),%rbp
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402613:	48 89 ef             	mov    %rbp,%rdi
  402616:	e8 f5 5a 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  40261b:	48 85 c0             	test   %rax,%rax
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40261e:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  402621:	74 45                	je     402668 <manager_deleteCar+0x68>
 */
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
  402623:	4c 89 ee             	mov    %r13,%rsi
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  402626:	48 89 c7             	mov    %rax,%rdi
 */
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
  402629:	48 f7 de             	neg    %rsi
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  40262c:	e8 1f 0e 00 00       	callq  403450 <reservation_addToTotal>
  402631:	48 85 c0             	test   %rax,%rax
  402634:	74 32                	je     402668 <manager_deleteCar+0x68>
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
  402636:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  40263b:	75 3b                	jne    402678 <manager_deleteCar+0x78>
            bool_t status = TMMAP_REMOVE(tablePtr, id);
  40263d:	4c 89 e6             	mov    %r12,%rsi
  402640:	48 89 ef             	mov    %rbp,%rdi
  402643:	e8 b8 56 00 00       	callq  407d00 <TMrbtree_delete>
            if (status == FALSE) {
  402648:	48 85 c0             	test   %rax,%rax
  40264b:	74 4a                	je     402697 <manager_deleteCar+0x97>
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
  40264d:	48 89 df             	mov    %rbx,%rdi
  402650:	e8 7b 13 00 00       	callq  4039d0 <reservation_free>
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
}
  402655:	48 83 c4 08          	add    $0x8,%rsp
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402659:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
}
  40265e:	5b                   	pop    %rbx
  40265f:	5d                   	pop    %rbp
  402660:	41 5c                	pop    %r12
  402662:	41 5d                	pop    %r13
  402664:	c3                   	retq   
  402665:	0f 1f 00             	nopl   (%rax)
  402668:	48 83 c4 08          	add    $0x8,%rsp

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  40266c:	31 c0                	xor    %eax,%eax
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
}
  40266e:	5b                   	pop    %rbx
  40266f:	5d                   	pop    %rbp
  402670:	41 5c                	pop    %r12
  402672:	41 5d                	pop    %r13
  402674:	c3                   	retq   
  402675:	0f 1f 00             	nopl   (%rax)
            if (status == FALSE) {
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
  402678:	48 89 df             	mov    %rbx,%rdi
  40267b:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  402682:	e8 e9 11 00 00       	callq  403870 <reservation_updatePrice>
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
}
  402687:	48 83 c4 08          	add    $0x8,%rsp
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  40268b:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_deleteCar (TM_ARGDECL  manager_t* managerPtr, long carId, long numCar)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->carTablePtr, carId, -numCar, -1);
}
  402690:	5b                   	pop    %rbx
  402691:	5d                   	pop    %rbp
  402692:	41 5c                	pop    %r12
  402694:	41 5d                	pop    %r13
  402696:	c3                   	retq   
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
            bool_t status = TMMAP_REMOVE(tablePtr, id);
            if (status == FALSE) {
                TM_RESTART();
  402697:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  40269c:	ba cc 00 00 00       	mov    $0xcc,%edx
  4026a1:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4026a6:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4026ab:	e8 a0 e5 ff ff       	callq  400c50 <__assert_fail@plt>

00000000004026b0 <manager_addRoom>:
 * =============================================================================
 */
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
  4026b0:	41 56                	push   %r14
  4026b2:	49 89 ce             	mov    %rcx,%r14
  4026b5:	41 55                	push   %r13
  4026b7:	49 89 d5             	mov    %rdx,%r13
  4026ba:	41 54                	push   %r12
  4026bc:	55                   	push   %rbp
  4026bd:	48 89 f5             	mov    %rsi,%rbp
  4026c0:	53                   	push   %rbx
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
  4026c1:	4c 8b 67 08          	mov    0x8(%rdi),%r12
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4026c5:	4c 89 e7             	mov    %r12,%rdi
  4026c8:	e8 43 5a 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  4026cd:	48 85 c0             	test   %rax,%rax
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4026d0:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  4026d3:	74 4b                	je     402720 <manager_addRoom+0x70>
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  4026d5:	4c 89 ee             	mov    %r13,%rsi
  4026d8:	48 89 c7             	mov    %rax,%rdi
  4026db:	e8 70 0d 00 00       	callq  403450 <reservation_addToTotal>
  4026e0:	48 85 c0             	test   %rax,%rax
  4026e3:	74 4b                	je     402730 <manager_addRoom+0x80>
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
  4026e5:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  4026ea:	75 54                	jne    402740 <manager_addRoom+0x90>
            bool_t status = TMMAP_REMOVE(tablePtr, id);
  4026ec:	48 89 ee             	mov    %rbp,%rsi
  4026ef:	4c 89 e7             	mov    %r12,%rdi
  4026f2:	e8 09 56 00 00       	callq  407d00 <TMrbtree_delete>
            if (status == FALSE) {
  4026f7:	48 85 c0             	test   %rax,%rax
  4026fa:	0f 84 8f 00 00 00    	je     40278f <manager_addRoom+0xdf>
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
  402700:	48 89 df             	mov    %rbx,%rdi
  402703:	e8 c8 12 00 00       	callq  4039d0 <reservation_free>
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402708:	5b                   	pop    %rbx
  402709:	5d                   	pop    %rbp
  40270a:	41 5c                	pop    %r12
  40270c:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  40270e:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402713:	41 5e                	pop    %r14
  402715:	c3                   	retq   
  402716:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40271d:	00 00 00 
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402720:	4d 85 ed             	test   %r13,%r13
  402723:	7e 0b                	jle    402730 <manager_addRoom+0x80>
  402725:	4c 89 f0             	mov    %r14,%rax
  402728:	48 c1 e8 3f          	shr    $0x3f,%rax
  40272c:	84 c0                	test   %al,%al
  40272e:	74 30                	je     402760 <manager_addRoom+0xb0>
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402730:	5b                   	pop    %rbx
  402731:	5d                   	pop    %rbp
  402732:	41 5c                	pop    %r12
  402734:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402736:	31 c0                	xor    %eax,%eax
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402738:	41 5e                	pop    %r14
  40273a:	c3                   	retq   
  40273b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            if (status == FALSE) {
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
  402740:	4c 89 f6             	mov    %r14,%rsi
  402743:	48 89 df             	mov    %rbx,%rdi
  402746:	e8 25 11 00 00       	callq  403870 <reservation_updatePrice>
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  40274b:	5b                   	pop    %rbx
  40274c:	5d                   	pop    %rbp
  40274d:	41 5c                	pop    %r12
  40274f:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402751:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402756:	41 5e                	pop    %r14
  402758:	c3                   	retq   
  402759:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
  402760:	4c 89 f2             	mov    %r14,%rdx
  402763:	4c 89 ee             	mov    %r13,%rsi
  402766:	48 89 ef             	mov    %rbp,%rdi
  402769:	e8 e2 0b 00 00       	callq  403350 <reservation_alloc>
        assert(reservationPtr != NULL);
  40276e:	48 85 c0             	test   %rax,%rax
  402771:	74 35                	je     4027a8 <manager_addRoom+0xf8>
        TMMAP_INSERT(tablePtr, id, reservationPtr);
  402773:	48 89 ee             	mov    %rbp,%rsi
  402776:	4c 89 e7             	mov    %r12,%rdi
  402779:	48 89 c2             	mov    %rax,%rdx
  40277c:	e8 ef 52 00 00       	callq  407a70 <TMrbtree_insert>
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402781:	5b                   	pop    %rbx
  402782:	5d                   	pop    %rbp
  402783:	41 5c                	pop    %r12
  402785:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402787:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_addRoom (TM_ARGDECL
                 manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, numRoom, price);
}
  40278c:	41 5e                	pop    %r14
  40278e:	c3                   	retq   
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
            bool_t status = TMMAP_REMOVE(tablePtr, id);
            if (status == FALSE) {
                TM_RESTART();
  40278f:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  402794:	ba cc 00 00 00       	mov    $0xcc,%edx
  402799:	be 32 8c 40 00       	mov    $0x408c32,%esi
  40279e:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4027a3:	e8 a8 e4 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
  4027a8:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  4027ad:	ba c2 00 00 00       	mov    $0xc2,%edx
  4027b2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4027b7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  4027bc:	e8 8f e4 ff ff       	callq  400c50 <__assert_fail@plt>
  4027c1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4027c8:	0f 1f 84 00 00 00 00 
  4027cf:	00 

00000000004027d0 <manager_addRoom_seq>:
}


bool_t
manager_addRoom_seq (manager_t* managerPtr, long roomId, long numRoom, long price)
{
  4027d0:	41 56                	push   %r14
  4027d2:	49 89 ce             	mov    %rcx,%r14
  4027d5:	41 55                	push   %r13
  4027d7:	49 89 d5             	mov    %rdx,%r13
  4027da:	41 54                	push   %r12
  4027dc:	55                   	push   %rbp
  4027dd:	48 89 f5             	mov    %rsi,%rbp
  4027e0:	53                   	push   %rbx
    return addReservation_seq(managerPtr->roomTablePtr, roomId, numRoom, price);
  4027e1:	4c 8b 67 08          	mov    0x8(%rdi),%r12
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  4027e5:	4c 89 e7             	mov    %r12,%rdi
  4027e8:	e8 d3 58 00 00       	callq  4080c0 <rbtree_get>
    if (reservationPtr == NULL) {
  4027ed:	48 85 c0             	test   %rax,%rax
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  4027f0:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  4027f3:	74 3b                	je     402830 <manager_addRoom_seq+0x60>
        assert(reservationPtr != NULL);
        status = MAP_INSERT(tablePtr, id, reservationPtr);
        assert(status);
    } else {
        /* Update existing reservation */
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
  4027f5:	4c 89 ee             	mov    %r13,%rsi
  4027f8:	48 89 c7             	mov    %rax,%rdi
  4027fb:	e8 f0 0c 00 00       	callq  4034f0 <reservation_addToTotal_seq>
  402800:	48 85 c0             	test   %rax,%rax
  402803:	74 3b                	je     402840 <manager_addRoom_seq+0x70>
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
  402805:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  40280a:	75 44                	jne    402850 <manager_addRoom_seq+0x80>
            status = MAP_REMOVE(tablePtr, id);
  40280c:	48 89 ee             	mov    %rbp,%rsi
  40280f:	4c 89 e7             	mov    %r12,%rdi
  402812:	e8 69 53 00 00       	callq  407b80 <rbtree_delete>
            assert(status);
  402817:	48 85 c0             	test   %rax,%rax
  40281a:	0f 84 7f 00 00 00    	je     40289f <manager_addRoom_seq+0xcf>

bool_t
manager_addRoom_seq (manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation_seq(managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402820:	5b                   	pop    %rbx
  402821:	5d                   	pop    %rbp
  402822:	41 5c                	pop    %r12
  402824:	41 5d                	pop    %r13
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
  402826:	b8 01 00 00 00       	mov    $0x1,%eax

bool_t
manager_addRoom_seq (manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation_seq(managerPtr->roomTablePtr, roomId, numRoom, price);
}
  40282b:	41 5e                	pop    %r14
  40282d:	c3                   	retq   
  40282e:	66 90                	xchg   %ax,%ax
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402830:	4d 85 ed             	test   %r13,%r13
  402833:	7e 0b                	jle    402840 <manager_addRoom_seq+0x70>
  402835:	4c 89 f0             	mov    %r14,%rax
  402838:	48 c1 e8 3f          	shr    $0x3f,%rax
  40283c:	84 c0                	test   %al,%al
  40283e:	74 20                	je     402860 <manager_addRoom_seq+0x90>

bool_t
manager_addRoom_seq (manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation_seq(managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402840:	5b                   	pop    %rbx
  402841:	5d                   	pop    %rbp
  402842:	41 5c                	pop    %r12
  402844:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402846:	31 c0                	xor    %eax,%eax

bool_t
manager_addRoom_seq (manager_t* managerPtr, long roomId, long numRoom, long price)
{
    return addReservation_seq(managerPtr->roomTablePtr, roomId, numRoom, price);
}
  402848:	41 5e                	pop    %r14
  40284a:	c3                   	retq   
  40284b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
  402850:	4c 89 f6             	mov    %r14,%rsi
  402853:	48 89 df             	mov    %rbx,%rdi
  402856:	e8 b5 10 00 00       	callq  403910 <reservation_updatePrice_seq>
  40285b:	eb c3                	jmp    402820 <manager_addRoom_seq+0x50>
  40285d:	0f 1f 00             	nopl   (%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
  402860:	4c 89 f2             	mov    %r14,%rdx
  402863:	4c 89 ee             	mov    %r13,%rsi
  402866:	48 89 ef             	mov    %rbp,%rdi
  402869:	e8 62 0b 00 00       	callq  4033d0 <reservation_alloc_seq>
        assert(reservationPtr != NULL);
  40286e:	48 85 c0             	test   %rax,%rax
  402871:	74 45                	je     4028b8 <manager_addRoom_seq+0xe8>
        status = MAP_INSERT(tablePtr, id, reservationPtr);
  402873:	48 89 c2             	mov    %rax,%rdx
  402876:	48 89 ee             	mov    %rbp,%rsi
  402879:	4c 89 e7             	mov    %r12,%rdi
  40287c:	e8 df 50 00 00       	callq  407960 <rbtree_insert>
        assert(status);
  402881:	48 85 c0             	test   %rax,%rax
  402884:	75 9a                	jne    402820 <manager_addRoom_seq+0x50>
  402886:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  40288b:	ba e7 00 00 00       	mov    $0xe7,%edx
  402890:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402895:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  40289a:	e8 b1 e3 ff ff       	callq  400c50 <__assert_fail@plt>
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
  40289f:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  4028a4:	ba ef 00 00 00       	mov    $0xef,%edx
  4028a9:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4028ae:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  4028b3:	e8 98 e3 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
        assert(reservationPtr != NULL);
  4028b8:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  4028bd:	ba e5 00 00 00       	mov    $0xe5,%edx
  4028c2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  4028c7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  4028cc:	e8 7f e3 ff ff       	callq  400c50 <__assert_fail@plt>
  4028d1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4028d8:	0f 1f 84 00 00 00 00 
  4028df:	00 

00000000004028e0 <manager_deleteRoom>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
  4028e0:	41 55                	push   %r13
  4028e2:	49 89 d5             	mov    %rdx,%r13
  4028e5:	41 54                	push   %r12
  4028e7:	49 89 f4             	mov    %rsi,%r12
  4028ea:	55                   	push   %rbp
  4028eb:	53                   	push   %rbx
  4028ec:	48 83 ec 08          	sub    $0x8,%rsp
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
  4028f0:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4028f4:	48 89 ef             	mov    %rbp,%rdi
  4028f7:	e8 14 58 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  4028fc:	48 85 c0             	test   %rax,%rax
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4028ff:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  402902:	74 4c                	je     402950 <manager_deleteRoom+0x70>
 */
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
  402904:	4c 89 ee             	mov    %r13,%rsi
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  402907:	48 89 c7             	mov    %rax,%rdi
 */
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
  40290a:	48 f7 de             	neg    %rsi
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  40290d:	e8 3e 0b 00 00       	callq  403450 <reservation_addToTotal>
  402912:	48 85 c0             	test   %rax,%rax
  402915:	74 39                	je     402950 <manager_deleteRoom+0x70>
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
  402917:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  40291c:	75 42                	jne    402960 <manager_deleteRoom+0x80>
            bool_t status = TMMAP_REMOVE(tablePtr, id);
  40291e:	4c 89 e6             	mov    %r12,%rsi
  402921:	48 89 ef             	mov    %rbp,%rdi
  402924:	e8 d7 53 00 00       	callq  407d00 <TMrbtree_delete>
            if (status == FALSE) {
  402929:	48 85 c0             	test   %rax,%rax
  40292c:	74 51                	je     40297f <manager_deleteRoom+0x9f>
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
  40292e:	48 89 df             	mov    %rbx,%rdi
  402931:	e8 9a 10 00 00       	callq  4039d0 <reservation_free>
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
}
  402936:	48 83 c4 08          	add    $0x8,%rsp
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  40293a:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
}
  40293f:	5b                   	pop    %rbx
  402940:	5d                   	pop    %rbp
  402941:	41 5c                	pop    %r12
  402943:	41 5d                	pop    %r13
  402945:	c3                   	retq   
  402946:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40294d:	00 00 00 
  402950:	48 83 c4 08          	add    $0x8,%rsp

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402954:	31 c0                	xor    %eax,%eax
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
}
  402956:	5b                   	pop    %rbx
  402957:	5d                   	pop    %rbp
  402958:	41 5c                	pop    %r12
  40295a:	41 5d                	pop    %r13
  40295c:	c3                   	retq   
  40295d:	0f 1f 00             	nopl   (%rax)
            if (status == FALSE) {
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
  402960:	48 89 df             	mov    %rbx,%rdi
  402963:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  40296a:	e8 01 0f 00 00       	callq  403870 <reservation_updatePrice>
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
}
  40296f:	48 83 c4 08          	add    $0x8,%rsp
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402973:	b8 01 00 00 00       	mov    $0x1,%eax
bool_t
manager_deleteRoom (TM_ARGDECL  manager_t* managerPtr, long roomId, long numRoom)
{
    /* -1 keeps old price */
    return addReservation(TM_ARG  managerPtr->roomTablePtr, roomId, -numRoom, -1);
}
  402978:	5b                   	pop    %rbx
  402979:	5d                   	pop    %rbp
  40297a:	41 5c                	pop    %r12
  40297c:	41 5d                	pop    %r13
  40297e:	c3                   	retq   
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
            bool_t status = TMMAP_REMOVE(tablePtr, id);
            if (status == FALSE) {
                TM_RESTART();
  40297f:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  402984:	ba cc 00 00 00       	mov    $0xcc,%edx
  402989:	be 32 8c 40 00       	mov    $0x408c32,%esi
  40298e:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402993:	e8 b8 e2 ff ff       	callq  400c50 <__assert_fail@plt>
  402998:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40299f:	00 

00000000004029a0 <manager_addFlight>:
 * =============================================================================
 */
bool_t
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
  4029a0:	41 56                	push   %r14
  4029a2:	49 89 ce             	mov    %rcx,%r14
  4029a5:	41 55                	push   %r13
  4029a7:	49 89 d5             	mov    %rdx,%r13
  4029aa:	41 54                	push   %r12
  4029ac:	55                   	push   %rbp
  4029ad:	48 89 f5             	mov    %rsi,%rbp
  4029b0:	53                   	push   %rbx
    return addReservation(TM_ARG
  4029b1:	4c 8b 67 10          	mov    0x10(%rdi),%r12
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4029b5:	4c 89 e7             	mov    %r12,%rdi
  4029b8:	e8 53 57 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  4029bd:	48 85 c0             	test   %rax,%rax
bool_t
addReservation (TM_ARGDECL  MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  4029c0:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  4029c3:	74 4b                	je     402a10 <manager_addFlight+0x70>
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
        TMMAP_INSERT(tablePtr, id, reservationPtr);
    } else {
        /* Update existing reservation */
        if (!RESERVATION_ADD_TO_TOTAL(reservationPtr, num)) {
  4029c5:	4c 89 ee             	mov    %r13,%rsi
  4029c8:	48 89 c7             	mov    %rax,%rdi
  4029cb:	e8 80 0a 00 00       	callq  403450 <reservation_addToTotal>
  4029d0:	48 85 c0             	test   %rax,%rax
  4029d3:	74 4b                	je     402a20 <manager_addFlight+0x80>
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
  4029d5:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  4029da:	75 54                	jne    402a30 <manager_addFlight+0x90>
            bool_t status = TMMAP_REMOVE(tablePtr, id);
  4029dc:	48 89 ee             	mov    %rbp,%rsi
  4029df:	4c 89 e7             	mov    %r12,%rdi
  4029e2:	e8 19 53 00 00       	callq  407d00 <TMrbtree_delete>
            if (status == FALSE) {
  4029e7:	48 85 c0             	test   %rax,%rax
  4029ea:	0f 84 8f 00 00 00    	je     402a7f <manager_addFlight+0xdf>
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
  4029f0:	48 89 df             	mov    %rbx,%rdi
  4029f3:	e8 d8 0f 00 00       	callq  4039d0 <reservation_free>
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  4029f8:	5b                   	pop    %rbx
  4029f9:	5d                   	pop    %rbp
  4029fa:	41 5c                	pop    %r12
  4029fc:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  4029fe:	b8 01 00 00 00       	mov    $0x1,%eax
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a03:	41 5e                	pop    %r14
  402a05:	c3                   	retq   
  402a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402a0d:	00 00 00 
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402a10:	4d 85 ed             	test   %r13,%r13
  402a13:	7e 0b                	jle    402a20 <manager_addFlight+0x80>
  402a15:	4c 89 f0             	mov    %r14,%rax
  402a18:	48 c1 e8 3f          	shr    $0x3f,%rax
  402a1c:	84 c0                	test   %al,%al
  402a1e:	74 30                	je     402a50 <manager_addFlight+0xb0>
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a20:	5b                   	pop    %rbx
  402a21:	5d                   	pop    %rbp
  402a22:	41 5c                	pop    %r12
  402a24:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402a26:	31 c0                	xor    %eax,%eax
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a28:	41 5e                	pop    %r14
  402a2a:	c3                   	retq   
  402a2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            if (status == FALSE) {
                TM_RESTART();
            }
            RESERVATION_FREE(reservationPtr);
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
  402a30:	4c 89 f6             	mov    %r14,%rsi
  402a33:	48 89 df             	mov    %rbx,%rdi
  402a36:	e8 35 0e 00 00       	callq  403870 <reservation_updatePrice>
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a3b:	5b                   	pop    %rbx
  402a3c:	5d                   	pop    %rbp
  402a3d:	41 5c                	pop    %r12
  402a3f:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402a41:	b8 01 00 00 00       	mov    $0x1,%eax
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a46:	41 5e                	pop    %r14
  402a48:	c3                   	retq   
  402a49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
  402a50:	4c 89 f2             	mov    %r14,%rdx
  402a53:	4c 89 ee             	mov    %r13,%rsi
  402a56:	48 89 ef             	mov    %rbp,%rdi
  402a59:	e8 f2 08 00 00       	callq  403350 <reservation_alloc>
        assert(reservationPtr != NULL);
  402a5e:	48 85 c0             	test   %rax,%rax
  402a61:	74 35                	je     402a98 <manager_addFlight+0xf8>
        TMMAP_INSERT(tablePtr, id, reservationPtr);
  402a63:	48 89 ee             	mov    %rbp,%rsi
  402a66:	4c 89 e7             	mov    %r12,%rdi
  402a69:	48 89 c2             	mov    %rax,%rdx
  402a6c:	e8 ff 4f 00 00       	callq  407a70 <TMrbtree_insert>
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a71:	5b                   	pop    %rbx
  402a72:	5d                   	pop    %rbp
  402a73:	41 5c                	pop    %r12
  402a75:	41 5d                	pop    %r13
        } else {
            RESERVATION_UPDATE_PRICE(reservationPtr, price);
        }
    }

    return TRUE;
  402a77:	b8 01 00 00 00       	mov    $0x1,%eax
manager_addFlight (TM_ARGDECL
                   manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402a7c:	41 5e                	pop    %r14
  402a7e:	c3                   	retq   
            return FALSE;
        }
        if ((long)TM_SHARED_READ(reservationPtr->numTotal) == 0) {
            bool_t status = TMMAP_REMOVE(tablePtr, id);
            if (status == FALSE) {
                TM_RESTART();
  402a7f:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  402a84:	ba cc 00 00 00       	mov    $0xcc,%edx
  402a89:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402a8e:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402a93:	e8 b8 e1 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = RESERVATION_ALLOC(id, num, price);
        assert(reservationPtr != NULL);
  402a98:	b9 b3 8d 40 00       	mov    $0x408db3,%ecx
  402a9d:	ba c2 00 00 00       	mov    $0xc2,%edx
  402aa2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402aa7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  402aac:	e8 9f e1 ff ff       	callq  400c50 <__assert_fail@plt>
  402ab1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402ab8:	0f 1f 84 00 00 00 00 
  402abf:	00 

0000000000402ac0 <manager_addFlight_seq>:
}


bool_t
manager_addFlight_seq (manager_t* managerPtr, long flightId, long numSeat, long price)
{
  402ac0:	41 56                	push   %r14
  402ac2:	49 89 ce             	mov    %rcx,%r14
  402ac5:	41 55                	push   %r13
  402ac7:	49 89 d5             	mov    %rdx,%r13
  402aca:	41 54                	push   %r12
  402acc:	55                   	push   %rbp
  402acd:	48 89 f5             	mov    %rsi,%rbp
  402ad0:	53                   	push   %rbx
    return addReservation_seq(managerPtr->flightTablePtr, flightId, numSeat, price);
  402ad1:	4c 8b 67 10          	mov    0x10(%rdi),%r12
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  402ad5:	4c 89 e7             	mov    %r12,%rdi
  402ad8:	e8 e3 55 00 00       	callq  4080c0 <rbtree_get>
    if (reservationPtr == NULL) {
  402add:	48 85 c0             	test   %rax,%rax
addReservation_seq (MAP_T* tablePtr, long id, long num, long price)
{
    reservation_t* reservationPtr;
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
  402ae0:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  402ae3:	74 3b                	je     402b20 <manager_addFlight_seq+0x60>
        assert(reservationPtr != NULL);
        status = MAP_INSERT(tablePtr, id, reservationPtr);
        assert(status);
    } else {
        /* Update existing reservation */
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
  402ae5:	4c 89 ee             	mov    %r13,%rsi
  402ae8:	48 89 c7             	mov    %rax,%rdi
  402aeb:	e8 00 0a 00 00       	callq  4034f0 <reservation_addToTotal_seq>
  402af0:	48 85 c0             	test   %rax,%rax
  402af3:	74 3b                	je     402b30 <manager_addFlight_seq+0x70>
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
  402af5:	48 83 7b 18 00       	cmpq   $0x0,0x18(%rbx)
  402afa:	75 44                	jne    402b40 <manager_addFlight_seq+0x80>
            status = MAP_REMOVE(tablePtr, id);
  402afc:	48 89 ee             	mov    %rbp,%rsi
  402aff:	4c 89 e7             	mov    %r12,%rdi
  402b02:	e8 79 50 00 00       	callq  407b80 <rbtree_delete>
            assert(status);
  402b07:	48 85 c0             	test   %rax,%rax
  402b0a:	0f 84 7f 00 00 00    	je     402b8f <manager_addFlight_seq+0xcf>

bool_t
manager_addFlight_seq (manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation_seq(managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402b10:	5b                   	pop    %rbx
  402b11:	5d                   	pop    %rbp
  402b12:	41 5c                	pop    %r12
  402b14:	41 5d                	pop    %r13
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
        }
    }

    return TRUE;
  402b16:	b8 01 00 00 00       	mov    $0x1,%eax

bool_t
manager_addFlight_seq (manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation_seq(managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402b1b:	41 5e                	pop    %r14
  402b1d:	c3                   	retq   
  402b1e:	66 90                	xchg   %ax,%ax
    bool_t status;

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
  402b20:	4d 85 ed             	test   %r13,%r13
  402b23:	7e 0b                	jle    402b30 <manager_addFlight_seq+0x70>
  402b25:	4c 89 f0             	mov    %r14,%rax
  402b28:	48 c1 e8 3f          	shr    $0x3f,%rax
  402b2c:	84 c0                	test   %al,%al
  402b2e:	74 20                	je     402b50 <manager_addFlight_seq+0x90>

bool_t
manager_addFlight_seq (manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation_seq(managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402b30:	5b                   	pop    %rbx
  402b31:	5d                   	pop    %rbp
  402b32:	41 5c                	pop    %r12
  402b34:	41 5d                	pop    %r13

    reservationPtr = (reservation_t*)MAP_FIND(tablePtr, id);
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
  402b36:	31 c0                	xor    %eax,%eax

bool_t
manager_addFlight_seq (manager_t* managerPtr, long flightId, long numSeat, long price)
{
    return addReservation_seq(managerPtr->flightTablePtr, flightId, numSeat, price);
}
  402b38:	41 5e                	pop    %r14
  402b3a:	c3                   	retq   
  402b3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
        } else {
            reservation_updatePrice_seq(reservationPtr, price);
  402b40:	4c 89 f6             	mov    %r14,%rsi
  402b43:	48 89 df             	mov    %rbx,%rdi
  402b46:	e8 c5 0d 00 00       	callq  403910 <reservation_updatePrice_seq>
  402b4b:	eb c3                	jmp    402b10 <manager_addFlight_seq+0x50>
  402b4d:	0f 1f 00             	nopl   (%rax)
    if (reservationPtr == NULL) {
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
  402b50:	4c 89 f2             	mov    %r14,%rdx
  402b53:	4c 89 ee             	mov    %r13,%rsi
  402b56:	48 89 ef             	mov    %rbp,%rdi
  402b59:	e8 72 08 00 00       	callq  4033d0 <reservation_alloc_seq>
        assert(reservationPtr != NULL);
  402b5e:	48 85 c0             	test   %rax,%rax
  402b61:	74 45                	je     402ba8 <manager_addFlight_seq+0xe8>
        status = MAP_INSERT(tablePtr, id, reservationPtr);
  402b63:	48 89 c2             	mov    %rax,%rdx
  402b66:	48 89 ee             	mov    %rbp,%rsi
  402b69:	4c 89 e7             	mov    %r12,%rdi
  402b6c:	e8 ef 4d 00 00       	callq  407960 <rbtree_insert>
        assert(status);
  402b71:	48 85 c0             	test   %rax,%rax
  402b74:	75 9a                	jne    402b10 <manager_addFlight_seq+0x50>
  402b76:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  402b7b:	ba e7 00 00 00       	mov    $0xe7,%edx
  402b80:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402b85:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  402b8a:	e8 c1 e0 ff ff       	callq  400c50 <__assert_fail@plt>
        if (!reservation_addToTotal_seq(reservationPtr, num)) {
            return FALSE;
        }
        if (reservationPtr->numTotal == 0) {
            status = MAP_REMOVE(tablePtr, id);
            assert(status);
  402b8f:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  402b94:	ba ef 00 00 00       	mov    $0xef,%edx
  402b99:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402b9e:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  402ba3:	e8 a8 e0 ff ff       	callq  400c50 <__assert_fail@plt>
        /* Create new reservation */
        if (num < 1 || price < 0) {
            return FALSE;
        }
        reservationPtr = reservation_alloc_seq(id, num, price);
        assert(reservationPtr != NULL);
  402ba8:	b9 a0 8d 40 00       	mov    $0x408da0,%ecx
  402bad:	ba e5 00 00 00       	mov    $0xe5,%edx
  402bb2:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402bb7:	bf 56 8c 40 00       	mov    $0x408c56,%edi
  402bbc:	e8 8f e0 ff ff       	callq  400c50 <__assert_fail@plt>
  402bc1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402bc8:	0f 1f 84 00 00 00 00 
  402bcf:	00 

0000000000402bd0 <manager_deleteFlight>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_deleteFlight (TM_ARGDECL  manager_t* managerPtr, long flightId)
{
  402bd0:	55                   	push   %rbp
  402bd1:	48 89 fd             	mov    %rdi,%rbp
  402bd4:	53                   	push   %rbx
  402bd5:	48 89 f3             	mov    %rsi,%rbx
  402bd8:	48 83 ec 08          	sub    $0x8,%rsp
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(managerPtr->flightTablePtr, flightId);
  402bdc:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  402be0:	e8 2b 55 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  402be5:	48 85 c0             	test   %rax,%rax
  402be8:	74 07                	je     402bf1 <manager_deleteFlight+0x21>
        return FALSE;
    }

    if ((long)TM_SHARED_READ(reservationPtr->numUsed) > 0) {
  402bea:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
  402bef:	7e 0f                	jle    402c00 <manager_deleteFlight+0x30>
    return addReservation(TM_ARG
                          managerPtr->flightTablePtr,
                          flightId,
                          -1*(long)TM_SHARED_READ(reservationPtr->numTotal),
                          -1 /* -1 keeps old price */);
}
  402bf1:	48 83 c4 08          	add    $0x8,%rsp
  402bf5:	31 c0                	xor    %eax,%eax
  402bf7:	5b                   	pop    %rbx
  402bf8:	5d                   	pop    %rbp
  402bf9:	c3                   	retq   
  402bfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    if ((long)TM_SHARED_READ(reservationPtr->numUsed) > 0) {
        return FALSE; /* somebody has a reservation */
    }

    return addReservation(TM_ARG
  402c00:	48 8b 50 18          	mov    0x18(%rax),%rdx
  402c04:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
                          managerPtr->flightTablePtr,
                          flightId,
                          -1*(long)TM_SHARED_READ(reservationPtr->numTotal),
                          -1 /* -1 keeps old price */);
}
  402c08:	48 83 c4 08          	add    $0x8,%rsp

    if ((long)TM_SHARED_READ(reservationPtr->numUsed) > 0) {
        return FALSE; /* somebody has a reservation */
    }

    return addReservation(TM_ARG
  402c0c:	48 89 de             	mov    %rbx,%rsi
  402c0f:	48 c7 c1 ff ff ff ff 	mov    $0xffffffffffffffff,%rcx
                          managerPtr->flightTablePtr,
                          flightId,
                          -1*(long)TM_SHARED_READ(reservationPtr->numTotal),
                          -1 /* -1 keeps old price */);
}
  402c16:	5b                   	pop    %rbx
  402c17:	5d                   	pop    %rbp

    if ((long)TM_SHARED_READ(reservationPtr->numUsed) > 0) {
        return FALSE; /* somebody has a reservation */
    }

    return addReservation(TM_ARG
  402c18:	48 f7 da             	neg    %rdx
  402c1b:	e9 80 f5 ff ff       	jmpq   4021a0 <addReservation>

0000000000402c20 <manager_addCustomer>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_addCustomer (TM_ARGDECL  manager_t* managerPtr, long customerId)
{
  402c20:	55                   	push   %rbp
  402c21:	48 89 fd             	mov    %rdi,%rbp
  402c24:	53                   	push   %rbx
  402c25:	48 89 f3             	mov    %rsi,%rbx
  402c28:	48 83 ec 08          	sub    $0x8,%rsp
    customer_t* customerPtr;
    bool_t status;

    if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
  402c2c:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  402c30:	e8 7b 55 00 00       	callq  4081b0 <TMrbtree_contains>
        return FALSE;
  402c35:	31 d2                	xor    %edx,%edx
manager_addCustomer (TM_ARGDECL  manager_t* managerPtr, long customerId)
{
    customer_t* customerPtr;
    bool_t status;

    if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
  402c37:	48 85 c0             	test   %rax,%rax
  402c3a:	74 14                	je     402c50 <manager_addCustomer+0x30>
    if (status == FALSE) {
        TM_RESTART();
    }

    return TRUE;
}
  402c3c:	48 83 c4 08          	add    $0x8,%rsp
  402c40:	48 89 d0             	mov    %rdx,%rax
  402c43:	5b                   	pop    %rbx
  402c44:	5d                   	pop    %rbp
  402c45:	c3                   	retq   
  402c46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402c4d:	00 00 00 

    if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
        return FALSE;
    }

    customerPtr = CUSTOMER_ALLOC(customerId);
  402c50:	48 89 df             	mov    %rbx,%rdi
  402c53:	e8 18 f2 ff ff       	callq  401e70 <customer_alloc>
    assert(customerPtr != NULL);
  402c58:	48 85 c0             	test   %rax,%rax
  402c5b:	74 23                	je     402c80 <manager_addCustomer+0x60>
    status = TMMAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
  402c5d:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  402c61:	48 89 c2             	mov    %rax,%rdx
  402c64:	48 89 de             	mov    %rbx,%rsi
  402c67:	e8 04 4e 00 00       	callq  407a70 <TMrbtree_insert>
    if (status == FALSE) {
  402c6c:	48 85 c0             	test   %rax,%rax
  402c6f:	74 28                	je     402c99 <manager_addCustomer+0x79>
        TM_RESTART();
    }

    return TRUE;
}
  402c71:	48 83 c4 08          	add    $0x8,%rsp
    status = TMMAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
    if (status == FALSE) {
        TM_RESTART();
    }

    return TRUE;
  402c75:	ba 01 00 00 00       	mov    $0x1,%edx
}
  402c7a:	5b                   	pop    %rbx
  402c7b:	48 89 d0             	mov    %rdx,%rax
  402c7e:	5d                   	pop    %rbp
  402c7f:	c3                   	retq   
    if (TMMAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
        return FALSE;
    }

    customerPtr = CUSTOMER_ALLOC(customerId);
    assert(customerPtr != NULL);
  402c80:	b9 80 8d 40 00       	mov    $0x408d80,%ecx
  402c85:	ba 8d 01 00 00       	mov    $0x18d,%edx
  402c8a:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402c8f:	bf 53 8b 40 00       	mov    $0x408b53,%edi
  402c94:	e8 b7 df ff ff       	callq  400c50 <__assert_fail@plt>
    status = TMMAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
    if (status == FALSE) {
        TM_RESTART();
  402c99:	b9 80 8d 40 00       	mov    $0x408d80,%ecx
  402c9e:	ba 90 01 00 00       	mov    $0x190,%edx
  402ca3:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402ca8:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402cad:	e8 9e df ff ff       	callq  400c50 <__assert_fail@plt>
  402cb2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402cb9:	1f 84 00 00 00 00 00 

0000000000402cc0 <manager_addCustomer_seq>:
}


bool_t
manager_addCustomer_seq (manager_t* managerPtr, long customerId)
{
  402cc0:	55                   	push   %rbp
  402cc1:	48 89 fd             	mov    %rdi,%rbp
  402cc4:	53                   	push   %rbx
  402cc5:	48 89 f3             	mov    %rsi,%rbx
  402cc8:	48 83 ec 08          	sub    $0x8,%rsp
    customer_t* customerPtr;
    bool_t status;

    if (MAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
  402ccc:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  402cd0:	e8 8b 54 00 00       	callq  408160 <rbtree_contains>
        return FALSE;
  402cd5:	31 d2                	xor    %edx,%edx
manager_addCustomer_seq (manager_t* managerPtr, long customerId)
{
    customer_t* customerPtr;
    bool_t status;

    if (MAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
  402cd7:	48 85 c0             	test   %rax,%rax
  402cda:	74 14                	je     402cf0 <manager_addCustomer_seq+0x30>
    assert(customerPtr != NULL);
    status = MAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
    assert(status);

    return TRUE;
}
  402cdc:	48 83 c4 08          	add    $0x8,%rsp
  402ce0:	48 89 d0             	mov    %rdx,%rax
  402ce3:	5b                   	pop    %rbx
  402ce4:	5d                   	pop    %rbp
  402ce5:	c3                   	retq   
  402ce6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  402ced:	00 00 00 

    if (MAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
        return FALSE;
    }

    customerPtr = customer_alloc_seq(customerId);
  402cf0:	48 89 df             	mov    %rbx,%rdi
  402cf3:	e8 e8 f1 ff ff       	callq  401ee0 <customer_alloc_seq>
    assert(customerPtr != NULL);
  402cf8:	48 85 c0             	test   %rax,%rax
  402cfb:	74 23                	je     402d20 <manager_addCustomer_seq+0x60>
    status = MAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
  402cfd:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  402d01:	48 89 c2             	mov    %rax,%rdx
  402d04:	48 89 de             	mov    %rbx,%rsi
  402d07:	e8 54 4c 00 00       	callq  407960 <rbtree_insert>
    assert(status);
  402d0c:	48 85 c0             	test   %rax,%rax
  402d0f:	74 28                	je     402d39 <manager_addCustomer_seq+0x79>

    return TRUE;
}
  402d11:	48 83 c4 08          	add    $0x8,%rsp
    customerPtr = customer_alloc_seq(customerId);
    assert(customerPtr != NULL);
    status = MAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
    assert(status);

    return TRUE;
  402d15:	ba 01 00 00 00       	mov    $0x1,%edx
}
  402d1a:	5b                   	pop    %rbx
  402d1b:	48 89 d0             	mov    %rdx,%rax
  402d1e:	5d                   	pop    %rbp
  402d1f:	c3                   	retq   
    if (MAP_CONTAINS(managerPtr->customerTablePtr, customerId)) {
        return FALSE;
    }

    customerPtr = customer_alloc_seq(customerId);
    assert(customerPtr != NULL);
  402d20:	b9 60 8d 40 00       	mov    $0x408d60,%ecx
  402d25:	ba a2 01 00 00       	mov    $0x1a2,%edx
  402d2a:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402d2f:	bf 53 8b 40 00       	mov    $0x408b53,%edi
  402d34:	e8 17 df ff ff       	callq  400c50 <__assert_fail@plt>
    status = MAP_INSERT(managerPtr->customerTablePtr, customerId, customerPtr);
    assert(status);
  402d39:	b9 60 8d 40 00       	mov    $0x408d60,%ecx
  402d3e:	ba a4 01 00 00       	mov    $0x1a4,%edx
  402d43:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402d48:	bf 74 8c 40 00       	mov    $0x408c74,%edi
  402d4d:	e8 fe de ff ff       	callq  400c50 <__assert_fail@plt>
  402d52:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402d59:	1f 84 00 00 00 00 00 

0000000000402d60 <manager_deleteCustomer>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_deleteCustomer (TM_ARGDECL  manager_t* managerPtr, long customerId)
{
  402d60:	41 56                	push   %r14
  402d62:	49 89 f6             	mov    %rsi,%r14
  402d65:	41 55                	push   %r13
  402d67:	41 54                	push   %r12
  402d69:	49 89 fc             	mov    %rdi,%r12
  402d6c:	55                   	push   %rbp
  402d6d:	53                   	push   %rbx
  402d6e:	48 83 ec 30          	sub    $0x30,%rsp
    MAP_T* reservationTables[NUM_RESERVATION_TYPE];
    list_t* reservationInfoListPtr;
    list_iter_t it;
    bool_t status;

    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
  402d72:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  402d76:	e8 95 53 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  402d7b:	48 85 c0             	test   %rax,%rax
    MAP_T* reservationTables[NUM_RESERVATION_TYPE];
    list_t* reservationInfoListPtr;
    list_iter_t it;
    bool_t status;

    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
  402d7e:	49 89 c5             	mov    %rax,%r13
    if (customerPtr == NULL) {
  402d81:	0f 84 b1 00 00 00    	je     402e38 <manager_deleteCustomer+0xd8>
        return FALSE;
    }

    reservationTables[RESERVATION_CAR] = managerPtr->carTablePtr;
  402d87:	49 8b 04 24          	mov    (%r12),%rax
    reservationTables[RESERVATION_ROOM] = managerPtr->roomTablePtr;
    reservationTables[RESERVATION_FLIGHT] = managerPtr->flightTablePtr;

    /* Cancel this customer's reservations */
    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
  402d8b:	49 8b 6d 08          	mov    0x8(%r13),%rbp
    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
  402d8f:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationTables[RESERVATION_CAR] = managerPtr->carTablePtr;
  402d94:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
    reservationTables[RESERVATION_ROOM] = managerPtr->roomTablePtr;
  402d99:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    reservationTables[RESERVATION_FLIGHT] = managerPtr->flightTablePtr;

    /* Cancel this customer's reservations */
    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
  402d9e:	48 89 ee             	mov    %rbp,%rsi
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationTables[RESERVATION_CAR] = managerPtr->carTablePtr;
    reservationTables[RESERVATION_ROOM] = managerPtr->roomTablePtr;
  402da1:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
    reservationTables[RESERVATION_FLIGHT] = managerPtr->flightTablePtr;
  402da6:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  402dab:	48 89 44 24 18       	mov    %rax,0x18(%rsp)

    /* Cancel this customer's reservations */
    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
  402db0:	e8 6b 11 00 00       	callq  403f20 <TMlist_iter_reset>
    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
  402db5:	eb 43                	jmp    402dfa <manager_deleteCustomer+0x9a>
  402db7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  402dbe:	00 00 
        reservation_info_t* reservationInfoPtr;
        reservation_t* reservationPtr;
        reservationInfoPtr =
  402dc0:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  402dc5:	48 89 ee             	mov    %rbp,%rsi
  402dc8:	e8 93 11 00 00       	callq  403f60 <TMlist_iter_next>
            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
        reservationPtr =
  402dcd:	48 8b 70 08          	mov    0x8(%rax),%rsi
    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
        reservation_info_t* reservationInfoPtr;
        reservation_t* reservationPtr;
        reservationInfoPtr =
  402dd1:	48 89 c3             	mov    %rax,%rbx
            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
        reservationPtr =
            (reservation_t*)TMMAP_FIND(reservationTables[reservationInfoPtr->type],
  402dd4:	8b 00                	mov    (%rax),%eax
    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
        reservation_info_t* reservationInfoPtr;
        reservation_t* reservationPtr;
        reservationInfoPtr =
            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
        reservationPtr =
  402dd6:	48 8b 7c c4 10       	mov    0x10(%rsp,%rax,8),%rdi
  402ddb:	e8 30 53 00 00       	callq  408110 <TMrbtree_get>
            (reservation_t*)TMMAP_FIND(reservationTables[reservationInfoPtr->type],
                                     reservationInfoPtr->id);
        if (reservationPtr == NULL) {
  402de0:	48 85 c0             	test   %rax,%rax
  402de3:	74 7b                	je     402e60 <manager_deleteCustomer+0x100>
            TM_RESTART();
        }
        status = RESERVATION_CANCEL(reservationPtr);
  402de5:	48 89 c7             	mov    %rax,%rdi
  402de8:	e8 03 09 00 00       	callq  4036f0 <reservation_cancel>
        if (status == FALSE) {
  402ded:	48 85 c0             	test   %rax,%rax
  402df0:	74 55                	je     402e47 <manager_deleteCustomer+0xe7>
            TM_RESTART();
        }
        RESERVATION_INFO_FREE(reservationInfoPtr);
  402df2:	48 89 df             	mov    %rbx,%rdi
  402df5:	e8 26 05 00 00       	callq  403320 <reservation_info_free>
    reservationTables[RESERVATION_FLIGHT] = managerPtr->flightTablePtr;

    /* Cancel this customer's reservations */
    reservationInfoListPtr = customerPtr->reservationInfoListPtr;
    TMLIST_ITER_RESET(&it, reservationInfoListPtr);
    while (TMLIST_ITER_HASNEXT(&it, reservationInfoListPtr)) {
  402dfa:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi
  402dff:	48 89 ee             	mov    %rbp,%rsi
  402e02:	e8 39 11 00 00       	callq  403f40 <TMlist_iter_hasNext>
  402e07:	48 85 c0             	test   %rax,%rax
  402e0a:	75 b4                	jne    402dc0 <manager_deleteCustomer+0x60>
            TM_RESTART();
        }
        RESERVATION_INFO_FREE(reservationInfoPtr);
    }

    status = TMMAP_REMOVE(managerPtr->customerTablePtr, customerId);
  402e0c:	49 8b 7c 24 18       	mov    0x18(%r12),%rdi
  402e11:	4c 89 f6             	mov    %r14,%rsi
  402e14:	e8 e7 4e 00 00       	callq  407d00 <TMrbtree_delete>
    if (status == FALSE) {
  402e19:	48 85 c0             	test   %rax,%rax
  402e1c:	74 5b                	je     402e79 <manager_deleteCustomer+0x119>
        TM_RESTART();
    }
    CUSTOMER_FREE(customerPtr);
  402e1e:	4c 89 ef             	mov    %r13,%rdi
  402e21:	e8 3a f1 ff ff       	callq  401f60 <customer_free>

    return TRUE;
}
  402e26:	48 83 c4 30          	add    $0x30,%rsp
    if (status == FALSE) {
        TM_RESTART();
    }
    CUSTOMER_FREE(customerPtr);

    return TRUE;
  402e2a:	b8 01 00 00 00       	mov    $0x1,%eax
}
  402e2f:	5b                   	pop    %rbx
  402e30:	5d                   	pop    %rbp
  402e31:	41 5c                	pop    %r12
  402e33:	41 5d                	pop    %r13
  402e35:	41 5e                	pop    %r14
  402e37:	c3                   	retq   
  402e38:	48 83 c4 30          	add    $0x30,%rsp
    list_iter_t it;
    bool_t status;

    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  402e3c:	31 c0                	xor    %eax,%eax
        TM_RESTART();
    }
    CUSTOMER_FREE(customerPtr);

    return TRUE;
}
  402e3e:	5b                   	pop    %rbx
  402e3f:	5d                   	pop    %rbp
  402e40:	41 5c                	pop    %r12
  402e42:	41 5d                	pop    %r13
  402e44:	41 5e                	pop    %r14
  402e46:	c3                   	retq   
        if (reservationPtr == NULL) {
            TM_RESTART();
        }
        status = RESERVATION_CANCEL(reservationPtr);
        if (status == FALSE) {
            TM_RESTART();
  402e47:	b9 40 8d 40 00       	mov    $0x408d40,%ecx
  402e4c:	ba d3 01 00 00       	mov    $0x1d3,%edx
  402e51:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402e56:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402e5b:	e8 f0 dd ff ff       	callq  400c50 <__assert_fail@plt>
            (reservation_info_t*)TMLIST_ITER_NEXT(&it, reservationInfoListPtr);
        reservationPtr =
            (reservation_t*)TMMAP_FIND(reservationTables[reservationInfoPtr->type],
                                     reservationInfoPtr->id);
        if (reservationPtr == NULL) {
            TM_RESTART();
  402e60:	b9 40 8d 40 00       	mov    $0x408d40,%ecx
  402e65:	ba cf 01 00 00       	mov    $0x1cf,%edx
  402e6a:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402e6f:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402e74:	e8 d7 dd ff ff       	callq  400c50 <__assert_fail@plt>
        RESERVATION_INFO_FREE(reservationInfoPtr);
    }

    status = TMMAP_REMOVE(managerPtr->customerTablePtr, customerId);
    if (status == FALSE) {
        TM_RESTART();
  402e79:	b9 40 8d 40 00       	mov    $0x408d40,%ecx
  402e7e:	ba da 01 00 00       	mov    $0x1da,%edx
  402e83:	be 32 8c 40 00       	mov    $0x408c32,%esi
  402e88:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  402e8d:	e8 be dd ff ff       	callq  400c50 <__assert_fail@plt>
  402e92:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402e99:	1f 84 00 00 00 00 00 

0000000000402ea0 <manager_queryCar>:
 * -- Returns -1 if the car does not exist
 * =============================================================================
 */
long
manager_queryCar (TM_ARGDECL  manager_t* managerPtr, long carId)
{
  402ea0:	48 83 ec 08          	sub    $0x8,%rsp
queryNumFree (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long numFree = -1;
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402ea4:	48 8b 3f             	mov    (%rdi),%rdi
  402ea7:	e8 64 52 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr != NULL) {
  402eac:	48 85 c0             	test   %rax,%rax
  402eaf:	74 09                	je     402eba <manager_queryCar+0x1a>
        numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
  402eb1:	48 8b 40 10          	mov    0x10(%rax),%rax
 */
long
manager_queryCar (TM_ARGDECL  manager_t* managerPtr, long carId)
{
    return queryNumFree(TM_ARG  managerPtr->carTablePtr, carId);
}
  402eb5:	48 83 c4 08          	add    $0x8,%rsp
  402eb9:	c3                   	retq   
 * =============================================================================
 */
static long
queryNumFree (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long numFree = -1;
  402eba:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402ec1:	eb f2                	jmp    402eb5 <manager_queryCar+0x15>
  402ec3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402eca:	84 00 00 00 00 00 

0000000000402ed0 <manager_queryCarPrice>:
 * -- Returns -1 if the car does not exist
 * =============================================================================
 */
long
manager_queryCarPrice (TM_ARGDECL  manager_t* managerPtr, long carId)
{
  402ed0:	48 83 ec 08          	sub    $0x8,%rsp
queryPrice (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long price = -1;
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402ed4:	48 8b 3f             	mov    (%rdi),%rdi
  402ed7:	e8 34 52 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr != NULL) {
  402edc:	48 85 c0             	test   %rax,%rax
  402edf:	74 09                	je     402eea <manager_queryCarPrice+0x1a>
        price = (long)TM_SHARED_READ(reservationPtr->price);
  402ee1:	48 8b 40 20          	mov    0x20(%rax),%rax
 */
long
manager_queryCarPrice (TM_ARGDECL  manager_t* managerPtr, long carId)
{
    return queryPrice(TM_ARG  managerPtr->carTablePtr, carId);
}
  402ee5:	48 83 c4 08          	add    $0x8,%rsp
  402ee9:	c3                   	retq   
 * =============================================================================
 */
static long
queryPrice (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long price = -1;
  402eea:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402ef1:	eb f2                	jmp    402ee5 <manager_queryCarPrice+0x15>
  402ef3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402efa:	84 00 00 00 00 00 

0000000000402f00 <manager_queryRoom>:
 * -- Returns -1 if the room does not exist
 * =============================================================================
 */
long
manager_queryRoom (TM_ARGDECL  manager_t* managerPtr, long roomId)
{
  402f00:	48 83 ec 08          	sub    $0x8,%rsp
queryNumFree (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long numFree = -1;
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402f04:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  402f08:	e8 03 52 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr != NULL) {
  402f0d:	48 85 c0             	test   %rax,%rax
  402f10:	74 09                	je     402f1b <manager_queryRoom+0x1b>
        numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
  402f12:	48 8b 40 10          	mov    0x10(%rax),%rax
 */
long
manager_queryRoom (TM_ARGDECL  manager_t* managerPtr, long roomId)
{
    return queryNumFree(TM_ARG  managerPtr->roomTablePtr, roomId);
}
  402f16:	48 83 c4 08          	add    $0x8,%rsp
  402f1a:	c3                   	retq   
 * =============================================================================
 */
static long
queryNumFree (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long numFree = -1;
  402f1b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402f22:	eb f2                	jmp    402f16 <manager_queryRoom+0x16>
  402f24:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402f2b:	00 00 00 00 00 

0000000000402f30 <manager_queryRoomPrice>:
 * -- Returns -1 if the room does not exist
 * =============================================================================
 */
long
manager_queryRoomPrice (TM_ARGDECL  manager_t* managerPtr, long roomId)
{
  402f30:	48 83 ec 08          	sub    $0x8,%rsp
queryPrice (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long price = -1;
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402f34:	48 8b 7f 08          	mov    0x8(%rdi),%rdi
  402f38:	e8 d3 51 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr != NULL) {
  402f3d:	48 85 c0             	test   %rax,%rax
  402f40:	74 09                	je     402f4b <manager_queryRoomPrice+0x1b>
        price = (long)TM_SHARED_READ(reservationPtr->price);
  402f42:	48 8b 40 20          	mov    0x20(%rax),%rax
 */
long
manager_queryRoomPrice (TM_ARGDECL  manager_t* managerPtr, long roomId)
{
    return queryPrice(TM_ARG  managerPtr->roomTablePtr, roomId);
}
  402f46:	48 83 c4 08          	add    $0x8,%rsp
  402f4a:	c3                   	retq   
 * =============================================================================
 */
static long
queryPrice (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long price = -1;
  402f4b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402f52:	eb f2                	jmp    402f46 <manager_queryRoomPrice+0x16>
  402f54:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402f5b:	00 00 00 00 00 

0000000000402f60 <manager_queryFlight>:
 * -- Returns -1 if the flight does not exist
 * =============================================================================
 */
long
manager_queryFlight (TM_ARGDECL  manager_t* managerPtr, long flightId)
{
  402f60:	48 83 ec 08          	sub    $0x8,%rsp
queryNumFree (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long numFree = -1;
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402f64:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  402f68:	e8 a3 51 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr != NULL) {
  402f6d:	48 85 c0             	test   %rax,%rax
  402f70:	74 09                	je     402f7b <manager_queryFlight+0x1b>
        numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
  402f72:	48 8b 40 10          	mov    0x10(%rax),%rax
 */
long
manager_queryFlight (TM_ARGDECL  manager_t* managerPtr, long flightId)
{
    return queryNumFree(TM_ARG  managerPtr->flightTablePtr, flightId);
}
  402f76:	48 83 c4 08          	add    $0x8,%rsp
  402f7a:	c3                   	retq   
 * =============================================================================
 */
static long
queryNumFree (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long numFree = -1;
  402f7b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402f82:	eb f2                	jmp    402f76 <manager_queryFlight+0x16>
  402f84:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402f8b:	00 00 00 00 00 

0000000000402f90 <manager_queryFlightPrice>:
 * -- Returns -1 if the flight does not exist
 * =============================================================================
 */
long
manager_queryFlightPrice (TM_ARGDECL  manager_t* managerPtr, long flightId)
{
  402f90:	48 83 ec 08          	sub    $0x8,%rsp
queryPrice (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long price = -1;
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  402f94:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
  402f98:	e8 73 51 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr != NULL) {
  402f9d:	48 85 c0             	test   %rax,%rax
  402fa0:	74 09                	je     402fab <manager_queryFlightPrice+0x1b>
        price = (long)TM_SHARED_READ(reservationPtr->price);
  402fa2:	48 8b 40 20          	mov    0x20(%rax),%rax
 */
long
manager_queryFlightPrice (TM_ARGDECL  manager_t* managerPtr, long flightId)
{
    return queryPrice(TM_ARG  managerPtr->flightTablePtr, flightId);
}
  402fa6:	48 83 c4 08          	add    $0x8,%rsp
  402faa:	c3                   	retq   
 * =============================================================================
 */
static long
queryPrice (TM_ARGDECL  MAP_T* tablePtr, long id)
{
    long price = -1;
  402fab:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402fb2:	eb f2                	jmp    402fa6 <manager_queryFlightPrice+0x16>
  402fb4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  402fbb:	00 00 00 00 00 

0000000000402fc0 <manager_queryCustomerBill>:
 * -- Returns -1 if the customer does not exist
 * =============================================================================
 */
long
manager_queryCustomerBill (TM_ARGDECL  manager_t* managerPtr, long customerId)
{
  402fc0:	48 83 ec 08          	sub    $0x8,%rsp
    long bill = -1;
    customer_t* customerPtr;

    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);
  402fc4:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  402fc8:	e8 43 51 00 00       	callq  408110 <TMrbtree_get>

    if (customerPtr != NULL) {
  402fcd:	48 85 c0             	test   %rax,%rax
  402fd0:	74 0e                	je     402fe0 <manager_queryCustomerBill+0x20>
        bill = CUSTOMER_GET_BILL(customerPtr);
  402fd2:	48 89 c7             	mov    %rax,%rdi
    }

    return bill;
}
  402fd5:	48 83 c4 08          	add    $0x8,%rsp
    customer_t* customerPtr;

    customerPtr = (customer_t*)TMMAP_FIND(managerPtr->customerTablePtr, customerId);

    if (customerPtr != NULL) {
        bill = CUSTOMER_GET_BILL(customerPtr);
  402fd9:	e9 62 f0 ff ff       	jmpq   402040 <customer_getBill>
  402fde:	66 90                	xchg   %ax,%ax
    }

    return bill;
}
  402fe0:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402fe7:	48 83 c4 08          	add    $0x8,%rsp
  402feb:	c3                   	retq   
  402fec:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000402ff0 <manager_reserveCar>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_reserveCar (TM_ARGDECL  manager_t* managerPtr, long customerId, long carId)
{
  402ff0:	41 54                	push   %r12
  402ff2:	49 89 d4             	mov    %rdx,%r12
  402ff5:	55                   	push   %rbp
  402ff6:	53                   	push   %rbx
    return reserve(TM_ARG
  402ff7:	48 8b 1f             	mov    (%rdi),%rbx
         long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  402ffa:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  402ffe:	e8 0d 51 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  403003:	48 85 c0             	test   %rax,%rax
         long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  403006:	48 89 c5             	mov    %rax,%rbp
    if (customerPtr == NULL) {
  403009:	74 20                	je     40302b <manager_reserveCar+0x3b>
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40300b:	48 89 df             	mov    %rbx,%rdi
  40300e:	4c 89 e6             	mov    %r12,%rsi
  403011:	e8 fa 50 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  403016:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  403019:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  40301c:	74 0d                	je     40302b <manager_reserveCar+0x3b>
        return FALSE;
    }

    if (!RESERVATION_MAKE(reservationPtr)) {
  40301e:	48 89 c7             	mov    %rax,%rdi
  403021:	e8 6a 05 00 00       	callq  403590 <reservation_make>
  403026:	48 85 c0             	test   %rax,%rax
  403029:	75 0d                	jne    403038 <manager_reserveCar+0x48>
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  40302b:	31 c0                	xor    %eax,%eax
                   managerPtr->carTablePtr,
                   managerPtr->customerTablePtr,
                   customerId,
                   carId,
                   RESERVATION_CAR);
}
  40302d:	5b                   	pop    %rbx
  40302e:	5d                   	pop    %rbp
  40302f:	41 5c                	pop    %r12
  403031:	c3                   	retq   
  403032:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    if (!RESERVATION_MAKE(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_ADD_RESERVATION_INFO(
  403038:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
  40303c:	4c 89 e2             	mov    %r12,%rdx
  40303f:	31 f6                	xor    %esi,%esi
  403041:	48 89 ef             	mov    %rbp,%rdi
  403044:	e8 37 ef ff ff       	callq  401f80 <customer_addReservationInfo>
  403049:	48 89 c2             	mov    %rax,%rdx
            TM_RESTART();
        }
        return FALSE;
    }

    return TRUE;
  40304c:	b8 01 00 00 00       	mov    $0x1,%eax

    if (!RESERVATION_MAKE(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_ADD_RESERVATION_INFO(
  403051:	48 85 d2             	test   %rdx,%rdx
  403054:	75 d7                	jne    40302d <manager_reserveCar+0x3d>
            type,
            id,
            (long)TM_SHARED_READ(reservationPtr->price)))
    {
        /* Undo previous successful reservation */
        bool_t status = RESERVATION_CANCEL(reservationPtr);
  403056:	48 89 df             	mov    %rbx,%rdi
  403059:	e8 92 06 00 00       	callq  4036f0 <reservation_cancel>
        if (status == FALSE) {
  40305e:	48 85 c0             	test   %rax,%rax
  403061:	75 c8                	jne    40302b <manager_reserveCar+0x3b>
  403063:	e8 08 dd ff ff       	callq  400d70 <reserve.part.0>
  403068:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40306f:	00 

0000000000403070 <manager_reserveRoom>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_reserveRoom (TM_ARGDECL  manager_t* managerPtr, long customerId, long roomId)
{
  403070:	41 54                	push   %r12
  403072:	49 89 d4             	mov    %rdx,%r12
  403075:	55                   	push   %rbp
  403076:	53                   	push   %rbx
    return reserve(TM_ARG
  403077:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
         long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  40307b:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  40307f:	e8 8c 50 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  403084:	48 85 c0             	test   %rax,%rax
         long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  403087:	48 89 c5             	mov    %rax,%rbp
    if (customerPtr == NULL) {
  40308a:	74 20                	je     4030ac <manager_reserveRoom+0x3c>
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40308c:	48 89 df             	mov    %rbx,%rdi
  40308f:	4c 89 e6             	mov    %r12,%rsi
  403092:	e8 79 50 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  403097:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40309a:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  40309d:	74 0d                	je     4030ac <manager_reserveRoom+0x3c>
        return FALSE;
    }

    if (!RESERVATION_MAKE(reservationPtr)) {
  40309f:	48 89 c7             	mov    %rax,%rdi
  4030a2:	e8 e9 04 00 00       	callq  403590 <reservation_make>
  4030a7:	48 85 c0             	test   %rax,%rax
  4030aa:	75 0c                	jne    4030b8 <manager_reserveRoom+0x48>
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  4030ac:	31 c0                	xor    %eax,%eax
                   managerPtr->roomTablePtr,
                   managerPtr->customerTablePtr,
                   customerId,
                   roomId,
                   RESERVATION_ROOM);
}
  4030ae:	5b                   	pop    %rbx
  4030af:	5d                   	pop    %rbp
  4030b0:	41 5c                	pop    %r12
  4030b2:	c3                   	retq   
  4030b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    if (!RESERVATION_MAKE(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_ADD_RESERVATION_INFO(
  4030b8:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
  4030bc:	4c 89 e2             	mov    %r12,%rdx
  4030bf:	be 02 00 00 00       	mov    $0x2,%esi
  4030c4:	48 89 ef             	mov    %rbp,%rdi
  4030c7:	e8 b4 ee ff ff       	callq  401f80 <customer_addReservationInfo>
  4030cc:	48 89 c2             	mov    %rax,%rdx
            TM_RESTART();
        }
        return FALSE;
    }

    return TRUE;
  4030cf:	b8 01 00 00 00       	mov    $0x1,%eax

    if (!RESERVATION_MAKE(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_ADD_RESERVATION_INFO(
  4030d4:	48 85 d2             	test   %rdx,%rdx
  4030d7:	75 d5                	jne    4030ae <manager_reserveRoom+0x3e>
            type,
            id,
            (long)TM_SHARED_READ(reservationPtr->price)))
    {
        /* Undo previous successful reservation */
        bool_t status = RESERVATION_CANCEL(reservationPtr);
  4030d9:	48 89 df             	mov    %rbx,%rdi
  4030dc:	e8 0f 06 00 00       	callq  4036f0 <reservation_cancel>
        if (status == FALSE) {
  4030e1:	48 85 c0             	test   %rax,%rax
  4030e4:	75 c6                	jne    4030ac <manager_reserveRoom+0x3c>
  4030e6:	e8 85 dc ff ff       	callq  400d70 <reserve.part.0>
  4030eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000004030f0 <manager_reserveFlight>:
 * =============================================================================
 */
bool_t
manager_reserveFlight (TM_ARGDECL
                       manager_t* managerPtr, long customerId, long flightId)
{
  4030f0:	41 54                	push   %r12
  4030f2:	49 89 d4             	mov    %rdx,%r12
  4030f5:	55                   	push   %rbp
  4030f6:	53                   	push   %rbx
    return reserve(TM_ARG
  4030f7:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
         long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  4030fb:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  4030ff:	e8 0c 50 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  403104:	48 85 c0             	test   %rax,%rax
         long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  403107:	48 89 c5             	mov    %rax,%rbp
    if (customerPtr == NULL) {
  40310a:	74 20                	je     40312c <manager_reserveFlight+0x3c>
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40310c:	48 89 df             	mov    %rbx,%rdi
  40310f:	4c 89 e6             	mov    %r12,%rsi
  403112:	e8 f9 4f 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  403117:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40311a:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  40311d:	74 0d                	je     40312c <manager_reserveFlight+0x3c>
        return FALSE;
    }

    if (!RESERVATION_MAKE(reservationPtr)) {
  40311f:	48 89 c7             	mov    %rax,%rdi
  403122:	e8 69 04 00 00       	callq  403590 <reservation_make>
  403127:	48 85 c0             	test   %rax,%rax
  40312a:	75 0c                	jne    403138 <manager_reserveFlight+0x48>
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  40312c:	31 c0                	xor    %eax,%eax
                   managerPtr->flightTablePtr,
                   managerPtr->customerTablePtr,
                   customerId,
                   flightId,
                   RESERVATION_FLIGHT);
}
  40312e:	5b                   	pop    %rbx
  40312f:	5d                   	pop    %rbp
  403130:	41 5c                	pop    %r12
  403132:	c3                   	retq   
  403133:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    if (!RESERVATION_MAKE(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_ADD_RESERVATION_INFO(
  403138:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
  40313c:	4c 89 e2             	mov    %r12,%rdx
  40313f:	be 01 00 00 00       	mov    $0x1,%esi
  403144:	48 89 ef             	mov    %rbp,%rdi
  403147:	e8 34 ee ff ff       	callq  401f80 <customer_addReservationInfo>
  40314c:	48 89 c2             	mov    %rax,%rdx
            TM_RESTART();
        }
        return FALSE;
    }

    return TRUE;
  40314f:	b8 01 00 00 00       	mov    $0x1,%eax

    if (!RESERVATION_MAKE(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_ADD_RESERVATION_INFO(
  403154:	48 85 d2             	test   %rdx,%rdx
  403157:	75 d5                	jne    40312e <manager_reserveFlight+0x3e>
            type,
            id,
            (long)TM_SHARED_READ(reservationPtr->price)))
    {
        /* Undo previous successful reservation */
        bool_t status = RESERVATION_CANCEL(reservationPtr);
  403159:	48 89 df             	mov    %rbx,%rdi
  40315c:	e8 8f 05 00 00       	callq  4036f0 <reservation_cancel>
        if (status == FALSE) {
  403161:	48 85 c0             	test   %rax,%rax
  403164:	75 c6                	jne    40312c <manager_reserveFlight+0x3c>
  403166:	e8 05 dc ff ff       	callq  400d70 <reserve.part.0>
  40316b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000403170 <manager_cancelCar>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_cancelCar (TM_ARGDECL  manager_t* managerPtr, long customerId, long carId)
{
  403170:	41 54                	push   %r12
  403172:	49 89 d4             	mov    %rdx,%r12
  403175:	55                   	push   %rbp
  403176:	53                   	push   %rbx
    return cancel(TM_ARG
  403177:	48 8b 1f             	mov    (%rdi),%rbx
        long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  40317a:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  40317e:	e8 8d 4f 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  403183:	48 85 c0             	test   %rax,%rax
        long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  403186:	48 89 c5             	mov    %rax,%rbp
    if (customerPtr == NULL) {
  403189:	74 20                	je     4031ab <manager_cancelCar+0x3b>
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40318b:	48 89 df             	mov    %rbx,%rdi
  40318e:	4c 89 e6             	mov    %r12,%rsi
  403191:	e8 7a 4f 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  403196:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  403199:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  40319c:	74 0d                	je     4031ab <manager_cancelCar+0x3b>
        return FALSE;
    }

    if (!RESERVATION_CANCEL(reservationPtr)) {
  40319e:	48 89 c7             	mov    %rax,%rdi
  4031a1:	e8 4a 05 00 00       	callq  4036f0 <reservation_cancel>
  4031a6:	48 85 c0             	test   %rax,%rax
  4031a9:	75 0d                	jne    4031b8 <manager_cancelCar+0x48>
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  4031ab:	31 c0                	xor    %eax,%eax
                  managerPtr->carTablePtr,
                  managerPtr->customerTablePtr,
                  customerId,
                  carId,
                  RESERVATION_CAR);
}
  4031ad:	5b                   	pop    %rbx
  4031ae:	5d                   	pop    %rbp
  4031af:	41 5c                	pop    %r12
  4031b1:	c3                   	retq   
  4031b2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    if (!RESERVATION_CANCEL(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
  4031b8:	4c 89 e2             	mov    %r12,%rdx
  4031bb:	31 f6                	xor    %esi,%esi
  4031bd:	48 89 ef             	mov    %rbp,%rdi
  4031c0:	e8 fb ed ff ff       	callq  401fc0 <customer_removeReservationInfo>
  4031c5:	48 89 c2             	mov    %rax,%rdx
            TM_RESTART();
        }
        return FALSE;
    }

    return TRUE;
  4031c8:	b8 01 00 00 00       	mov    $0x1,%eax

    if (!RESERVATION_CANCEL(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
  4031cd:	48 85 d2             	test   %rdx,%rdx
  4031d0:	75 db                	jne    4031ad <manager_cancelCar+0x3d>
        /* Undo previous successful cancellation */
        bool_t status = RESERVATION_MAKE(reservationPtr);
  4031d2:	48 89 df             	mov    %rbx,%rdi
  4031d5:	e8 b6 03 00 00       	callq  403590 <reservation_make>
        if (status == FALSE) {
  4031da:	48 85 c0             	test   %rax,%rax
  4031dd:	75 cc                	jne    4031ab <manager_cancelCar+0x3b>
  4031df:	e8 a6 db ff ff       	callq  400d8a <cancel.part.1>
  4031e4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4031eb:	00 00 00 00 00 

00000000004031f0 <manager_cancelRoom>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
manager_cancelRoom (TM_ARGDECL  manager_t* managerPtr, long customerId, long roomId)
{
  4031f0:	41 54                	push   %r12
  4031f2:	49 89 d4             	mov    %rdx,%r12
  4031f5:	55                   	push   %rbp
  4031f6:	53                   	push   %rbx
    return cancel(TM_ARG
  4031f7:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
        long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  4031fb:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  4031ff:	e8 0c 4f 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  403204:	48 85 c0             	test   %rax,%rax
        long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  403207:	48 89 c5             	mov    %rax,%rbp
    if (customerPtr == NULL) {
  40320a:	74 20                	je     40322c <manager_cancelRoom+0x3c>
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40320c:	48 89 df             	mov    %rbx,%rdi
  40320f:	4c 89 e6             	mov    %r12,%rsi
  403212:	e8 f9 4e 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  403217:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40321a:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  40321d:	74 0d                	je     40322c <manager_cancelRoom+0x3c>
        return FALSE;
    }

    if (!RESERVATION_CANCEL(reservationPtr)) {
  40321f:	48 89 c7             	mov    %rax,%rdi
  403222:	e8 c9 04 00 00       	callq  4036f0 <reservation_cancel>
  403227:	48 85 c0             	test   %rax,%rax
  40322a:	75 0c                	jne    403238 <manager_cancelRoom+0x48>
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  40322c:	31 c0                	xor    %eax,%eax
                  managerPtr->roomTablePtr,
                  managerPtr->customerTablePtr,
                  customerId,
                  roomId,
                  RESERVATION_ROOM);
}
  40322e:	5b                   	pop    %rbx
  40322f:	5d                   	pop    %rbp
  403230:	41 5c                	pop    %r12
  403232:	c3                   	retq   
  403233:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    if (!RESERVATION_CANCEL(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
  403238:	4c 89 e2             	mov    %r12,%rdx
  40323b:	be 02 00 00 00       	mov    $0x2,%esi
  403240:	48 89 ef             	mov    %rbp,%rdi
  403243:	e8 78 ed ff ff       	callq  401fc0 <customer_removeReservationInfo>
  403248:	48 89 c2             	mov    %rax,%rdx
            TM_RESTART();
        }
        return FALSE;
    }

    return TRUE;
  40324b:	b8 01 00 00 00       	mov    $0x1,%eax

    if (!RESERVATION_CANCEL(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
  403250:	48 85 d2             	test   %rdx,%rdx
  403253:	75 d9                	jne    40322e <manager_cancelRoom+0x3e>
        /* Undo previous successful cancellation */
        bool_t status = RESERVATION_MAKE(reservationPtr);
  403255:	48 89 df             	mov    %rbx,%rdi
  403258:	e8 33 03 00 00       	callq  403590 <reservation_make>
        if (status == FALSE) {
  40325d:	48 85 c0             	test   %rax,%rax
  403260:	75 ca                	jne    40322c <manager_cancelRoom+0x3c>
  403262:	e8 23 db ff ff       	callq  400d8a <cancel.part.1>
  403267:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40326e:	00 00 

0000000000403270 <manager_cancelFlight>:
 * =============================================================================
 */
bool_t
manager_cancelFlight (TM_ARGDECL
                      manager_t* managerPtr, long customerId, long flightId)
{
  403270:	41 54                	push   %r12
  403272:	49 89 d4             	mov    %rdx,%r12
  403275:	55                   	push   %rbp
  403276:	53                   	push   %rbx
    return cancel(TM_ARG
  403277:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
        long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  40327b:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
  40327f:	e8 8c 4e 00 00       	callq  408110 <TMrbtree_get>
    if (customerPtr == NULL) {
  403284:	48 85 c0             	test   %rax,%rax
        long customerId, long id, reservation_type_t type)
{
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
  403287:	48 89 c5             	mov    %rax,%rbp
    if (customerPtr == NULL) {
  40328a:	74 20                	je     4032ac <manager_cancelFlight+0x3c>
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40328c:	48 89 df             	mov    %rbx,%rdi
  40328f:	4c 89 e6             	mov    %r12,%rsi
  403292:	e8 79 4e 00 00       	callq  408110 <TMrbtree_get>
    if (reservationPtr == NULL) {
  403297:	48 85 c0             	test   %rax,%rax
    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
    }

    reservationPtr = (reservation_t*)TMMAP_FIND(tablePtr, id);
  40329a:	48 89 c3             	mov    %rax,%rbx
    if (reservationPtr == NULL) {
  40329d:	74 0d                	je     4032ac <manager_cancelFlight+0x3c>
        return FALSE;
    }

    if (!RESERVATION_CANCEL(reservationPtr)) {
  40329f:	48 89 c7             	mov    %rax,%rdi
  4032a2:	e8 49 04 00 00       	callq  4036f0 <reservation_cancel>
  4032a7:	48 85 c0             	test   %rax,%rax
  4032aa:	75 0c                	jne    4032b8 <manager_cancelFlight+0x48>
    customer_t* customerPtr;
    reservation_t* reservationPtr;

    customerPtr = (customer_t*)TMMAP_FIND(customerTablePtr, customerId);
    if (customerPtr == NULL) {
        return FALSE;
  4032ac:	31 c0                	xor    %eax,%eax
                  managerPtr->flightTablePtr,
                  managerPtr->customerTablePtr,
                  customerId,
                  flightId,
                  RESERVATION_FLIGHT);
}
  4032ae:	5b                   	pop    %rbx
  4032af:	5d                   	pop    %rbp
  4032b0:	41 5c                	pop    %r12
  4032b2:	c3                   	retq   
  4032b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    if (!RESERVATION_CANCEL(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
  4032b8:	4c 89 e2             	mov    %r12,%rdx
  4032bb:	be 01 00 00 00       	mov    $0x1,%esi
  4032c0:	48 89 ef             	mov    %rbp,%rdi
  4032c3:	e8 f8 ec ff ff       	callq  401fc0 <customer_removeReservationInfo>
  4032c8:	48 89 c2             	mov    %rax,%rdx
            TM_RESTART();
        }
        return FALSE;
    }

    return TRUE;
  4032cb:	b8 01 00 00 00       	mov    $0x1,%eax

    if (!RESERVATION_CANCEL(reservationPtr)) {
        return FALSE;
    }

    if (!CUSTOMER_REMOVE_RESERVATION_INFO(customerPtr, type, id)) {
  4032d0:	48 85 d2             	test   %rdx,%rdx
  4032d3:	75 d9                	jne    4032ae <manager_cancelFlight+0x3e>
        /* Undo previous successful cancellation */
        bool_t status = RESERVATION_MAKE(reservationPtr);
  4032d5:	48 89 df             	mov    %rbx,%rdi
  4032d8:	e8 b3 02 00 00       	callq  403590 <reservation_make>
        if (status == FALSE) {
  4032dd:	48 85 c0             	test   %rax,%rax
  4032e0:	75 ca                	jne    4032ac <manager_cancelFlight+0x3c>
  4032e2:	e8 a3 da ff ff       	callq  400d8a <cancel.part.1>
  4032e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4032ee:	00 00 

00000000004032f0 <reservation_info_alloc>:
 * -- Returns NULL on failure
 * =============================================================================
 */
reservation_info_t*
reservation_info_alloc (TM_ARGDECL  reservation_type_t type, long id, long price)
{
  4032f0:	41 54                	push   %r12
  4032f2:	49 89 f4             	mov    %rsi,%r12
  4032f5:	55                   	push   %rbp
  4032f6:	48 89 d5             	mov    %rdx,%rbp
  4032f9:	53                   	push   %rbx
  4032fa:	89 fb                	mov    %edi,%ebx
    reservation_info_t* reservationInfoPtr;

    reservationInfoPtr = (reservation_info_t*)TM_MALLOC(sizeof(reservation_info_t));
  4032fc:	bf 18 00 00 00       	mov    $0x18,%edi
  403301:	e8 7a d9 ff ff       	callq  400c80 <malloc@plt>
    if (reservationInfoPtr != NULL) {
  403306:	48 85 c0             	test   %rax,%rax
  403309:	74 0a                	je     403315 <reservation_info_alloc+0x25>
        reservationInfoPtr->type = type;
  40330b:	89 18                	mov    %ebx,(%rax)
        reservationInfoPtr->id = id;
  40330d:	4c 89 60 08          	mov    %r12,0x8(%rax)
        reservationInfoPtr->price = price;
  403311:	48 89 68 10          	mov    %rbp,0x10(%rax)
    }

    return reservationInfoPtr;
}
  403315:	5b                   	pop    %rbx
  403316:	5d                   	pop    %rbp
  403317:	41 5c                	pop    %r12
  403319:	c3                   	retq   
  40331a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000403320 <reservation_info_free>:
 * =============================================================================
 */
void
reservation_info_free (TM_ARGDECL  reservation_info_t* reservationInfoPtr)
{
    TM_FREE(reservationInfoPtr);
  403320:	e9 8b d9 ff ff       	jmpq   400cb0 <free@plt>
  403325:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40332c:	00 00 00 00 

0000000000403330 <reservation_info_compare>:
long
reservation_info_compare (reservation_info_t* aPtr, reservation_info_t* bPtr)
{
    long typeDiff;

    typeDiff = aPtr->type - bPtr->type;
  403330:	8b 07                	mov    (%rdi),%eax
  403332:	2b 06                	sub    (%rsi),%eax

    return ((typeDiff != 0) ? (typeDiff) : (aPtr->id - bPtr->id));
  403334:	48 85 c0             	test   %rax,%rax
  403337:	75 08                	jne    403341 <reservation_info_compare+0x11>
  403339:	48 8b 47 08          	mov    0x8(%rdi),%rax
  40333d:	48 2b 46 08          	sub    0x8(%rsi),%rax
}
  403341:	f3 c3                	repz retq 
  403343:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40334a:	84 00 00 00 00 00 

0000000000403350 <reservation_alloc>:
 * -- Returns NULL on failure
 * =============================================================================
 */
reservation_t*
reservation_alloc (TM_ARGDECL  long id, long numTotal, long price)
{
  403350:	41 54                	push   %r12
  403352:	49 89 fc             	mov    %rdi,%r12
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TM_MALLOC(sizeof(reservation_t));
  403355:	bf 28 00 00 00       	mov    $0x28,%edi
 * -- Returns NULL on failure
 * =============================================================================
 */
reservation_t*
reservation_alloc (TM_ARGDECL  long id, long numTotal, long price)
{
  40335a:	55                   	push   %rbp
  40335b:	48 89 d5             	mov    %rdx,%rbp
  40335e:	53                   	push   %rbx
  40335f:	48 89 f3             	mov    %rsi,%rbx
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TM_MALLOC(sizeof(reservation_t));
  403362:	e8 19 d9 ff ff       	callq  400c80 <malloc@plt>
    if (reservationPtr != NULL) {
  403367:	48 85 c0             	test   %rax,%rax
  40336a:	74 21                	je     40338d <reservation_alloc+0x3d>
    if (numUsed < 0) {
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
  40336c:	48 85 db             	test   %rbx,%rbx
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)TM_MALLOC(sizeof(reservation_t));
    if (reservationPtr != NULL) {
        reservationPtr->id = id;
  40336f:	4c 89 20             	mov    %r12,(%rax)
        reservationPtr->numUsed = 0;
  403372:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  403379:	00 
        reservationPtr->numFree = numTotal;
  40337a:	48 89 58 10          	mov    %rbx,0x10(%rax)
        reservationPtr->numTotal = numTotal;
  40337e:	48 89 58 18          	mov    %rbx,0x18(%rax)
        reservationPtr->price = price;
  403382:	48 89 68 20          	mov    %rbp,0x20(%rax)
    if (numUsed < 0) {
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
  403386:	78 0a                	js     403392 <reservation_alloc+0x42>
    if ((numUsed + numFree) != numTotal) {
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
  403388:	48 85 ed             	test   %rbp,%rbp
  40338b:	78 1e                	js     4033ab <reservation_alloc+0x5b>
        reservationPtr->price = price;
        CHECK_RESERVATION(reservationPtr);
    }

    return reservationPtr;
}
  40338d:	5b                   	pop    %rbx
  40338e:	5d                   	pop    %rbp
  40338f:	41 5c                	pop    %r12
  403391:	c3                   	retq   
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
        TM_RESTART();
  403392:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  403397:	ba 98 00 00 00       	mov    $0x98,%edx
  40339c:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4033a1:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4033a6:	e8 a5 d8 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
        TM_RESTART();
  4033ab:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4033b0:	ba a6 00 00 00       	mov    $0xa6,%edx
  4033b5:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4033ba:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4033bf:	e8 8c d8 ff ff       	callq  400c50 <__assert_fail@plt>
  4033c4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4033cb:	00 00 00 00 00 

00000000004033d0 <reservation_alloc_seq>:
}


reservation_t*
reservation_alloc_seq (long id, long numTotal, long price)
{
  4033d0:	41 54                	push   %r12
  4033d2:	49 89 fc             	mov    %rdi,%r12
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)malloc(sizeof(reservation_t));
  4033d5:	bf 28 00 00 00       	mov    $0x28,%edi
}


reservation_t*
reservation_alloc_seq (long id, long numTotal, long price)
{
  4033da:	55                   	push   %rbp
  4033db:	48 89 d5             	mov    %rdx,%rbp
  4033de:	53                   	push   %rbx
  4033df:	48 89 f3             	mov    %rsi,%rbx
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)malloc(sizeof(reservation_t));
  4033e2:	e8 99 d8 ff ff       	callq  400c80 <malloc@plt>
    if (reservationPtr != NULL) {
  4033e7:	48 85 c0             	test   %rax,%rax
  4033ea:	74 21                	je     40340d <reservation_alloc_seq+0x3d>

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  4033ec:	48 85 db             	test   %rbx,%rbx
{
    reservation_t* reservationPtr;

    reservationPtr = (reservation_t*)malloc(sizeof(reservation_t));
    if (reservationPtr != NULL) {
        reservationPtr->id = id;
  4033ef:	4c 89 20             	mov    %r12,(%rax)
        reservationPtr->numUsed = 0;
  4033f2:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  4033f9:	00 
        reservationPtr->numFree = numTotal;
  4033fa:	48 89 58 10          	mov    %rbx,0x10(%rax)
        reservationPtr->numTotal = numTotal;
  4033fe:	48 89 58 18          	mov    %rbx,0x18(%rax)
        reservationPtr->price = price;
  403402:	48 89 68 20          	mov    %rbp,0x20(%rax)

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  403406:	78 0a                	js     403412 <reservation_alloc_seq+0x42>
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  403408:	48 85 ed             	test   %rbp,%rbp
  40340b:	78 1e                	js     40342b <reservation_alloc_seq+0x5b>
        reservationPtr->price = price;
        checkReservation_seq(reservationPtr);
    }

    return reservationPtr;
}
  40340d:	5b                   	pop    %rbx
  40340e:	5d                   	pop    %rbp
  40340f:	41 5c                	pop    %r12
  403411:	c3                   	retq   

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  403412:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  403417:	ba b2 00 00 00       	mov    $0xb2,%edx
  40341c:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403421:	bf fb 8d 40 00       	mov    $0x408dfb,%edi
  403426:	e8 25 d8 ff ff       	callq  400c50 <__assert_fail@plt>
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  40342b:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  403430:	ba b6 00 00 00       	mov    $0xb6,%edx
  403435:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  40343a:	bf 18 8e 40 00       	mov    $0x408e18,%edi
  40343f:	e8 0c d8 ff ff       	callq  400c50 <__assert_fail@plt>
  403444:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40344b:	00 00 00 00 00 

0000000000403450 <reservation_addToTotal>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
reservation_addToTotal (TM_ARGDECL  reservation_t* reservationPtr, long num)
{
  403450:	48 83 ec 08          	sub    $0x8,%rsp
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);

    if (numFree + num < 0) {
  403454:	48 89 f0             	mov    %rsi,%rax
  403457:	48 03 47 10          	add    0x10(%rdi),%rax
  40345b:	78 33                	js     403490 <reservation_addToTotal+0x40>
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->numFree, (numFree + num));
    TM_SHARED_WRITE(reservationPtr->numTotal,
  40345d:	48 03 77 18          	add    0x18(%rdi),%rsi
 * =============================================================================
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
  403461:	48 8b 57 08          	mov    0x8(%rdi),%rdx

    if (numFree + num < 0) {
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->numFree, (numFree + num));
  403465:	48 89 47 10          	mov    %rax,0x10(%rdi)
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
    if (numUsed < 0) {
  403469:	48 85 d2             	test   %rdx,%rdx
    if (numFree + num < 0) {
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->numFree, (numFree + num));
    TM_SHARED_WRITE(reservationPtr->numTotal,
  40346c:	48 89 77 18          	mov    %rsi,0x18(%rdi)
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
    if (numUsed < 0) {
  403470:	78 70                	js     4034e2 <reservation_addToTotal+0x92>
    if (numFree < 0) {
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
    if (numTotal < 0) {
  403472:	48 85 f6             	test   %rsi,%rsi
  403475:	78 52                	js     4034c9 <reservation_addToTotal+0x79>
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
  403477:	48 01 d0             	add    %rdx,%rax
  40347a:	48 39 c6             	cmp    %rax,%rsi
  40347d:	75 31                	jne    4034b0 <reservation_addToTotal+0x60>
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
  40347f:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
  403484:	78 11                	js     403497 <reservation_addToTotal+0x47>
    TM_SHARED_WRITE(reservationPtr->numTotal,
                    ((long)TM_SHARED_READ(reservationPtr->numTotal) + num));

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
  403486:	b8 01 00 00 00       	mov    $0x1,%eax
}
  40348b:	48 83 c4 08          	add    $0x8,%rsp
  40348f:	c3                   	retq   
reservation_addToTotal (TM_ARGDECL  reservation_t* reservationPtr, long num)
{
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);

    if (numFree + num < 0) {
        return FALSE;
  403490:	31 c0                	xor    %eax,%eax
                    ((long)TM_SHARED_READ(reservationPtr->numTotal) + num));

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
}
  403492:	48 83 c4 08          	add    $0x8,%rsp
  403496:	c3                   	retq   
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
        TM_RESTART();
  403497:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  40349c:	ba a6 00 00 00       	mov    $0xa6,%edx
  4034a1:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4034a6:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4034ab:	e8 a0 d7 ff ff       	callq  400c50 <__assert_fail@plt>
    if (numTotal < 0) {
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
        TM_RESTART();
  4034b0:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4034b5:	ba a1 00 00 00       	mov    $0xa1,%edx
  4034ba:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4034bf:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4034c4:	e8 87 d7 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
    if (numTotal < 0) {
        TM_RESTART();
  4034c9:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4034ce:	ba 9d 00 00 00       	mov    $0x9d,%edx
  4034d3:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4034d8:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4034dd:	e8 6e d7 ff ff       	callq  400c50 <__assert_fail@plt>
  4034e2:	e8 bd d8 ff ff       	callq  400da4 <checkReservation.part.0>
  4034e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4034ee:	00 00 

00000000004034f0 <reservation_addToTotal_seq>:
}


bool_t
reservation_addToTotal_seq (reservation_t* reservationPtr, long num)
{
  4034f0:	48 83 ec 08          	sub    $0x8,%rsp
    if (reservationPtr->numFree + num < 0) {
  4034f4:	48 89 f0             	mov    %rsi,%rax
  4034f7:	48 03 47 10          	add    0x10(%rdi),%rax
  4034fb:	78 33                	js     403530 <reservation_addToTotal_seq+0x40>
        return FALSE;
    }

    reservationPtr->numFree += num;
    reservationPtr->numTotal += num;
  4034fd:	48 03 77 18          	add    0x18(%rdi),%rsi


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  403501:	48 8b 57 08          	mov    0x8(%rdi),%rdx
{
    if (reservationPtr->numFree + num < 0) {
        return FALSE;
    }

    reservationPtr->numFree += num;
  403505:	48 89 47 10          	mov    %rax,0x10(%rdi)


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  403509:	48 85 d2             	test   %rdx,%rdx
    if (reservationPtr->numFree + num < 0) {
        return FALSE;
    }

    reservationPtr->numFree += num;
    reservationPtr->numTotal += num;
  40350c:	48 89 77 18          	mov    %rsi,0x18(%rdi)


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  403510:	78 70                	js     403582 <reservation_addToTotal_seq+0x92>
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
  403512:	48 85 f6             	test   %rsi,%rsi
  403515:	78 52                	js     403569 <reservation_addToTotal_seq+0x79>
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  403517:	48 01 d0             	add    %rdx,%rax
  40351a:	48 39 c6             	cmp    %rax,%rsi
  40351d:	75 31                	jne    403550 <reservation_addToTotal_seq+0x60>
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  40351f:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
  403524:	78 11                	js     403537 <reservation_addToTotal_seq+0x47>
    reservationPtr->numFree += num;
    reservationPtr->numTotal += num;

    checkReservation_seq(reservationPtr);

    return TRUE;
  403526:	b8 01 00 00 00       	mov    $0x1,%eax
}
  40352b:	48 83 c4 08          	add    $0x8,%rsp
  40352f:	c3                   	retq   

bool_t
reservation_addToTotal_seq (reservation_t* reservationPtr, long num)
{
    if (reservationPtr->numFree + num < 0) {
        return FALSE;
  403530:	31 c0                	xor    %eax,%eax
    reservationPtr->numTotal += num;

    checkReservation_seq(reservationPtr);

    return TRUE;
}
  403532:	48 83 c4 08          	add    $0x8,%rsp
  403536:	c3                   	retq   
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  403537:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40353c:	ba b6 00 00 00       	mov    $0xb6,%edx
  403541:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403546:	bf 18 8e 40 00       	mov    $0x408e18,%edi
  40354b:	e8 00 d7 ff ff       	callq  400c50 <__assert_fail@plt>
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  403550:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  403555:	ba b5 00 00 00       	mov    $0xb5,%edx
  40355a:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  40355f:	bf 58 8e 40 00       	mov    $0x408e58,%edi
  403564:	e8 e7 d6 ff ff       	callq  400c50 <__assert_fail@plt>
static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
  403569:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40356e:	ba b3 00 00 00       	mov    $0xb3,%edx
  403573:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403578:	bf 33 8e 40 00       	mov    $0x408e33,%edi
  40357d:	e8 ce d6 ff ff       	callq  400c50 <__assert_fail@plt>
  403582:	e8 37 d8 ff ff       	callq  400dbe <checkReservation_seq.part.1>
  403587:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40358e:	00 00 

0000000000403590 <reservation_make>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
reservation_make (TM_ARGDECL  reservation_t* reservationPtr)
{
  403590:	48 83 ec 08          	sub    $0x8,%rsp
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
  403594:	48 8b 47 10          	mov    0x10(%rdi),%rax

    if (numFree < 1) {
  403598:	48 85 c0             	test   %rax,%rax
  40359b:	7e 43                	jle    4035e0 <reservation_make+0x50>
        return FALSE;
    }
    TM_SHARED_WRITE(reservationPtr->numUsed,
  40359d:	48 8b 77 08          	mov    0x8(%rdi),%rsi
                    ((long)TM_SHARED_READ(reservationPtr->numUsed) + 1));
    TM_SHARED_WRITE(reservationPtr->numFree, (numFree - 1));
  4035a1:	48 83 e8 01          	sub    $0x1,%rax
  4035a5:	48 89 47 10          	mov    %rax,0x10(%rdi)
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);

    if (numFree < 1) {
        return FALSE;
    }
    TM_SHARED_WRITE(reservationPtr->numUsed,
  4035a9:	48 8d 56 01          	lea    0x1(%rsi),%rdx
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
    if (numUsed < 0) {
  4035ad:	48 85 d2             	test   %rdx,%rdx
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);

    if (numFree < 1) {
        return FALSE;
    }
    TM_SHARED_WRITE(reservationPtr->numUsed,
  4035b0:	48 89 57 08          	mov    %rdx,0x8(%rdi)
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
    if (numUsed < 0) {
  4035b4:	78 7c                	js     403632 <reservation_make+0xa2>
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
  4035b6:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
    if (numTotal < 0) {
  4035ba:	48 85 c9             	test   %rcx,%rcx
  4035bd:	78 5a                	js     403619 <reservation_make+0x89>
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
  4035bf:	48 01 d0             	add    %rdx,%rax
  4035c2:	48 39 c1             	cmp    %rax,%rcx
  4035c5:	75 39                	jne    403600 <reservation_make+0x70>
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
  4035c7:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
  4035cc:	78 19                	js     4035e7 <reservation_make+0x57>
                    ((long)TM_SHARED_READ(reservationPtr->numUsed) + 1));
    TM_SHARED_WRITE(reservationPtr->numFree, (numFree - 1));

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
  4035ce:	b8 01 00 00 00       	mov    $0x1,%eax
}
  4035d3:	48 83 c4 08          	add    $0x8,%rsp
  4035d7:	c3                   	retq   
  4035d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4035df:	00 
reservation_make (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);

    if (numFree < 1) {
        return FALSE;
  4035e0:	31 c0                	xor    %eax,%eax
    TM_SHARED_WRITE(reservationPtr->numFree, (numFree - 1));

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
}
  4035e2:	48 83 c4 08          	add    $0x8,%rsp
  4035e6:	c3                   	retq   
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
        TM_RESTART();
  4035e7:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4035ec:	ba a6 00 00 00       	mov    $0xa6,%edx
  4035f1:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4035f6:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4035fb:	e8 50 d6 ff ff       	callq  400c50 <__assert_fail@plt>
    if (numTotal < 0) {
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
        TM_RESTART();
  403600:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  403605:	ba a1 00 00 00       	mov    $0xa1,%edx
  40360a:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  40360f:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  403614:	e8 37 d6 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
    if (numTotal < 0) {
        TM_RESTART();
  403619:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  40361e:	ba 9d 00 00 00       	mov    $0x9d,%edx
  403623:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403628:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  40362d:	e8 1e d6 ff ff       	callq  400c50 <__assert_fail@plt>
  403632:	e8 6d d7 ff ff       	callq  400da4 <checkReservation.part.0>
  403637:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40363e:	00 00 

0000000000403640 <reservation_make_seq>:
}


bool_t
reservation_make_seq (reservation_t* reservationPtr)
{
  403640:	48 83 ec 08          	sub    $0x8,%rsp
    if (reservationPtr->numFree < 1) {
  403644:	48 8b 47 10          	mov    0x10(%rdi),%rax
  403648:	48 85 c0             	test   %rax,%rax
  40364b:	7e 43                	jle    403690 <reservation_make_seq+0x50>
        return FALSE;
    }

    reservationPtr->numUsed++;
  40364d:	48 8b 77 08          	mov    0x8(%rdi),%rsi
    reservationPtr->numFree--;
  403651:	48 83 e8 01          	sub    $0x1,%rax
  403655:	48 89 47 10          	mov    %rax,0x10(%rdi)
{
    if (reservationPtr->numFree < 1) {
        return FALSE;
    }

    reservationPtr->numUsed++;
  403659:	48 8d 56 01          	lea    0x1(%rsi),%rdx


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  40365d:	48 85 d2             	test   %rdx,%rdx
{
    if (reservationPtr->numFree < 1) {
        return FALSE;
    }

    reservationPtr->numUsed++;
  403660:	48 89 57 08          	mov    %rdx,0x8(%rdi)


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  403664:	78 7c                	js     4036e2 <reservation_make_seq+0xa2>
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
  403666:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
  40366a:	48 85 c9             	test   %rcx,%rcx
  40366d:	78 5a                	js     4036c9 <reservation_make_seq+0x89>
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  40366f:	48 01 d0             	add    %rdx,%rax
  403672:	48 39 c1             	cmp    %rax,%rcx
  403675:	75 39                	jne    4036b0 <reservation_make_seq+0x70>
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  403677:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
  40367c:	78 19                	js     403697 <reservation_make_seq+0x57>
    reservationPtr->numUsed++;
    reservationPtr->numFree--;

    checkReservation_seq(reservationPtr);

    return TRUE;
  40367e:	b8 01 00 00 00       	mov    $0x1,%eax
}
  403683:	48 83 c4 08          	add    $0x8,%rsp
  403687:	c3                   	retq   
  403688:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40368f:	00 

bool_t
reservation_make_seq (reservation_t* reservationPtr)
{
    if (reservationPtr->numFree < 1) {
        return FALSE;
  403690:	31 c0                	xor    %eax,%eax
    reservationPtr->numFree--;

    checkReservation_seq(reservationPtr);

    return TRUE;
}
  403692:	48 83 c4 08          	add    $0x8,%rsp
  403696:	c3                   	retq   
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  403697:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40369c:	ba b6 00 00 00       	mov    $0xb6,%edx
  4036a1:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4036a6:	bf 18 8e 40 00       	mov    $0x408e18,%edi
  4036ab:	e8 a0 d5 ff ff       	callq  400c50 <__assert_fail@plt>
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  4036b0:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  4036b5:	ba b5 00 00 00       	mov    $0xb5,%edx
  4036ba:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4036bf:	bf 58 8e 40 00       	mov    $0x408e58,%edi
  4036c4:	e8 87 d5 ff ff       	callq  400c50 <__assert_fail@plt>
static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
  4036c9:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  4036ce:	ba b3 00 00 00       	mov    $0xb3,%edx
  4036d3:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4036d8:	bf 33 8e 40 00       	mov    $0x408e33,%edi
  4036dd:	e8 6e d5 ff ff       	callq  400c50 <__assert_fail@plt>
  4036e2:	e8 d7 d6 ff ff       	callq  400dbe <checkReservation_seq.part.1>
  4036e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4036ee:	00 00 

00000000004036f0 <reservation_cancel>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
reservation_cancel (TM_ARGDECL  reservation_t* reservationPtr)
{
  4036f0:	48 83 ec 08          	sub    $0x8,%rsp
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
  4036f4:	48 8b 47 08          	mov    0x8(%rdi),%rax

    if (numUsed < 1) {
  4036f8:	48 85 c0             	test   %rax,%rax
  4036fb:	7e 43                	jle    403740 <reservation_cancel+0x50>
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->numUsed, (numUsed - 1));
    TM_SHARED_WRITE(reservationPtr->numFree,
  4036fd:	48 8b 77 10          	mov    0x10(%rdi),%rsi

    if (numUsed < 1) {
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->numUsed, (numUsed - 1));
  403701:	48 83 e8 01          	sub    $0x1,%rax
  403705:	48 89 47 08          	mov    %rax,0x8(%rdi)
    TM_SHARED_WRITE(reservationPtr->numFree,
  403709:	48 8d 56 01          	lea    0x1(%rsi),%rdx
    if (numUsed < 0) {
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
  40370d:	48 85 d2             	test   %rdx,%rdx
    if (numUsed < 1) {
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->numUsed, (numUsed - 1));
    TM_SHARED_WRITE(reservationPtr->numFree,
  403710:	48 89 57 10          	mov    %rdx,0x10(%rdi)
    if (numUsed < 0) {
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
  403714:	78 7c                	js     403792 <reservation_cancel+0xa2>
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
  403716:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
    if (numTotal < 0) {
  40371a:	48 85 c9             	test   %rcx,%rcx
  40371d:	78 5a                	js     403779 <reservation_cancel+0x89>
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
  40371f:	48 01 d0             	add    %rdx,%rax
  403722:	48 39 c1             	cmp    %rax,%rcx
  403725:	75 39                	jne    403760 <reservation_cancel+0x70>
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
  403727:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
  40372c:	78 19                	js     403747 <reservation_cancel+0x57>
    TM_SHARED_WRITE(reservationPtr->numFree,
                    ((long)TM_SHARED_READ(reservationPtr->numFree) + 1));

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
  40372e:	b8 01 00 00 00       	mov    $0x1,%eax
}
  403733:	48 83 c4 08          	add    $0x8,%rsp
  403737:	c3                   	retq   
  403738:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40373f:	00 
reservation_cancel (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);

    if (numUsed < 1) {
        return FALSE;
  403740:	31 c0                	xor    %eax,%eax
                    ((long)TM_SHARED_READ(reservationPtr->numFree) + 1));

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
}
  403742:	48 83 c4 08          	add    $0x8,%rsp
  403746:	c3                   	retq   
        TM_RESTART();
    }

    long price = (long)TM_SHARED_READ(reservationPtr->price);
    if (price < 0) {
        TM_RESTART();
  403747:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  40374c:	ba a6 00 00 00       	mov    $0xa6,%edx
  403751:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403756:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  40375b:	e8 f0 d4 ff ff       	callq  400c50 <__assert_fail@plt>
    if (numTotal < 0) {
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
        TM_RESTART();
  403760:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  403765:	ba a1 00 00 00       	mov    $0xa1,%edx
  40376a:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  40376f:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  403774:	e8 d7 d4 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
    if (numTotal < 0) {
        TM_RESTART();
  403779:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  40377e:	ba 9d 00 00 00       	mov    $0x9d,%edx
  403783:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403788:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  40378d:	e8 be d4 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
        TM_RESTART();
  403792:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  403797:	ba 98 00 00 00       	mov    $0x98,%edx
  40379c:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4037a1:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4037a6:	e8 a5 d4 ff ff       	callq  400c50 <__assert_fail@plt>
  4037ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000004037b0 <reservation_cancel_seq>:
}


bool_t
reservation_cancel_seq (reservation_t* reservationPtr)
{
  4037b0:	48 83 ec 08          	sub    $0x8,%rsp
    if (reservationPtr->numUsed < 1) {
  4037b4:	48 8b 47 08          	mov    0x8(%rdi),%rax
  4037b8:	48 85 c0             	test   %rax,%rax
  4037bb:	7e 43                	jle    403800 <reservation_cancel_seq+0x50>
        return FALSE;
    }

    reservationPtr->numUsed--;
    reservationPtr->numFree++;
  4037bd:	48 8b 77 10          	mov    0x10(%rdi),%rsi
{
    if (reservationPtr->numUsed < 1) {
        return FALSE;
    }

    reservationPtr->numUsed--;
  4037c1:	48 83 e8 01          	sub    $0x1,%rax
  4037c5:	48 89 47 08          	mov    %rax,0x8(%rdi)
    reservationPtr->numFree++;
  4037c9:	48 8d 56 01          	lea    0x1(%rsi),%rdx

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  4037cd:	48 85 d2             	test   %rdx,%rdx
    if (reservationPtr->numUsed < 1) {
        return FALSE;
    }

    reservationPtr->numUsed--;
    reservationPtr->numFree++;
  4037d0:	48 89 57 10          	mov    %rdx,0x10(%rdi)

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  4037d4:	78 7c                	js     403852 <reservation_cancel_seq+0xa2>
    assert(reservationPtr->numTotal >= 0);
  4037d6:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
  4037da:	48 85 c9             	test   %rcx,%rcx
  4037dd:	78 5a                	js     403839 <reservation_cancel_seq+0x89>
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  4037df:	48 01 d0             	add    %rdx,%rax
  4037e2:	48 39 c1             	cmp    %rax,%rcx
  4037e5:	75 39                	jne    403820 <reservation_cancel_seq+0x70>
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  4037e7:	48 83 7f 20 00       	cmpq   $0x0,0x20(%rdi)
  4037ec:	78 19                	js     403807 <reservation_cancel_seq+0x57>
    reservationPtr->numUsed--;
    reservationPtr->numFree++;

    checkReservation_seq(reservationPtr);

    return TRUE;
  4037ee:	b8 01 00 00 00       	mov    $0x1,%eax
}
  4037f3:	48 83 c4 08          	add    $0x8,%rsp
  4037f7:	c3                   	retq   
  4037f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4037ff:	00 

bool_t
reservation_cancel_seq (reservation_t* reservationPtr)
{
    if (reservationPtr->numUsed < 1) {
        return FALSE;
  403800:	31 c0                	xor    %eax,%eax
    reservationPtr->numFree++;

    checkReservation_seq(reservationPtr);

    return TRUE;
}
  403802:	48 83 c4 08          	add    $0x8,%rsp
  403806:	c3                   	retq   
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
           (reservationPtr->numTotal));
    assert(reservationPtr->price >= 0);
  403807:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40380c:	ba b6 00 00 00       	mov    $0xb6,%edx
  403811:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403816:	bf 18 8e 40 00       	mov    $0x408e18,%edi
  40381b:	e8 30 d4 ff ff       	callq  400c50 <__assert_fail@plt>
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  403820:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  403825:	ba b5 00 00 00       	mov    $0xb5,%edx
  40382a:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  40382f:	bf 58 8e 40 00       	mov    $0x408e58,%edi
  403834:	e8 17 d4 ff ff       	callq  400c50 <__assert_fail@plt>
static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
  403839:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40383e:	ba b3 00 00 00       	mov    $0xb3,%edx
  403843:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403848:	bf 33 8e 40 00       	mov    $0x408e33,%edi
  40384d:	e8 fe d3 ff ff       	callq  400c50 <__assert_fail@plt>

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  403852:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  403857:	ba b2 00 00 00       	mov    $0xb2,%edx
  40385c:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403861:	bf fb 8d 40 00       	mov    $0x408dfb,%edi
  403866:	e8 e5 d3 ff ff       	callq  400c50 <__assert_fail@plt>
  40386b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000403870 <reservation_updatePrice>:
 * -- Returns TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
reservation_updatePrice (TM_ARGDECL  reservation_t* reservationPtr, long newPrice)
{
  403870:	48 83 ec 08          	sub    $0x8,%rsp
    if (newPrice < 0) {
  403874:	48 85 f6             	test   %rsi,%rsi
  403877:	78 37                	js     4038b0 <reservation_updatePrice+0x40>
 * =============================================================================
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
  403879:	48 8b 57 08          	mov    0x8(%rdi),%rdx
{
    if (newPrice < 0) {
        return FALSE;
    }

    TM_SHARED_WRITE(reservationPtr->price, newPrice);
  40387d:	48 89 77 20          	mov    %rsi,0x20(%rdi)
 */
static void
checkReservation (TM_ARGDECL  reservation_t* reservationPtr)
{
    long numUsed = (long)TM_SHARED_READ(reservationPtr->numUsed);
    if (numUsed < 0) {
  403881:	48 85 d2             	test   %rdx,%rdx
  403884:	78 7c                	js     403902 <reservation_updatePrice+0x92>
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
  403886:	48 8b 47 10          	mov    0x10(%rdi),%rax
    if (numFree < 0) {
  40388a:	48 85 c0             	test   %rax,%rax
  40388d:	78 5a                	js     4038e9 <reservation_updatePrice+0x79>
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
  40388f:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
    if (numTotal < 0) {
  403893:	48 85 c9             	test   %rcx,%rcx
  403896:	78 38                	js     4038d0 <reservation_updatePrice+0x60>
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
  403898:	48 01 d0             	add    %rdx,%rax
  40389b:	48 39 c1             	cmp    %rax,%rcx
  40389e:	75 17                	jne    4038b7 <reservation_updatePrice+0x47>

    TM_SHARED_WRITE(reservationPtr->price, newPrice);

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
  4038a0:	b8 01 00 00 00       	mov    $0x1,%eax
}
  4038a5:	48 83 c4 08          	add    $0x8,%rsp
  4038a9:	c3                   	retq   
  4038aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 */
bool_t
reservation_updatePrice (TM_ARGDECL  reservation_t* reservationPtr, long newPrice)
{
    if (newPrice < 0) {
        return FALSE;
  4038b0:	31 c0                	xor    %eax,%eax
    TM_SHARED_WRITE(reservationPtr->price, newPrice);

    CHECK_RESERVATION(reservationPtr);

    return TRUE;
}
  4038b2:	48 83 c4 08          	add    $0x8,%rsp
  4038b6:	c3                   	retq   
    if (numTotal < 0) {
        TM_RESTART();
    }

    if ((numUsed + numFree) != numTotal) {
        TM_RESTART();
  4038b7:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4038bc:	ba a1 00 00 00       	mov    $0xa1,%edx
  4038c1:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4038c6:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4038cb:	e8 80 d3 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }

    long numTotal = (long)TM_SHARED_READ(reservationPtr->numTotal);
    if (numTotal < 0) {
        TM_RESTART();
  4038d0:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4038d5:	ba 9d 00 00 00       	mov    $0x9d,%edx
  4038da:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4038df:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4038e4:	e8 67 d3 ff ff       	callq  400c50 <__assert_fail@plt>
        TM_RESTART();
    }
    
    long numFree = (long)TM_SHARED_READ(reservationPtr->numFree);
    if (numFree < 0) {
        TM_RESTART();
  4038e9:	b9 d0 8e 40 00       	mov    $0x408ed0,%ecx
  4038ee:	ba 98 00 00 00       	mov    $0x98,%edx
  4038f3:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  4038f8:	bf f9 8d 40 00       	mov    $0x408df9,%edi
  4038fd:	e8 4e d3 ff ff       	callq  400c50 <__assert_fail@plt>
  403902:	e8 9d d4 ff ff       	callq  400da4 <checkReservation.part.0>
  403907:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40390e:	00 00 

0000000000403910 <reservation_updatePrice_seq>:
}


bool_t
reservation_updatePrice_seq (reservation_t* reservationPtr, long newPrice)
{
  403910:	48 83 ec 08          	sub    $0x8,%rsp
    if (newPrice < 0) {
  403914:	48 85 f6             	test   %rsi,%rsi
  403917:	78 37                	js     403950 <reservation_updatePrice_seq+0x40>


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  403919:	48 8b 57 08          	mov    0x8(%rdi),%rdx
{
    if (newPrice < 0) {
        return FALSE;
    }

    reservationPtr->price = newPrice;
  40391d:	48 89 77 20          	mov    %rsi,0x20(%rdi)


static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
  403921:	48 85 d2             	test   %rdx,%rdx
  403924:	78 7c                	js     4039a2 <reservation_updatePrice_seq+0x92>
    assert(reservationPtr->numFree >= 0);
  403926:	48 8b 47 10          	mov    0x10(%rdi),%rax
  40392a:	48 85 c0             	test   %rax,%rax
  40392d:	78 5a                	js     403989 <reservation_updatePrice_seq+0x79>
    assert(reservationPtr->numTotal >= 0);
  40392f:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
  403933:	48 85 c9             	test   %rcx,%rcx
  403936:	78 38                	js     403970 <reservation_updatePrice_seq+0x60>
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  403938:	48 01 d0             	add    %rdx,%rax
  40393b:	48 39 c1             	cmp    %rax,%rcx
  40393e:	75 17                	jne    403957 <reservation_updatePrice_seq+0x47>

    reservationPtr->price = newPrice;

    checkReservation_seq(reservationPtr);

    return TRUE;
  403940:	b8 01 00 00 00       	mov    $0x1,%eax
}
  403945:	48 83 c4 08          	add    $0x8,%rsp
  403949:	c3                   	retq   
  40394a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

bool_t
reservation_updatePrice_seq (reservation_t* reservationPtr, long newPrice)
{
    if (newPrice < 0) {
        return FALSE;
  403950:	31 c0                	xor    %eax,%eax
    reservationPtr->price = newPrice;

    checkReservation_seq(reservationPtr);

    return TRUE;
}
  403952:	48 83 c4 08          	add    $0x8,%rsp
  403956:	c3                   	retq   
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
    assert((reservationPtr->numUsed + reservationPtr->numFree) ==
  403957:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40395c:	ba b5 00 00 00       	mov    $0xb5,%edx
  403961:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403966:	bf 58 8e 40 00       	mov    $0x408e58,%edi
  40396b:	e8 e0 d2 ff ff       	callq  400c50 <__assert_fail@plt>
static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
    assert(reservationPtr->numTotal >= 0);
  403970:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  403975:	ba b3 00 00 00       	mov    $0xb3,%edx
  40397a:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  40397f:	bf 33 8e 40 00       	mov    $0x408e33,%edi
  403984:	e8 c7 d2 ff ff       	callq  400c50 <__assert_fail@plt>

static void
checkReservation_seq (reservation_t* reservationPtr)
{
    assert(reservationPtr->numUsed >= 0);
    assert(reservationPtr->numFree >= 0);
  403989:	b9 b0 8e 40 00       	mov    $0x408eb0,%ecx
  40398e:	ba b2 00 00 00       	mov    $0xb2,%edx
  403993:	be d0 8d 40 00       	mov    $0x408dd0,%esi
  403998:	bf fb 8d 40 00       	mov    $0x408dfb,%edi
  40399d:	e8 ae d2 ff ff       	callq  400c50 <__assert_fail@plt>
  4039a2:	e8 17 d4 ff ff       	callq  400dbe <checkReservation_seq.part.1>
  4039a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4039ae:	00 00 

00000000004039b0 <reservation_compare>:
 * =============================================================================
 */
long
reservation_compare (reservation_t* aPtr, reservation_t* bPtr)
{
    return (aPtr->id - bPtr->id);
  4039b0:	48 8b 07             	mov    (%rdi),%rax
  4039b3:	48 2b 06             	sub    (%rsi),%rax
}
  4039b6:	c3                   	retq   
  4039b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4039be:	00 00 

00000000004039c0 <reservation_hash>:
 */
ulong_t
reservation_hash (reservation_t* reservationPtr)
{
    /* Separate tables for cars, flights, etc, so no need to use 'type' */
    return (ulong_t)reservationPtr->id;
  4039c0:	48 8b 07             	mov    (%rdi),%rax
}
  4039c3:	c3                   	retq   
  4039c4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4039cb:	00 00 00 00 00 

00000000004039d0 <reservation_free>:
 * =============================================================================
 */
void
reservation_free (TM_ARGDECL  reservation_t* reservationPtr)
{
    TM_FREE(reservationPtr);
  4039d0:	e9 db d2 ff ff       	jmpq   400cb0 <free@plt>
  4039d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4039dc:	00 00 00 
  4039df:	90                   	nop

00000000004039e0 <addCustomer>:
 * =============================================================================
 */
static bool_t
addCustomer (manager_t* managerPtr, long id, long num, long price)
{
    return manager_addCustomer_seq(managerPtr, id);
  4039e0:	e9 db f2 ff ff       	jmpq   402cc0 <manager_addCustomer_seq>
  4039e5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  4039ec:	00 00 00 00 

00000000004039f0 <checkTables>:
 * -- dependent on tasks generated for clients in initializeClients()
 * =============================================================================
 */
void
checkTables (manager_t* managerPtr)
{
  4039f0:	41 56                	push   %r14
  4039f2:	49 89 fe             	mov    %rdi,%r14
  4039f5:	41 55                	push   %r13
  4039f7:	41 54                	push   %r12
  4039f9:	55                   	push   %rbp
  4039fa:	53                   	push   %rbx
  4039fb:	48 83 ec 40          	sub    $0x40,%rsp
    long i;
    long numRelation = (long)global_params[PARAM_RELATIONS];
    MAP_T* customerTablePtr = managerPtr->customerTablePtr;
    MAP_T* tables[] = {
  4039ff:	48 8b 07             	mov    (%rdi),%rax
void
checkTables (manager_t* managerPtr)
{
    long i;
    long numRelation = (long)global_params[PARAM_RELATIONS];
    MAP_T* customerTablePtr = managerPtr->customerTablePtr;
  403a02:	48 8b 6f 18          	mov    0x18(%rdi),%rbp
 */
void
checkTables (manager_t* managerPtr)
{
    long i;
    long numRelation = (long)global_params[PARAM_RELATIONS];
  403a06:	f2 0f 10 05 a2 8d 20 	movsd  0x208da2(%rip),%xmm0        # 60c7b0 <global_params+0x390>
  403a0d:	00 
        managerPtr->carTablePtr,
        managerPtr->flightTablePtr,
        managerPtr->roomTablePtr,
    };
    long numTable = sizeof(tables) / sizeof(tables[0]);
    bool_t (*manager_add[])(manager_t*, long, long, long) = {
  403a0e:	48 c7 44 24 20 f0 24 	movq   $0x4024f0,0x20(%rsp)
  403a15:	40 00 
  403a17:	48 c7 44 24 28 c0 2a 	movq   $0x402ac0,0x28(%rsp)
  403a1e:	40 00 
  403a20:	48 c7 44 24 30 d0 27 	movq   $0x4027d0,0x30(%rsp)
  403a27:	40 00 
checkTables (manager_t* managerPtr)
{
    long i;
    long numRelation = (long)global_params[PARAM_RELATIONS];
    MAP_T* customerTablePtr = managerPtr->customerTablePtr;
    MAP_T* tables[] = {
  403a29:	48 89 04 24          	mov    %rax,(%rsp)
  403a2d:	48 8b 47 10          	mov    0x10(%rdi),%rax
 */
void
checkTables (manager_t* managerPtr)
{
    long i;
    long numRelation = (long)global_params[PARAM_RELATIONS];
  403a31:	f2 4c 0f 2c e0       	cvttsd2si %xmm0,%r12
    MAP_T* customerTablePtr = managerPtr->customerTablePtr;
    MAP_T* tables[] = {
  403a36:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  403a3b:	48 8b 47 08          	mov    0x8(%rdi),%rax
        &manager_addFlight_seq,
        &manager_addRoom_seq
    };
    long t;

    printf("Checking tables... ");
  403a3f:	bf e1 8e 40 00       	mov    $0x408ee1,%edi
checkTables (manager_t* managerPtr)
{
    long i;
    long numRelation = (long)global_params[PARAM_RELATIONS];
    MAP_T* customerTablePtr = managerPtr->customerTablePtr;
    MAP_T* tables[] = {
  403a44:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
        &manager_addFlight_seq,
        &manager_addRoom_seq
    };
    long t;

    printf("Checking tables... ");
  403a49:	31 c0                	xor    %eax,%eax
  403a4b:	e8 b0 d1 ff ff       	callq  400c00 <printf@plt>
    fflush(stdout);
  403a50:	48 8b 3d d9 88 20 00 	mov    0x2088d9(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
  403a57:	e8 04 d3 ff ff       	callq  400d60 <fflush@plt>

    /* Check for unique customer IDs */
    long percentQuery = (long)global_params[PARAM_QUERIES];
  403a5c:	f2 0f 10 0d 44 8d 20 	movsd  0x208d44(%rip),%xmm1        # 60c7a8 <global_params+0x388>
  403a63:	00 
  403a64:	f2 48 0f 2c c1       	cvttsd2si %xmm1,%rax
    long queryRange = (long)((double)percentQuery / 100.0 * (double)numRelation + 0.5);
  403a69:	f2 49 0f 2a cc       	cvtsi2sd %r12,%xmm1
  403a6e:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  403a73:	f2 0f 5e 05 25 59 00 	divsd  0x5925(%rip),%xmm0        # 4093a0 <__PRETTY_FUNCTION__.3923+0xe>
  403a7a:	00 
  403a7b:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  403a7f:	f2 0f 58 05 21 59 00 	addsd  0x5921(%rip),%xmm0        # 4093a8 <__PRETTY_FUNCTION__.3923+0x16>
  403a86:	00 
  403a87:	f2 4c 0f 2c e8       	cvttsd2si %xmm0,%r13
    long maxCustomerId = queryRange + 1;
  403a8c:	49 83 c5 01          	add    $0x1,%r13
    for (i = 1; i <= maxCustomerId; i++) {
  403a90:	4d 85 ed             	test   %r13,%r13
  403a93:	7e 63                	jle    403af8 <checkTables+0x108>
  403a95:	bb 01 00 00 00       	mov    $0x1,%ebx
  403a9a:	eb 0d                	jmp    403aa9 <checkTables+0xb9>
  403a9c:	0f 1f 40 00          	nopl   0x0(%rax)
  403aa0:	48 83 c3 01          	add    $0x1,%rbx
  403aa4:	49 39 dd             	cmp    %rbx,%r13
  403aa7:	7c 4f                	jl     403af8 <checkTables+0x108>
        if (MAP_FIND(customerTablePtr, i)) {
  403aa9:	48 89 de             	mov    %rbx,%rsi
  403aac:	48 89 ef             	mov    %rbp,%rdi
  403aaf:	e8 0c 46 00 00       	callq  4080c0 <rbtree_get>
  403ab4:	48 85 c0             	test   %rax,%rax
  403ab7:	74 e7                	je     403aa0 <checkTables+0xb0>
            if (MAP_REMOVE(customerTablePtr, i)) {
  403ab9:	48 89 de             	mov    %rbx,%rsi
  403abc:	48 89 ef             	mov    %rbp,%rdi
  403abf:	e8 bc 40 00 00       	callq  407b80 <rbtree_delete>
  403ac4:	48 85 c0             	test   %rax,%rax
  403ac7:	74 d7                	je     403aa0 <checkTables+0xb0>
                assert(!MAP_FIND(customerTablePtr, i));
  403ac9:	48 89 de             	mov    %rbx,%rsi
  403acc:	48 89 ef             	mov    %rbp,%rdi
  403acf:	e8 ec 45 00 00       	callq  4080c0 <rbtree_get>
  403ad4:	48 85 c0             	test   %rax,%rax
  403ad7:	74 c7                	je     403aa0 <checkTables+0xb0>
  403ad9:	b9 92 93 40 00       	mov    $0x409392,%ecx
  403ade:	ba 6e 01 00 00       	mov    $0x16e,%edx
  403ae3:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  403ae8:	bf 10 90 40 00       	mov    $0x409010,%edi
  403aed:	e8 5e d1 ff ff       	callq  400c50 <__assert_fail@plt>
  403af2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    /* Check for unique customer IDs */
    long percentQuery = (long)global_params[PARAM_QUERIES];
    long queryRange = (long)((double)percentQuery / 100.0 * (double)numRelation + 0.5);
    long maxCustomerId = queryRange + 1;
    for (i = 1; i <= maxCustomerId; i++) {
  403af8:	45 31 ed             	xor    %r13d,%r13d
    }

    /* Check reservation tables for consistency and unique ids */
    for (t = 0; t < numTable; t++) {
        MAP_T* tablePtr = tables[t];
        for (i = 1; i <= numRelation; i++) {
  403afb:	4d 85 e4             	test   %r12,%r12
        }
    }

    /* Check reservation tables for consistency and unique ids */
    for (t = 0; t < numTable; t++) {
        MAP_T* tablePtr = tables[t];
  403afe:	4a 8b 2c ec          	mov    (%rsp,%r13,8),%rbp
        for (i = 1; i <= numRelation; i++) {
  403b02:	bb 01 00 00 00       	mov    $0x1,%ebx
  403b07:	7f 10                	jg     403b19 <checkTables+0x129>
  403b09:	eb 75                	jmp    403b80 <checkTables+0x190>
  403b0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  403b10:	48 83 c3 01          	add    $0x1,%rbx
  403b14:	49 39 dc             	cmp    %rbx,%r12
  403b17:	7c 67                	jl     403b80 <checkTables+0x190>
            if (MAP_FIND(tablePtr, i)) {
  403b19:	48 89 de             	mov    %rbx,%rsi
  403b1c:	48 89 ef             	mov    %rbp,%rdi
  403b1f:	e8 9c 45 00 00       	callq  4080c0 <rbtree_get>
  403b24:	48 85 c0             	test   %rax,%rax
  403b27:	74 e7                	je     403b10 <checkTables+0x120>
                assert(manager_add[t](managerPtr, i, 0, 0)); /* validate entry */
  403b29:	31 c9                	xor    %ecx,%ecx
  403b2b:	31 d2                	xor    %edx,%edx
  403b2d:	48 89 de             	mov    %rbx,%rsi
  403b30:	4c 89 f7             	mov    %r14,%rdi
  403b33:	42 ff 54 ec 20       	callq  *0x20(%rsp,%r13,8)
  403b38:	48 85 c0             	test   %rax,%rax
  403b3b:	74 73                	je     403bb0 <checkTables+0x1c0>
                if (MAP_REMOVE(tablePtr, i)) {
  403b3d:	48 89 de             	mov    %rbx,%rsi
  403b40:	48 89 ef             	mov    %rbp,%rdi
  403b43:	e8 38 40 00 00       	callq  407b80 <rbtree_delete>
  403b48:	48 85 c0             	test   %rax,%rax
  403b4b:	74 c3                	je     403b10 <checkTables+0x120>
                    assert(!MAP_REMOVE(tablePtr, i));
  403b4d:	48 89 de             	mov    %rbx,%rsi
  403b50:	48 89 ef             	mov    %rbp,%rdi
  403b53:	e8 28 40 00 00       	callq  407b80 <rbtree_delete>
  403b58:	48 85 c0             	test   %rax,%rax
  403b5b:	74 b3                	je     403b10 <checkTables+0x120>
  403b5d:	b9 92 93 40 00       	mov    $0x409392,%ecx
  403b62:	ba 7a 01 00 00       	mov    $0x17a,%edx
  403b67:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  403b6c:	bf 68 90 40 00       	mov    $0x409068,%edi
  403b71:	e8 da d0 ff ff       	callq  400c50 <__assert_fail@plt>
  403b76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  403b7d:	00 00 00 
            }
        }
    }

    /* Check reservation tables for consistency and unique ids */
    for (t = 0; t < numTable; t++) {
  403b80:	49 83 c5 01          	add    $0x1,%r13
  403b84:	49 83 fd 03          	cmp    $0x3,%r13
  403b88:	0f 85 6d ff ff ff    	jne    403afb <checkTables+0x10b>
                }
            }
        }
    }

    puts("done.");
  403b8e:	bf 00 8f 40 00       	mov    $0x408f00,%edi
  403b93:	e8 88 d0 ff ff       	callq  400c20 <puts@plt>
    fflush(stdout);
  403b98:	48 8b 3d 91 87 20 00 	mov    0x208791(%rip),%rdi        # 60c330 <stdout@@GLIBC_2.2.5>
}
  403b9f:	48 83 c4 40          	add    $0x40,%rsp
  403ba3:	5b                   	pop    %rbx
  403ba4:	5d                   	pop    %rbp
  403ba5:	41 5c                	pop    %r12
  403ba7:	41 5d                	pop    %r13
  403ba9:	41 5e                	pop    %r14
            }
        }
    }

    puts("done.");
    fflush(stdout);
  403bab:	e9 b0 d1 ff ff       	jmpq   400d60 <fflush@plt>
    /* Check reservation tables for consistency and unique ids */
    for (t = 0; t < numTable; t++) {
        MAP_T* tablePtr = tables[t];
        for (i = 1; i <= numRelation; i++) {
            if (MAP_FIND(tablePtr, i)) {
                assert(manager_add[t](managerPtr, i, 0, 0)); /* validate entry */
  403bb0:	b9 92 93 40 00       	mov    $0x409392,%ecx
  403bb5:	ba 78 01 00 00       	mov    $0x178,%edx
  403bba:	be f5 8e 40 00       	mov    $0x408ef5,%esi
  403bbf:	bf 40 90 40 00       	mov    $0x409040,%edi
  403bc4:	e8 87 d0 ff ff       	callq  400c50 <__assert_fail@plt>
  403bc9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000403bd0 <compareDataPtrAddresses>:
 * -- Default compare function
 * =============================================================================
 */
static long
compareDataPtrAddresses (const void* a, const void* b)
{
  403bd0:	48 89 f8             	mov    %rdi,%rax
    return ((long)a - (long)b);
  403bd3:	48 29 f0             	sub    %rsi,%rax
}
  403bd6:	c3                   	retq   
  403bd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  403bde:	00 00 

0000000000403be0 <TMfreeList>:
 * TMfreeList
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
  403be0:	41 57                	push   %r15
  403be2:	41 56                	push   %r14
  403be4:	41 55                	push   %r13
  403be6:	41 54                	push   %r12
  403be8:	55                   	push   %rbp
  403be9:	53                   	push   %rbx
  403bea:	48 89 fb             	mov    %rdi,%rbx
  403bed:	48 83 ec 28          	sub    $0x28,%rsp
    if (nodePtr != NULL) {
  403bf1:	48 85 ff             	test   %rdi,%rdi
  403bf4:	0f 84 e6 00 00 00    	je     403ce0 <TMfreeList+0x100>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403bfa:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403bfe:	48 85 ed             	test   %rbp,%rbp
  403c01:	0f 84 b9 00 00 00    	je     403cc0 <TMfreeList+0xe0>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c07:	4c 8b 65 08          	mov    0x8(%rbp),%r12
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c0b:	4d 85 e4             	test   %r12,%r12
  403c0e:	0f 84 a4 00 00 00    	je     403cb8 <TMfreeList+0xd8>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c14:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c19:	4d 85 ed             	test   %r13,%r13
  403c1c:	0f 84 8e 00 00 00    	je     403cb0 <TMfreeList+0xd0>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c22:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c26:	4d 85 f6             	test   %r14,%r14
  403c29:	74 7d                	je     403ca8 <TMfreeList+0xc8>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c2b:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c2f:	4d 85 ff             	test   %r15,%r15
  403c32:	74 6c                	je     403ca0 <TMfreeList+0xc0>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c34:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c38:	48 85 c0             	test   %rax,%rax
  403c3b:	74 5b                	je     403c98 <TMfreeList+0xb8>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c3d:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c41:	48 85 d2             	test   %rdx,%rdx
  403c44:	74 4a                	je     403c90 <TMfreeList+0xb0>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  403c46:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403c4a:	48 85 c9             	test   %rcx,%rcx
  403c4d:	74 2f                	je     403c7e <TMfreeList+0x9e>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
        TMfreeList(TM_ARG  nextPtr);
  403c4f:	48 8b 79 08          	mov    0x8(%rcx),%rdi
  403c53:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  403c58:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  403c5d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  403c62:	e8 79 ff ff ff       	callq  403be0 <TMfreeList>
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  list_node_t* nodePtr)
{
    TM_FREE(nodePtr);
  403c67:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  403c6c:	48 89 cf             	mov    %rcx,%rdi
  403c6f:	e8 3c d0 ff ff       	callq  400cb0 <free@plt>
  403c74:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  403c79:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403c7e:	48 89 d7             	mov    %rdx,%rdi
  403c81:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  403c86:	e8 25 d0 ff ff       	callq  400cb0 <free@plt>
  403c8b:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403c90:	48 89 c7             	mov    %rax,%rdi
  403c93:	e8 18 d0 ff ff       	callq  400cb0 <free@plt>
  403c98:	4c 89 ff             	mov    %r15,%rdi
  403c9b:	e8 10 d0 ff ff       	callq  400cb0 <free@plt>
  403ca0:	4c 89 f7             	mov    %r14,%rdi
  403ca3:	e8 08 d0 ff ff       	callq  400cb0 <free@plt>
  403ca8:	4c 89 ef             	mov    %r13,%rdi
  403cab:	e8 00 d0 ff ff       	callq  400cb0 <free@plt>
  403cb0:	4c 89 e7             	mov    %r12,%rdi
  403cb3:	e8 f8 cf ff ff       	callq  400cb0 <free@plt>
  403cb8:	48 89 ef             	mov    %rbp,%rdi
  403cbb:	e8 f0 cf ff ff       	callq  400cb0 <free@plt>
    if (nodePtr != NULL) {
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
        TMfreeList(TM_ARG  nextPtr);
        TMfreeNode(TM_ARG  nodePtr);
    }
}
  403cc0:	48 83 c4 28          	add    $0x28,%rsp
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  list_node_t* nodePtr)
{
    TM_FREE(nodePtr);
  403cc4:	48 89 df             	mov    %rbx,%rdi
    if (nodePtr != NULL) {
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
        TMfreeList(TM_ARG  nextPtr);
        TMfreeNode(TM_ARG  nodePtr);
    }
}
  403cc7:	5b                   	pop    %rbx
  403cc8:	5d                   	pop    %rbp
  403cc9:	41 5c                	pop    %r12
  403ccb:	41 5d                	pop    %r13
  403ccd:	41 5e                	pop    %r14
  403ccf:	41 5f                	pop    %r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  list_node_t* nodePtr)
{
    TM_FREE(nodePtr);
  403cd1:	e9 da cf ff ff       	jmpq   400cb0 <free@plt>
  403cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  403cdd:	00 00 00 
    if (nodePtr != NULL) {
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
        TMfreeList(TM_ARG  nextPtr);
        TMfreeNode(TM_ARG  nodePtr);
    }
}
  403ce0:	48 83 c4 28          	add    $0x28,%rsp
  403ce4:	5b                   	pop    %rbx
  403ce5:	5d                   	pop    %rbp
  403ce6:	41 5c                	pop    %r12
  403ce8:	41 5d                	pop    %r13
  403cea:	41 5e                	pop    %r14
  403cec:	41 5f                	pop    %r15
  403cee:	c3                   	retq   
  403cef:	90                   	nop

0000000000403cf0 <freeList>:
 * freeList
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
  403cf0:	41 57                	push   %r15
  403cf2:	41 56                	push   %r14
  403cf4:	41 55                	push   %r13
  403cf6:	41 54                	push   %r12
  403cf8:	55                   	push   %rbp
  403cf9:	53                   	push   %rbx
  403cfa:	48 89 fb             	mov    %rdi,%rbx
  403cfd:	48 83 ec 28          	sub    $0x28,%rsp
    if (nodePtr != NULL) {
  403d01:	48 85 ff             	test   %rdi,%rdi
  403d04:	0f 84 e6 00 00 00    	je     403df0 <freeList+0x100>
        freeList(nodePtr->nextPtr);
  403d0a:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d0e:	48 85 ed             	test   %rbp,%rbp
  403d11:	0f 84 b9 00 00 00    	je     403dd0 <freeList+0xe0>
        freeList(nodePtr->nextPtr);
  403d17:	4c 8b 65 08          	mov    0x8(%rbp),%r12
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d1b:	4d 85 e4             	test   %r12,%r12
  403d1e:	0f 84 a4 00 00 00    	je     403dc8 <freeList+0xd8>
        freeList(nodePtr->nextPtr);
  403d24:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d29:	4d 85 ed             	test   %r13,%r13
  403d2c:	0f 84 8e 00 00 00    	je     403dc0 <freeList+0xd0>
        freeList(nodePtr->nextPtr);
  403d32:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d36:	4d 85 f6             	test   %r14,%r14
  403d39:	74 7d                	je     403db8 <freeList+0xc8>
        freeList(nodePtr->nextPtr);
  403d3b:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d3f:	4d 85 ff             	test   %r15,%r15
  403d42:	74 6c                	je     403db0 <freeList+0xc0>
        freeList(nodePtr->nextPtr);
  403d44:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d48:	48 85 c0             	test   %rax,%rax
  403d4b:	74 5b                	je     403da8 <freeList+0xb8>
        freeList(nodePtr->nextPtr);
  403d4d:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d51:	48 85 d2             	test   %rdx,%rdx
  403d54:	74 4a                	je     403da0 <freeList+0xb0>
        freeList(nodePtr->nextPtr);
  403d56:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403d5a:	48 85 c9             	test   %rcx,%rcx
  403d5d:	74 2f                	je     403d8e <freeList+0x9e>
        freeList(nodePtr->nextPtr);
  403d5f:	48 8b 79 08          	mov    0x8(%rcx),%rdi
  403d63:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  403d68:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  403d6d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  403d72:	e8 79 ff ff ff       	callq  403cf0 <freeList>
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  403d77:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  403d7c:	48 89 cf             	mov    %rcx,%rdi
  403d7f:	e8 2c cf ff ff       	callq  400cb0 <free@plt>
  403d84:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  403d89:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403d8e:	48 89 d7             	mov    %rdx,%rdi
  403d91:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  403d96:	e8 15 cf ff ff       	callq  400cb0 <free@plt>
  403d9b:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403da0:	48 89 c7             	mov    %rax,%rdi
  403da3:	e8 08 cf ff ff       	callq  400cb0 <free@plt>
  403da8:	4c 89 ff             	mov    %r15,%rdi
  403dab:	e8 00 cf ff ff       	callq  400cb0 <free@plt>
  403db0:	4c 89 f7             	mov    %r14,%rdi
  403db3:	e8 f8 ce ff ff       	callq  400cb0 <free@plt>
  403db8:	4c 89 ef             	mov    %r13,%rdi
  403dbb:	e8 f0 ce ff ff       	callq  400cb0 <free@plt>
  403dc0:	4c 89 e7             	mov    %r12,%rdi
  403dc3:	e8 e8 ce ff ff       	callq  400cb0 <free@plt>
  403dc8:	48 89 ef             	mov    %rbp,%rdi
  403dcb:	e8 e0 ce ff ff       	callq  400cb0 <free@plt>
{
    if (nodePtr != NULL) {
        freeList(nodePtr->nextPtr);
        freeNode(nodePtr);
    }
}
  403dd0:	48 83 c4 28          	add    $0x28,%rsp
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  403dd4:	48 89 df             	mov    %rbx,%rdi
{
    if (nodePtr != NULL) {
        freeList(nodePtr->nextPtr);
        freeNode(nodePtr);
    }
}
  403dd7:	5b                   	pop    %rbx
  403dd8:	5d                   	pop    %rbp
  403dd9:	41 5c                	pop    %r12
  403ddb:	41 5d                	pop    %r13
  403ddd:	41 5e                	pop    %r14
  403ddf:	41 5f                	pop    %r15
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  403de1:	e9 ca ce ff ff       	jmpq   400cb0 <free@plt>
  403de6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  403ded:	00 00 00 
{
    if (nodePtr != NULL) {
        freeList(nodePtr->nextPtr);
        freeNode(nodePtr);
    }
}
  403df0:	48 83 c4 28          	add    $0x28,%rsp
  403df4:	5b                   	pop    %rbx
  403df5:	5d                   	pop    %rbp
  403df6:	41 5c                	pop    %r12
  403df8:	41 5d                	pop    %r13
  403dfa:	41 5e                	pop    %r14
  403dfc:	41 5f                	pop    %r15
  403dfe:	c3                   	retq   
  403dff:	90                   	nop

0000000000403e00 <PfreeList>:
 * PfreeList
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
  403e00:	41 57                	push   %r15
  403e02:	41 56                	push   %r14
  403e04:	41 55                	push   %r13
  403e06:	41 54                	push   %r12
  403e08:	55                   	push   %rbp
  403e09:	53                   	push   %rbx
  403e0a:	48 89 fb             	mov    %rdi,%rbx
  403e0d:	48 83 ec 28          	sub    $0x28,%rsp
    if (nodePtr != NULL) {
  403e11:	48 85 ff             	test   %rdi,%rdi
  403e14:	0f 84 e6 00 00 00    	je     403f00 <PfreeList+0x100>
        PfreeList(nodePtr->nextPtr);
  403e1a:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e1e:	48 85 ed             	test   %rbp,%rbp
  403e21:	0f 84 b9 00 00 00    	je     403ee0 <PfreeList+0xe0>
        PfreeList(nodePtr->nextPtr);
  403e27:	4c 8b 65 08          	mov    0x8(%rbp),%r12
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e2b:	4d 85 e4             	test   %r12,%r12
  403e2e:	0f 84 a4 00 00 00    	je     403ed8 <PfreeList+0xd8>
        PfreeList(nodePtr->nextPtr);
  403e34:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e39:	4d 85 ed             	test   %r13,%r13
  403e3c:	0f 84 8e 00 00 00    	je     403ed0 <PfreeList+0xd0>
        PfreeList(nodePtr->nextPtr);
  403e42:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e46:	4d 85 f6             	test   %r14,%r14
  403e49:	74 7d                	je     403ec8 <PfreeList+0xc8>
        PfreeList(nodePtr->nextPtr);
  403e4b:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e4f:	4d 85 ff             	test   %r15,%r15
  403e52:	74 6c                	je     403ec0 <PfreeList+0xc0>
        PfreeList(nodePtr->nextPtr);
  403e54:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e58:	48 85 c0             	test   %rax,%rax
  403e5b:	74 5b                	je     403eb8 <PfreeList+0xb8>
        PfreeList(nodePtr->nextPtr);
  403e5d:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e61:	48 85 d2             	test   %rdx,%rdx
  403e64:	74 4a                	je     403eb0 <PfreeList+0xb0>
        PfreeList(nodePtr->nextPtr);
  403e66:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  403e6a:	48 85 c9             	test   %rcx,%rcx
  403e6d:	74 2f                	je     403e9e <PfreeList+0x9e>
        PfreeList(nodePtr->nextPtr);
  403e6f:	48 8b 79 08          	mov    0x8(%rcx),%rdi
  403e73:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  403e78:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  403e7d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  403e82:	e8 79 ff ff ff       	callq  403e00 <PfreeList>
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  403e87:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  403e8c:	48 89 cf             	mov    %rcx,%rdi
  403e8f:	e8 1c ce ff ff       	callq  400cb0 <free@plt>
  403e94:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  403e99:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  403e9e:	48 89 d7             	mov    %rdx,%rdi
  403ea1:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  403ea6:	e8 05 ce ff ff       	callq  400cb0 <free@plt>
  403eab:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  403eb0:	48 89 c7             	mov    %rax,%rdi
  403eb3:	e8 f8 cd ff ff       	callq  400cb0 <free@plt>
  403eb8:	4c 89 ff             	mov    %r15,%rdi
  403ebb:	e8 f0 cd ff ff       	callq  400cb0 <free@plt>
  403ec0:	4c 89 f7             	mov    %r14,%rdi
  403ec3:	e8 e8 cd ff ff       	callq  400cb0 <free@plt>
  403ec8:	4c 89 ef             	mov    %r13,%rdi
  403ecb:	e8 e0 cd ff ff       	callq  400cb0 <free@plt>
  403ed0:	4c 89 e7             	mov    %r12,%rdi
  403ed3:	e8 d8 cd ff ff       	callq  400cb0 <free@plt>
  403ed8:	48 89 ef             	mov    %rbp,%rdi
  403edb:	e8 d0 cd ff ff       	callq  400cb0 <free@plt>
{
    if (nodePtr != NULL) {
        PfreeList(nodePtr->nextPtr);
        PfreeNode(nodePtr);
    }
}
  403ee0:	48 83 c4 28          	add    $0x28,%rsp
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  403ee4:	48 89 df             	mov    %rbx,%rdi
{
    if (nodePtr != NULL) {
        PfreeList(nodePtr->nextPtr);
        PfreeNode(nodePtr);
    }
}
  403ee7:	5b                   	pop    %rbx
  403ee8:	5d                   	pop    %rbp
  403ee9:	41 5c                	pop    %r12
  403eeb:	41 5d                	pop    %r13
  403eed:	41 5e                	pop    %r14
  403eef:	41 5f                	pop    %r15
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  403ef1:	e9 ba cd ff ff       	jmpq   400cb0 <free@plt>
  403ef6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  403efd:	00 00 00 
{
    if (nodePtr != NULL) {
        PfreeList(nodePtr->nextPtr);
        PfreeNode(nodePtr);
    }
}
  403f00:	48 83 c4 28          	add    $0x28,%rsp
  403f04:	5b                   	pop    %rbx
  403f05:	5d                   	pop    %rbp
  403f06:	41 5c                	pop    %r12
  403f08:	41 5d                	pop    %r13
  403f0a:	41 5e                	pop    %r14
  403f0c:	41 5f                	pop    %r15
  403f0e:	c3                   	retq   
  403f0f:	90                   	nop

0000000000403f10 <list_iter_reset>:
 * =============================================================================
 */
void
list_iter_reset (list_iter_t* itPtr, list_t* listPtr)
{
    *itPtr = &(listPtr->head);
  403f10:	48 89 37             	mov    %rsi,(%rdi)
  403f13:	c3                   	retq   
  403f14:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  403f1b:	00 00 00 00 00 

0000000000403f20 <TMlist_iter_reset>:
 * =============================================================================
 */
void
TMlist_iter_reset (TM_ARGDECL  list_iter_t* itPtr, list_t* listPtr)
{
    TM_LOCAL_WRITE_P(*itPtr, &(listPtr->head));
  403f20:	48 89 37             	mov    %rsi,(%rdi)
  403f23:	c3                   	retq   
  403f24:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  403f2b:	00 00 00 00 00 

0000000000403f30 <list_iter_hasNext>:
 * =============================================================================
 */
bool_t
list_iter_hasNext (list_iter_t* itPtr, list_t* listPtr)
{
    return (((*itPtr)->nextPtr != NULL) ? TRUE : FALSE);
  403f30:	48 8b 07             	mov    (%rdi),%rax
  403f33:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
  403f38:	0f 95 c0             	setne  %al
  403f3b:	0f b6 c0             	movzbl %al,%eax
}
  403f3e:	c3                   	retq   
  403f3f:	90                   	nop

0000000000403f40 <TMlist_iter_hasNext>:
 * =============================================================================
 */
bool_t
TMlist_iter_hasNext (TM_ARGDECL  list_iter_t* itPtr, list_t* listPtr)
{
    list_iter_t next = (list_iter_t)TM_SHARED_READ_P((*itPtr)->nextPtr);
  403f40:	48 8b 07             	mov    (%rdi),%rax

    return ((next != NULL) ? TRUE : FALSE);
  403f43:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
  403f48:	0f 95 c0             	setne  %al
  403f4b:	0f b6 c0             	movzbl %al,%eax
}
  403f4e:	c3                   	retq   
  403f4f:	90                   	nop

0000000000403f50 <list_iter_next>:
 * =============================================================================
 */
void*
list_iter_next (list_iter_t* itPtr, list_t* listPtr)
{
    *itPtr = (*itPtr)->nextPtr;
  403f50:	48 8b 07             	mov    (%rdi),%rax
  403f53:	48 8b 40 08          	mov    0x8(%rax),%rax
  403f57:	48 89 07             	mov    %rax,(%rdi)

    return (*itPtr)->dataPtr;
  403f5a:	48 8b 00             	mov    (%rax),%rax
}
  403f5d:	c3                   	retq   
  403f5e:	66 90                	xchg   %ax,%ax

0000000000403f60 <TMlist_iter_next>:
 * =============================================================================
 */
void*
TMlist_iter_next (TM_ARGDECL  list_iter_t* itPtr, list_t* listPtr)
{
    list_iter_t next = (list_iter_t)TM_SHARED_READ_P((*itPtr)->nextPtr);
  403f60:	48 8b 07             	mov    (%rdi),%rax
  403f63:	48 8b 40 08          	mov    0x8(%rax),%rax
    TM_LOCAL_WRITE_P(*itPtr, next);
  403f67:	48 89 07             	mov    %rax,(%rdi)

    return next->dataPtr;
  403f6a:	48 8b 00             	mov    (%rax),%rax
}
  403f6d:	c3                   	retq   
  403f6e:	66 90                	xchg   %ax,%ax

0000000000403f70 <list_alloc>:
 * -- Returns NULL on failure
 * =============================================================================
 */
list_t*
list_alloc (long (*compare)(const void*, const void*))
{
  403f70:	53                   	push   %rbx
  403f71:	48 89 fb             	mov    %rdi,%rbx
    list_t* listPtr = (list_t*)malloc(sizeof(list_t));
  403f74:	bf 20 00 00 00       	mov    $0x20,%edi
  403f79:	e8 02 cd ff ff       	callq  400c80 <malloc@plt>
    if (listPtr == NULL) {
  403f7e:	48 85 c0             	test   %rax,%rax
  403f81:	74 35                	je     403fb8 <list_alloc+0x48>

    listPtr->head.dataPtr = NULL;
    listPtr->head.nextPtr = NULL;
    listPtr->size = 0;

    if (compare == NULL) {
  403f83:	48 85 db             	test   %rbx,%rbx
    list_t* listPtr = (list_t*)malloc(sizeof(list_t));
    if (listPtr == NULL) {
        return NULL;
    }

    listPtr->head.dataPtr = NULL;
  403f86:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    listPtr->head.nextPtr = NULL;
  403f8d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  403f94:	00 
    listPtr->size = 0;
  403f95:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  403f9c:	00 

    if (compare == NULL) {
  403f9d:	74 09                	je     403fa8 <list_alloc+0x38>
        listPtr->compare = &compareDataPtrAddresses; /* default */
    } else {
        listPtr->compare = compare;
  403f9f:	48 89 58 10          	mov    %rbx,0x10(%rax)
    }

    return listPtr;
}
  403fa3:	5b                   	pop    %rbx
  403fa4:	c3                   	retq   
  403fa5:	0f 1f 00             	nopl   (%rax)
    listPtr->head.dataPtr = NULL;
    listPtr->head.nextPtr = NULL;
    listPtr->size = 0;

    if (compare == NULL) {
        listPtr->compare = &compareDataPtrAddresses; /* default */
  403fa8:	48 c7 40 10 d0 3b 40 	movq   $0x403bd0,0x10(%rax)
  403faf:	00 
    } else {
        listPtr->compare = compare;
    }

    return listPtr;
}
  403fb0:	5b                   	pop    %rbx
  403fb1:	c3                   	retq   
  403fb2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
list_t*
list_alloc (long (*compare)(const void*, const void*))
{
    list_t* listPtr = (list_t*)malloc(sizeof(list_t));
    if (listPtr == NULL) {
        return NULL;
  403fb8:	31 c0                	xor    %eax,%eax
    } else {
        listPtr->compare = compare;
    }

    return listPtr;
}
  403fba:	5b                   	pop    %rbx
  403fbb:	c3                   	retq   
  403fbc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000403fc0 <Plist_alloc>:
 * -- Returns NULL on failure
 * =============================================================================
 */
list_t*
Plist_alloc (long (*compare)(const void*, const void*))
{
  403fc0:	53                   	push   %rbx
  403fc1:	48 89 fb             	mov    %rdi,%rbx
    list_t* listPtr = (list_t*)P_MALLOC(sizeof(list_t));
  403fc4:	bf 20 00 00 00       	mov    $0x20,%edi
  403fc9:	e8 b2 cc ff ff       	callq  400c80 <malloc@plt>
    if (listPtr == NULL) {
  403fce:	48 85 c0             	test   %rax,%rax
  403fd1:	74 35                	je     404008 <Plist_alloc+0x48>

    listPtr->head.dataPtr = NULL;
    listPtr->head.nextPtr = NULL;
    listPtr->size = 0;

    if (compare == NULL) {
  403fd3:	48 85 db             	test   %rbx,%rbx
    list_t* listPtr = (list_t*)P_MALLOC(sizeof(list_t));
    if (listPtr == NULL) {
        return NULL;
    }

    listPtr->head.dataPtr = NULL;
  403fd6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    listPtr->head.nextPtr = NULL;
  403fdd:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  403fe4:	00 
    listPtr->size = 0;
  403fe5:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  403fec:	00 

    if (compare == NULL) {
  403fed:	74 09                	je     403ff8 <Plist_alloc+0x38>
        listPtr->compare = &compareDataPtrAddresses; /* default */
    } else {
        listPtr->compare = compare;
  403fef:	48 89 58 10          	mov    %rbx,0x10(%rax)
    }

    return listPtr;
}
  403ff3:	5b                   	pop    %rbx
  403ff4:	c3                   	retq   
  403ff5:	0f 1f 00             	nopl   (%rax)
    listPtr->head.dataPtr = NULL;
    listPtr->head.nextPtr = NULL;
    listPtr->size = 0;

    if (compare == NULL) {
        listPtr->compare = &compareDataPtrAddresses; /* default */
  403ff8:	48 c7 40 10 d0 3b 40 	movq   $0x403bd0,0x10(%rax)
  403fff:	00 
    } else {
        listPtr->compare = compare;
    }

    return listPtr;
}
  404000:	5b                   	pop    %rbx
  404001:	c3                   	retq   
  404002:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
list_t*
Plist_alloc (long (*compare)(const void*, const void*))
{
    list_t* listPtr = (list_t*)P_MALLOC(sizeof(list_t));
    if (listPtr == NULL) {
        return NULL;
  404008:	31 c0                	xor    %eax,%eax
    } else {
        listPtr->compare = compare;
    }

    return listPtr;
}
  40400a:	5b                   	pop    %rbx
  40400b:	c3                   	retq   
  40400c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404010 <TMlist_alloc>:
 * -- Returns NULL on failure
 * =============================================================================
 */
list_t*
TMlist_alloc (TM_ARGDECL  long (*compare)(const void*, const void*))
{
  404010:	53                   	push   %rbx
  404011:	48 89 fb             	mov    %rdi,%rbx
    list_t* listPtr = (list_t*)TM_MALLOC(sizeof(list_t));
  404014:	bf 20 00 00 00       	mov    $0x20,%edi
  404019:	e8 62 cc ff ff       	callq  400c80 <malloc@plt>
    if (listPtr == NULL) {
  40401e:	48 85 c0             	test   %rax,%rax
  404021:	74 35                	je     404058 <TMlist_alloc+0x48>

    listPtr->head.dataPtr = NULL;
    listPtr->head.nextPtr = NULL;
    listPtr->size = 0;

    if (compare == NULL) {
  404023:	48 85 db             	test   %rbx,%rbx
    list_t* listPtr = (list_t*)TM_MALLOC(sizeof(list_t));
    if (listPtr == NULL) {
        return NULL;
    }

    listPtr->head.dataPtr = NULL;
  404026:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    listPtr->head.nextPtr = NULL;
  40402d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  404034:	00 
    listPtr->size = 0;
  404035:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  40403c:	00 

    if (compare == NULL) {
  40403d:	74 09                	je     404048 <TMlist_alloc+0x38>
        listPtr->compare = &compareDataPtrAddresses; /* default */
    } else {
        listPtr->compare = compare;
  40403f:	48 89 58 10          	mov    %rbx,0x10(%rax)
    }

    return listPtr;
}
  404043:	5b                   	pop    %rbx
  404044:	c3                   	retq   
  404045:	0f 1f 00             	nopl   (%rax)
    listPtr->head.dataPtr = NULL;
    listPtr->head.nextPtr = NULL;
    listPtr->size = 0;

    if (compare == NULL) {
        listPtr->compare = &compareDataPtrAddresses; /* default */
  404048:	48 c7 40 10 d0 3b 40 	movq   $0x403bd0,0x10(%rax)
  40404f:	00 
    } else {
        listPtr->compare = compare;
    }

    return listPtr;
}
  404050:	5b                   	pop    %rbx
  404051:	c3                   	retq   
  404052:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
list_t*
TMlist_alloc (TM_ARGDECL  long (*compare)(const void*, const void*))
{
    list_t* listPtr = (list_t*)TM_MALLOC(sizeof(list_t));
    if (listPtr == NULL) {
        return NULL;
  404058:	31 c0                	xor    %eax,%eax
    } else {
        listPtr->compare = compare;
    }

    return listPtr;
}
  40405a:	5b                   	pop    %rbx
  40405b:	c3                   	retq   
  40405c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000404060 <list_free>:
 * list_free
 * =============================================================================
 */
void
list_free (list_t* listPtr)
{
  404060:	41 57                	push   %r15
  404062:	41 56                	push   %r14
  404064:	41 55                	push   %r13
  404066:	41 54                	push   %r12
  404068:	55                   	push   %rbp
  404069:	48 89 fd             	mov    %rdi,%rbp
  40406c:	53                   	push   %rbx
  40406d:	48 83 ec 38          	sub    $0x38,%rsp
    freeList(listPtr->head.nextPtr);
  404071:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404075:	48 85 db             	test   %rbx,%rbx
  404078:	0f 84 10 01 00 00    	je     40418e <list_free+0x12e>
        freeList(nodePtr->nextPtr);
  40407e:	4c 8b 63 08          	mov    0x8(%rbx),%r12
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404082:	4d 85 e4             	test   %r12,%r12
  404085:	0f 84 fb 00 00 00    	je     404186 <list_free+0x126>
        freeList(nodePtr->nextPtr);
  40408b:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404090:	4d 85 ed             	test   %r13,%r13
  404093:	0f 84 e5 00 00 00    	je     40417e <list_free+0x11e>
        freeList(nodePtr->nextPtr);
  404099:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40409d:	4d 85 f6             	test   %r14,%r14
  4040a0:	0f 84 d0 00 00 00    	je     404176 <list_free+0x116>
        freeList(nodePtr->nextPtr);
  4040a6:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040aa:	4d 85 ff             	test   %r15,%r15
  4040ad:	0f 84 bb 00 00 00    	je     40416e <list_free+0x10e>
        freeList(nodePtr->nextPtr);
  4040b3:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040b7:	48 85 c0             	test   %rax,%rax
        freeList(nodePtr->nextPtr);
  4040ba:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040bf:	0f 84 a1 00 00 00    	je     404166 <list_free+0x106>
        freeList(nodePtr->nextPtr);
  4040c5:	48 8b 40 08          	mov    0x8(%rax),%rax
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040c9:	48 85 c0             	test   %rax,%rax
  4040cc:	0f 84 8a 00 00 00    	je     40415c <list_free+0xfc>
        freeList(nodePtr->nextPtr);
  4040d2:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040d6:	48 85 d2             	test   %rdx,%rdx
  4040d9:	74 79                	je     404154 <list_free+0xf4>
        freeList(nodePtr->nextPtr);
  4040db:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040df:	48 85 c9             	test   %rcx,%rcx
  4040e2:	74 5e                	je     404142 <list_free+0xe2>
        freeList(nodePtr->nextPtr);
  4040e4:	48 8b 71 08          	mov    0x8(%rcx),%rsi
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4040e8:	48 85 f6             	test   %rsi,%rsi
  4040eb:	74 39                	je     404126 <list_free+0xc6>
        freeList(nodePtr->nextPtr);
  4040ed:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  4040f1:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  4040f6:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
  4040fb:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  404100:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  404105:	e8 e6 fb ff ff       	callq  403cf0 <freeList>
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  40410a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40410f:	48 89 f7             	mov    %rsi,%rdi
  404112:	e8 99 cb ff ff       	callq  400cb0 <free@plt>
  404117:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  40411c:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  404121:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  404126:	48 89 cf             	mov    %rcx,%rdi
  404129:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  40412e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  404133:	e8 78 cb ff ff       	callq  400cb0 <free@plt>
  404138:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  40413d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404142:	48 89 d7             	mov    %rdx,%rdi
  404145:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40414a:	e8 61 cb ff ff       	callq  400cb0 <free@plt>
  40414f:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404154:	48 89 c7             	mov    %rax,%rdi
  404157:	e8 54 cb ff ff       	callq  400cb0 <free@plt>
  40415c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  404161:	e8 4a cb ff ff       	callq  400cb0 <free@plt>
  404166:	4c 89 ff             	mov    %r15,%rdi
  404169:	e8 42 cb ff ff       	callq  400cb0 <free@plt>
  40416e:	4c 89 f7             	mov    %r14,%rdi
  404171:	e8 3a cb ff ff       	callq  400cb0 <free@plt>
  404176:	4c 89 ef             	mov    %r13,%rdi
  404179:	e8 32 cb ff ff       	callq  400cb0 <free@plt>
  40417e:	4c 89 e7             	mov    %r12,%rdi
  404181:	e8 2a cb ff ff       	callq  400cb0 <free@plt>
  404186:	48 89 df             	mov    %rbx,%rdi
  404189:	e8 22 cb ff ff       	callq  400cb0 <free@plt>
void
list_free (list_t* listPtr)
{
    freeList(listPtr->head.nextPtr);
    free(listPtr);
}
  40418e:	48 83 c4 38          	add    $0x38,%rsp
 */
void
list_free (list_t* listPtr)
{
    freeList(listPtr->head.nextPtr);
    free(listPtr);
  404192:	48 89 ef             	mov    %rbp,%rdi
}
  404195:	5b                   	pop    %rbx
  404196:	5d                   	pop    %rbp
  404197:	41 5c                	pop    %r12
  404199:	41 5d                	pop    %r13
  40419b:	41 5e                	pop    %r14
  40419d:	41 5f                	pop    %r15
 */
void
list_free (list_t* listPtr)
{
    freeList(listPtr->head.nextPtr);
    free(listPtr);
  40419f:	e9 0c cb ff ff       	jmpq   400cb0 <free@plt>
  4041a4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4041ab:	00 00 00 00 00 

00000000004041b0 <Plist_free>:
 * Plist_free
 * =============================================================================
 */
void
Plist_free (list_t* listPtr)
{
  4041b0:	41 57                	push   %r15
  4041b2:	41 56                	push   %r14
  4041b4:	41 55                	push   %r13
  4041b6:	41 54                	push   %r12
  4041b8:	55                   	push   %rbp
  4041b9:	48 89 fd             	mov    %rdi,%rbp
  4041bc:	53                   	push   %rbx
  4041bd:	48 83 ec 38          	sub    $0x38,%rsp
    PfreeList(listPtr->head.nextPtr);
  4041c1:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4041c5:	48 85 db             	test   %rbx,%rbx
  4041c8:	0f 84 10 01 00 00    	je     4042de <Plist_free+0x12e>
        PfreeList(nodePtr->nextPtr);
  4041ce:	4c 8b 63 08          	mov    0x8(%rbx),%r12
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4041d2:	4d 85 e4             	test   %r12,%r12
  4041d5:	0f 84 fb 00 00 00    	je     4042d6 <Plist_free+0x126>
        PfreeList(nodePtr->nextPtr);
  4041db:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4041e0:	4d 85 ed             	test   %r13,%r13
  4041e3:	0f 84 e5 00 00 00    	je     4042ce <Plist_free+0x11e>
        PfreeList(nodePtr->nextPtr);
  4041e9:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4041ed:	4d 85 f6             	test   %r14,%r14
  4041f0:	0f 84 d0 00 00 00    	je     4042c6 <Plist_free+0x116>
        PfreeList(nodePtr->nextPtr);
  4041f6:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4041fa:	4d 85 ff             	test   %r15,%r15
  4041fd:	0f 84 bb 00 00 00    	je     4042be <Plist_free+0x10e>
        PfreeList(nodePtr->nextPtr);
  404203:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404207:	48 85 c0             	test   %rax,%rax
        PfreeList(nodePtr->nextPtr);
  40420a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40420f:	0f 84 a1 00 00 00    	je     4042b6 <Plist_free+0x106>
        PfreeList(nodePtr->nextPtr);
  404215:	48 8b 40 08          	mov    0x8(%rax),%rax
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404219:	48 85 c0             	test   %rax,%rax
  40421c:	0f 84 8a 00 00 00    	je     4042ac <Plist_free+0xfc>
        PfreeList(nodePtr->nextPtr);
  404222:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404226:	48 85 d2             	test   %rdx,%rdx
  404229:	74 79                	je     4042a4 <Plist_free+0xf4>
        PfreeList(nodePtr->nextPtr);
  40422b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40422f:	48 85 c9             	test   %rcx,%rcx
  404232:	74 5e                	je     404292 <Plist_free+0xe2>
        PfreeList(nodePtr->nextPtr);
  404234:	48 8b 71 08          	mov    0x8(%rcx),%rsi
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404238:	48 85 f6             	test   %rsi,%rsi
  40423b:	74 39                	je     404276 <Plist_free+0xc6>
        PfreeList(nodePtr->nextPtr);
  40423d:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  404241:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  404246:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
  40424b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  404250:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  404255:	e8 a6 fb ff ff       	callq  403e00 <PfreeList>
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  40425a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  40425f:	48 89 f7             	mov    %rsi,%rdi
  404262:	e8 49 ca ff ff       	callq  400cb0 <free@plt>
  404267:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  40426c:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  404271:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  404276:	48 89 cf             	mov    %rcx,%rdi
  404279:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  40427e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  404283:	e8 28 ca ff ff       	callq  400cb0 <free@plt>
  404288:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  40428d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404292:	48 89 d7             	mov    %rdx,%rdi
  404295:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  40429a:	e8 11 ca ff ff       	callq  400cb0 <free@plt>
  40429f:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  4042a4:	48 89 c7             	mov    %rax,%rdi
  4042a7:	e8 04 ca ff ff       	callq  400cb0 <free@plt>
  4042ac:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  4042b1:	e8 fa c9 ff ff       	callq  400cb0 <free@plt>
  4042b6:	4c 89 ff             	mov    %r15,%rdi
  4042b9:	e8 f2 c9 ff ff       	callq  400cb0 <free@plt>
  4042be:	4c 89 f7             	mov    %r14,%rdi
  4042c1:	e8 ea c9 ff ff       	callq  400cb0 <free@plt>
  4042c6:	4c 89 ef             	mov    %r13,%rdi
  4042c9:	e8 e2 c9 ff ff       	callq  400cb0 <free@plt>
  4042ce:	4c 89 e7             	mov    %r12,%rdi
  4042d1:	e8 da c9 ff ff       	callq  400cb0 <free@plt>
  4042d6:	48 89 df             	mov    %rbx,%rdi
  4042d9:	e8 d2 c9 ff ff       	callq  400cb0 <free@plt>
void
Plist_free (list_t* listPtr)
{
    PfreeList(listPtr->head.nextPtr);
    P_FREE(listPtr);
}
  4042de:	48 83 c4 38          	add    $0x38,%rsp
 */
void
Plist_free (list_t* listPtr)
{
    PfreeList(listPtr->head.nextPtr);
    P_FREE(listPtr);
  4042e2:	48 89 ef             	mov    %rbp,%rdi
}
  4042e5:	5b                   	pop    %rbx
  4042e6:	5d                   	pop    %rbp
  4042e7:	41 5c                	pop    %r12
  4042e9:	41 5d                	pop    %r13
  4042eb:	41 5e                	pop    %r14
  4042ed:	41 5f                	pop    %r15
 */
void
Plist_free (list_t* listPtr)
{
    PfreeList(listPtr->head.nextPtr);
    P_FREE(listPtr);
  4042ef:	e9 bc c9 ff ff       	jmpq   400cb0 <free@plt>
  4042f4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4042fb:	00 00 00 00 00 

0000000000404300 <TMlist_free>:
 * TMlist_free
 * =============================================================================
 */
void
TMlist_free (TM_ARGDECL  list_t* listPtr)
{
  404300:	41 57                	push   %r15
  404302:	41 56                	push   %r14
  404304:	41 55                	push   %r13
  404306:	41 54                	push   %r12
  404308:	55                   	push   %rbp
  404309:	48 89 fd             	mov    %rdi,%rbp
  40430c:	53                   	push   %rbx
  40430d:	48 83 ec 38          	sub    $0x38,%rsp
    list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(listPtr->head.nextPtr);
  404311:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404315:	48 85 db             	test   %rbx,%rbx
  404318:	0f 84 10 01 00 00    	je     40442e <TMlist_free+0x12e>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  40431e:	4c 8b 63 08          	mov    0x8(%rbx),%r12
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404322:	4d 85 e4             	test   %r12,%r12
  404325:	0f 84 fb 00 00 00    	je     404426 <TMlist_free+0x126>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  40432b:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404330:	4d 85 ed             	test   %r13,%r13
  404333:	0f 84 e5 00 00 00    	je     40441e <TMlist_free+0x11e>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  404339:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40433d:	4d 85 f6             	test   %r14,%r14
  404340:	0f 84 d0 00 00 00    	je     404416 <TMlist_free+0x116>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  404346:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40434a:	4d 85 ff             	test   %r15,%r15
  40434d:	0f 84 bb 00 00 00    	je     40440e <TMlist_free+0x10e>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  404353:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404357:	48 85 c0             	test   %rax,%rax
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  40435a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40435f:	0f 84 a1 00 00 00    	je     404406 <TMlist_free+0x106>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  404365:	48 8b 40 08          	mov    0x8(%rax),%rax
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404369:	48 85 c0             	test   %rax,%rax
  40436c:	0f 84 8a 00 00 00    	je     4043fc <TMlist_free+0xfc>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  404372:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404376:	48 85 d2             	test   %rdx,%rdx
  404379:	74 79                	je     4043f4 <TMlist_free+0xf4>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  40437b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  40437f:	48 85 c9             	test   %rcx,%rcx
  404382:	74 5e                	je     4043e2 <TMlist_free+0xe2>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
  404384:	48 8b 71 08          	mov    0x8(%rcx),%rsi
 * =============================================================================
 */
static void
TMfreeList (TM_ARGDECL  list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404388:	48 85 f6             	test   %rsi,%rsi
  40438b:	74 39                	je     4043c6 <TMlist_free+0xc6>
        list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr);
        TMfreeList(TM_ARG  nextPtr);
  40438d:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  404391:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  404396:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
  40439b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  4043a0:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  4043a5:	e8 36 f8 ff ff       	callq  403be0 <TMfreeList>
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  list_node_t* nodePtr)
{
    TM_FREE(nodePtr);
  4043aa:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  4043af:	48 89 f7             	mov    %rsi,%rdi
  4043b2:	e8 f9 c8 ff ff       	callq  400cb0 <free@plt>
  4043b7:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  4043bc:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  4043c1:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4043c6:	48 89 cf             	mov    %rcx,%rdi
  4043c9:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  4043ce:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  4043d3:	e8 d8 c8 ff ff       	callq  400cb0 <free@plt>
  4043d8:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  4043dd:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  4043e2:	48 89 d7             	mov    %rdx,%rdi
  4043e5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  4043ea:	e8 c1 c8 ff ff       	callq  400cb0 <free@plt>
  4043ef:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  4043f4:	48 89 c7             	mov    %rax,%rdi
  4043f7:	e8 b4 c8 ff ff       	callq  400cb0 <free@plt>
  4043fc:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  404401:	e8 aa c8 ff ff       	callq  400cb0 <free@plt>
  404406:	4c 89 ff             	mov    %r15,%rdi
  404409:	e8 a2 c8 ff ff       	callq  400cb0 <free@plt>
  40440e:	4c 89 f7             	mov    %r14,%rdi
  404411:	e8 9a c8 ff ff       	callq  400cb0 <free@plt>
  404416:	4c 89 ef             	mov    %r13,%rdi
  404419:	e8 92 c8 ff ff       	callq  400cb0 <free@plt>
  40441e:	4c 89 e7             	mov    %r12,%rdi
  404421:	e8 8a c8 ff ff       	callq  400cb0 <free@plt>
  404426:	48 89 df             	mov    %rbx,%rdi
  404429:	e8 82 c8 ff ff       	callq  400cb0 <free@plt>
TMlist_free (TM_ARGDECL  list_t* listPtr)
{
    list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(listPtr->head.nextPtr);
    TMfreeList(TM_ARG  nextPtr);
    TM_FREE(listPtr);
}
  40442e:	48 83 c4 38          	add    $0x38,%rsp
void
TMlist_free (TM_ARGDECL  list_t* listPtr)
{
    list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(listPtr->head.nextPtr);
    TMfreeList(TM_ARG  nextPtr);
    TM_FREE(listPtr);
  404432:	48 89 ef             	mov    %rbp,%rdi
}
  404435:	5b                   	pop    %rbx
  404436:	5d                   	pop    %rbp
  404437:	41 5c                	pop    %r12
  404439:	41 5d                	pop    %r13
  40443b:	41 5e                	pop    %r14
  40443d:	41 5f                	pop    %r15
void
TMlist_free (TM_ARGDECL  list_t* listPtr)
{
    list_node_t* nextPtr = (list_node_t*)TM_SHARED_READ_P(listPtr->head.nextPtr);
    TMfreeList(TM_ARG  nextPtr);
    TM_FREE(listPtr);
  40443f:	e9 6c c8 ff ff       	jmpq   400cb0 <free@plt>
  404444:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40444b:	00 00 00 00 00 

0000000000404450 <list_isEmpty>:
 * =============================================================================
 */
bool_t
list_isEmpty (list_t* listPtr)
{
    return (listPtr->head.nextPtr == NULL);
  404450:	31 c0                	xor    %eax,%eax
  404452:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
  404457:	0f 94 c0             	sete   %al
}
  40445a:	c3                   	retq   
  40445b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000404460 <TMlist_isEmpty>:
 */
bool_t
TMlist_isEmpty (TM_ARGDECL  list_t* listPtr)
{
    return (((void*)TM_SHARED_READ_P(listPtr->head.nextPtr) == NULL) ?
            TRUE : FALSE);
  404460:	31 c0                	xor    %eax,%eax
  404462:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
  404467:	0f 94 c0             	sete   %al
}
  40446a:	c3                   	retq   
  40446b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000404470 <list_getSize>:
 * =============================================================================
 */
long
list_getSize (list_t* listPtr)
{
    return listPtr->size;
  404470:	48 8b 47 18          	mov    0x18(%rdi),%rax
}
  404474:	c3                   	retq   
  404475:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40447c:	00 00 00 00 

0000000000404480 <TMlist_getSize>:
 * =============================================================================
 */
long
TMlist_getSize (TM_ARGDECL  list_t* listPtr)
{
    return (long)TM_SHARED_READ(listPtr->size);
  404480:	48 8b 47 18          	mov    0x18(%rdi),%rax
}
  404484:	c3                   	retq   
  404485:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40448c:	00 00 00 00 

0000000000404490 <list_find>:
 * -- Returns NULL if not found, else returns pointer to data
 * =============================================================================
 */
void*
list_find (list_t* listPtr, void* dataPtr)
{
  404490:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  404492:	49 89 fd             	mov    %rdi,%r13
 * -- Returns NULL if not found, else returns pointer to data
 * =============================================================================
 */
void*
list_find (list_t* listPtr, void* dataPtr)
{
  404495:	41 54                	push   %r12
  404497:	49 89 f4             	mov    %rsi,%r12
  40449a:	55                   	push   %rbp
  40449b:	48 89 fd             	mov    %rdi,%rbp
  40449e:	53                   	push   %rbx
  40449f:	48 83 ec 08          	sub    $0x8,%rsp
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr = prevPtr->nextPtr;
  4044a3:	48 8b 5f 08          	mov    0x8(%rdi),%rbx

    for (; nodePtr != NULL; nodePtr = nodePtr->nextPtr) {
  4044a7:	48 85 db             	test   %rbx,%rbx
  4044aa:	75 13                	jne    4044bf <list_find+0x2f>
  4044ac:	eb 4a                	jmp    4044f8 <list_find+0x68>
  4044ae:	66 90                	xchg   %ax,%ax
  4044b0:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4044b4:	48 85 c0             	test   %rax,%rax
  4044b7:	74 3f                	je     4044f8 <list_find+0x68>
  4044b9:	49 89 dd             	mov    %rbx,%r13
  4044bc:	48 89 c3             	mov    %rax,%rbx
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  4044bf:	4c 89 e6             	mov    %r12,%rsi
  4044c2:	48 8b 3b             	mov    (%rbx),%rdi
  4044c5:	ff 55 10             	callq  *0x10(%rbp)
  4044c8:	48 85 c0             	test   %rax,%rax
  4044cb:	78 e3                	js     4044b0 <list_find+0x20>
  4044cd:	49 8b 5d 08          	mov    0x8(%r13),%rbx
    list_node_t* nodePtr;
    list_node_t* prevPtr = findPrevious(listPtr, dataPtr);

    nodePtr = prevPtr->nextPtr;

    if ((nodePtr == NULL) ||
  4044d1:	48 85 db             	test   %rbx,%rbx
  4044d4:	74 22                	je     4044f8 <list_find+0x68>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) != 0)) {
  4044d6:	4c 89 e6             	mov    %r12,%rsi
  4044d9:	48 8b 3b             	mov    (%rbx),%rdi
  4044dc:	ff 55 10             	callq  *0x10(%rbp)
    list_node_t* nodePtr;
    list_node_t* prevPtr = findPrevious(listPtr, dataPtr);

    nodePtr = prevPtr->nextPtr;

    if ((nodePtr == NULL) ||
  4044df:	48 85 c0             	test   %rax,%rax
  4044e2:	75 14                	jne    4044f8 <list_find+0x68>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) != 0)) {
        return NULL;
    }

    return (nodePtr->dataPtr);
  4044e4:	48 8b 03             	mov    (%rbx),%rax
}
  4044e7:	48 83 c4 08          	add    $0x8,%rsp
  4044eb:	5b                   	pop    %rbx
  4044ec:	5d                   	pop    %rbp
  4044ed:	41 5c                	pop    %r12
  4044ef:	41 5d                	pop    %r13
  4044f1:	c3                   	retq   
  4044f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4044f8:	48 83 c4 08          	add    $0x8,%rsp

    nodePtr = prevPtr->nextPtr;

    if ((nodePtr == NULL) ||
        (listPtr->compare(nodePtr->dataPtr, dataPtr) != 0)) {
        return NULL;
  4044fc:	31 c0                	xor    %eax,%eax
    }

    return (nodePtr->dataPtr);
}
  4044fe:	5b                   	pop    %rbx
  4044ff:	5d                   	pop    %rbp
  404500:	41 5c                	pop    %r12
  404502:	41 5d                	pop    %r13
  404504:	c3                   	retq   
  404505:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40450c:	00 00 00 00 

0000000000404510 <TMlist_find>:
 * -- Returns NULL if not found, else returns pointer to data
 * =============================================================================
 */
void*
TMlist_find (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
  404510:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  404512:	49 89 fd             	mov    %rdi,%r13
 * -- Returns NULL if not found, else returns pointer to data
 * =============================================================================
 */
void*
TMlist_find (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
  404515:	41 54                	push   %r12
  404517:	49 89 f4             	mov    %rsi,%r12
  40451a:	55                   	push   %rbp
  40451b:	48 89 fd             	mov    %rdi,%rbp
  40451e:	53                   	push   %rbx
  40451f:	48 83 ec 08          	sub    $0x8,%rsp
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr;

    for (nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  404523:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
  404527:	48 85 db             	test   %rbx,%rbx
  40452a:	75 13                	jne    40453f <TMlist_find+0x2f>
  40452c:	eb 4a                	jmp    404578 <TMlist_find+0x68>
  40452e:	66 90                	xchg   %ax,%ax
         nodePtr != NULL;
         nodePtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr))
  404530:	48 8b 43 08          	mov    0x8(%rbx),%rax
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr;

    for (nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  404534:	48 85 c0             	test   %rax,%rax
  404537:	74 3f                	je     404578 <TMlist_find+0x68>
  404539:	49 89 dd             	mov    %rbx,%r13
         nodePtr != NULL;
         nodePtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr))
  40453c:	48 89 c3             	mov    %rax,%rbx
    {
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  40453f:	4c 89 e6             	mov    %r12,%rsi
  404542:	48 8b 3b             	mov    (%rbx),%rdi
  404545:	ff 55 10             	callq  *0x10(%rbp)
  404548:	48 85 c0             	test   %rax,%rax
  40454b:	78 e3                	js     404530 <TMlist_find+0x20>
  40454d:	49 8b 5d 08          	mov    0x8(%r13),%rbx
    list_node_t* nodePtr;
    list_node_t* prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);

    nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);

    if ((nodePtr == NULL) ||
  404551:	48 85 db             	test   %rbx,%rbx
  404554:	74 22                	je     404578 <TMlist_find+0x68>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) != 0)) {
  404556:	4c 89 e6             	mov    %r12,%rsi
  404559:	48 8b 3b             	mov    (%rbx),%rdi
  40455c:	ff 55 10             	callq  *0x10(%rbp)
    list_node_t* nodePtr;
    list_node_t* prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);

    nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);

    if ((nodePtr == NULL) ||
  40455f:	48 85 c0             	test   %rax,%rax
  404562:	75 14                	jne    404578 <TMlist_find+0x68>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) != 0)) {
        return NULL;
    }

    return (nodePtr->dataPtr);
  404564:	48 8b 03             	mov    (%rbx),%rax
}
  404567:	48 83 c4 08          	add    $0x8,%rsp
  40456b:	5b                   	pop    %rbx
  40456c:	5d                   	pop    %rbp
  40456d:	41 5c                	pop    %r12
  40456f:	41 5d                	pop    %r13
  404571:	c3                   	retq   
  404572:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  404578:	48 83 c4 08          	add    $0x8,%rsp

    nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);

    if ((nodePtr == NULL) ||
        (listPtr->compare(nodePtr->dataPtr, dataPtr) != 0)) {
        return NULL;
  40457c:	31 c0                	xor    %eax,%eax
    }

    return (nodePtr->dataPtr);
}
  40457e:	5b                   	pop    %rbx
  40457f:	5d                   	pop    %rbp
  404580:	41 5c                	pop    %r12
  404582:	41 5d                	pop    %r13
  404584:	c3                   	retq   
  404585:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40458c:	00 00 00 00 

0000000000404590 <list_insert>:
 * -- Return TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
list_insert (list_t* listPtr, void* dataPtr)
{
  404590:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  404592:	49 89 fd             	mov    %rdi,%r13
 * -- Return TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
list_insert (list_t* listPtr, void* dataPtr)
{
  404595:	41 54                	push   %r12
  404597:	49 89 f4             	mov    %rsi,%r12
  40459a:	55                   	push   %rbp
  40459b:	48 89 fd             	mov    %rdi,%rbp
  40459e:	53                   	push   %rbx
  40459f:	48 83 ec 08          	sub    $0x8,%rsp
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr = prevPtr->nextPtr;
  4045a3:	48 8b 5f 08          	mov    0x8(%rdi),%rbx

    for (; nodePtr != NULL; nodePtr = nodePtr->nextPtr) {
  4045a7:	48 85 db             	test   %rbx,%rbx
  4045aa:	75 13                	jne    4045bf <list_insert+0x2f>
  4045ac:	eb 4a                	jmp    4045f8 <list_insert+0x68>
  4045ae:	66 90                	xchg   %ax,%ax
  4045b0:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4045b4:	49 89 dd             	mov    %rbx,%r13
  4045b7:	48 85 c0             	test   %rax,%rax
  4045ba:	74 3c                	je     4045f8 <list_insert+0x68>
  4045bc:	48 89 c3             	mov    %rax,%rbx
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  4045bf:	4c 89 e6             	mov    %r12,%rsi
  4045c2:	48 8b 3b             	mov    (%rbx),%rdi
  4045c5:	ff 55 10             	callq  *0x10(%rbp)
  4045c8:	48 85 c0             	test   %rax,%rax
  4045cb:	78 e3                	js     4045b0 <list_insert+0x20>
  4045cd:	49 8b 5d 08          	mov    0x8(%r13),%rbx

    prevPtr = findPrevious(listPtr, dataPtr);
    currPtr = prevPtr->nextPtr;

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
  4045d1:	48 85 db             	test   %rbx,%rbx
  4045d4:	74 24                	je     4045fa <list_insert+0x6a>
        listPtr->compare(currPtr->dataPtr, dataPtr) == 0) {
  4045d6:	4c 89 e6             	mov    %r12,%rsi
  4045d9:	48 8b 3b             	mov    (%rbx),%rdi
  4045dc:	ff 55 10             	callq  *0x10(%rbp)

    prevPtr = findPrevious(listPtr, dataPtr);
    currPtr = prevPtr->nextPtr;

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
  4045df:	48 85 c0             	test   %rax,%rax
  4045e2:	75 16                	jne    4045fa <list_insert+0x6a>
    nodePtr->nextPtr = currPtr;
    prevPtr->nextPtr = nodePtr;
    listPtr->size++;

    return TRUE;
}
  4045e4:	48 83 c4 08          	add    $0x8,%rsp
    currPtr = prevPtr->nextPtr;

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
        listPtr->compare(currPtr->dataPtr, dataPtr) == 0) {
        return FALSE;
  4045e8:	31 c0                	xor    %eax,%eax
    nodePtr->nextPtr = currPtr;
    prevPtr->nextPtr = nodePtr;
    listPtr->size++;

    return TRUE;
}
  4045ea:	5b                   	pop    %rbx
  4045eb:	5d                   	pop    %rbp
  4045ec:	41 5c                	pop    %r12
  4045ee:	41 5d                	pop    %r13
  4045f0:	c3                   	retq   
  4045f1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    list_node_t* prevPtr;
    list_node_t* nodePtr;
    list_node_t* currPtr;

    prevPtr = findPrevious(listPtr, dataPtr);
    currPtr = prevPtr->nextPtr;
  4045f8:	31 db                	xor    %ebx,%ebx
 * =============================================================================
 */
static list_node_t*
allocNode (void* dataPtr)
{
    list_node_t* nodePtr = (list_node_t*)malloc(sizeof(list_node_t));
  4045fa:	bf 10 00 00 00       	mov    $0x10,%edi
  4045ff:	e8 7c c6 ff ff       	callq  400c80 <malloc@plt>
    if (nodePtr == NULL) {
  404604:	48 85 c0             	test   %rax,%rax
  404607:	74 db                	je     4045e4 <list_insert+0x54>
        return NULL;
    }

    nodePtr->dataPtr = dataPtr;
  404609:	4c 89 20             	mov    %r12,(%rax)
    nodePtr = allocNode(dataPtr);
    if (nodePtr == NULL) {
        return FALSE;
    }

    nodePtr->nextPtr = currPtr;
  40460c:	48 89 58 08          	mov    %rbx,0x8(%rax)
    prevPtr->nextPtr = nodePtr;
  404610:	49 89 45 08          	mov    %rax,0x8(%r13)
    listPtr->size++;
  404614:	48 83 45 18 01       	addq   $0x1,0x18(%rbp)

    return TRUE;
}
  404619:	48 83 c4 08          	add    $0x8,%rsp
  40461d:	5b                   	pop    %rbx
  40461e:	5d                   	pop    %rbp
  40461f:	41 5c                	pop    %r12

    nodePtr->nextPtr = currPtr;
    prevPtr->nextPtr = nodePtr;
    listPtr->size++;

    return TRUE;
  404621:	b8 01 00 00 00       	mov    $0x1,%eax
}
  404626:	41 5d                	pop    %r13
  404628:	c3                   	retq   
  404629:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000404630 <Plist_insert>:
 * -- Return TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
Plist_insert (list_t* listPtr, void* dataPtr)
{
  404630:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  404632:	49 89 fd             	mov    %rdi,%r13
 * -- Return TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
Plist_insert (list_t* listPtr, void* dataPtr)
{
  404635:	41 54                	push   %r12
  404637:	49 89 f4             	mov    %rsi,%r12
  40463a:	55                   	push   %rbp
  40463b:	48 89 fd             	mov    %rdi,%rbp
  40463e:	53                   	push   %rbx
  40463f:	48 83 ec 08          	sub    $0x8,%rsp
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr = prevPtr->nextPtr;
  404643:	48 8b 5f 08          	mov    0x8(%rdi),%rbx

    for (; nodePtr != NULL; nodePtr = nodePtr->nextPtr) {
  404647:	48 85 db             	test   %rbx,%rbx
  40464a:	75 13                	jne    40465f <Plist_insert+0x2f>
  40464c:	eb 4a                	jmp    404698 <Plist_insert+0x68>
  40464e:	66 90                	xchg   %ax,%ax
  404650:	48 8b 43 08          	mov    0x8(%rbx),%rax
  404654:	49 89 dd             	mov    %rbx,%r13
  404657:	48 85 c0             	test   %rax,%rax
  40465a:	74 3c                	je     404698 <Plist_insert+0x68>
  40465c:	48 89 c3             	mov    %rax,%rbx
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  40465f:	4c 89 e6             	mov    %r12,%rsi
  404662:	48 8b 3b             	mov    (%rbx),%rdi
  404665:	ff 55 10             	callq  *0x10(%rbp)
  404668:	48 85 c0             	test   %rax,%rax
  40466b:	78 e3                	js     404650 <Plist_insert+0x20>
  40466d:	49 8b 5d 08          	mov    0x8(%r13),%rbx

    prevPtr = findPrevious(listPtr, dataPtr);
    currPtr = prevPtr->nextPtr;

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
  404671:	48 85 db             	test   %rbx,%rbx
  404674:	74 24                	je     40469a <Plist_insert+0x6a>
        listPtr->compare(currPtr->dataPtr, dataPtr) == 0) {
  404676:	4c 89 e6             	mov    %r12,%rsi
  404679:	48 8b 3b             	mov    (%rbx),%rdi
  40467c:	ff 55 10             	callq  *0x10(%rbp)

    prevPtr = findPrevious(listPtr, dataPtr);
    currPtr = prevPtr->nextPtr;

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
  40467f:	48 85 c0             	test   %rax,%rax
  404682:	75 16                	jne    40469a <Plist_insert+0x6a>
    nodePtr->nextPtr = currPtr;
    prevPtr->nextPtr = nodePtr;
    listPtr->size++;

    return TRUE;
}
  404684:	48 83 c4 08          	add    $0x8,%rsp
    currPtr = prevPtr->nextPtr;

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
        listPtr->compare(currPtr->dataPtr, dataPtr) == 0) {
        return FALSE;
  404688:	31 c0                	xor    %eax,%eax
    nodePtr->nextPtr = currPtr;
    prevPtr->nextPtr = nodePtr;
    listPtr->size++;

    return TRUE;
}
  40468a:	5b                   	pop    %rbx
  40468b:	5d                   	pop    %rbp
  40468c:	41 5c                	pop    %r12
  40468e:	41 5d                	pop    %r13
  404690:	c3                   	retq   
  404691:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    list_node_t* prevPtr;
    list_node_t* nodePtr;
    list_node_t* currPtr;

    prevPtr = findPrevious(listPtr, dataPtr);
    currPtr = prevPtr->nextPtr;
  404698:	31 db                	xor    %ebx,%ebx
 * =============================================================================
 */
static list_node_t*
PallocNode (void* dataPtr)
{
    list_node_t* nodePtr = (list_node_t*)P_MALLOC(sizeof(list_node_t));
  40469a:	bf 10 00 00 00       	mov    $0x10,%edi
  40469f:	e8 dc c5 ff ff       	callq  400c80 <malloc@plt>
    if (nodePtr == NULL) {
  4046a4:	48 85 c0             	test   %rax,%rax
  4046a7:	74 db                	je     404684 <Plist_insert+0x54>
        return NULL;
    }

    nodePtr->dataPtr = dataPtr;
  4046a9:	4c 89 20             	mov    %r12,(%rax)
    nodePtr = PallocNode(dataPtr);
    if (nodePtr == NULL) {
        return FALSE;
    }

    nodePtr->nextPtr = currPtr;
  4046ac:	48 89 58 08          	mov    %rbx,0x8(%rax)
    prevPtr->nextPtr = nodePtr;
  4046b0:	49 89 45 08          	mov    %rax,0x8(%r13)
    listPtr->size++;
  4046b4:	48 83 45 18 01       	addq   $0x1,0x18(%rbp)

    return TRUE;
}
  4046b9:	48 83 c4 08          	add    $0x8,%rsp
  4046bd:	5b                   	pop    %rbx
  4046be:	5d                   	pop    %rbp
  4046bf:	41 5c                	pop    %r12

    nodePtr->nextPtr = currPtr;
    prevPtr->nextPtr = nodePtr;
    listPtr->size++;

    return TRUE;
  4046c1:	b8 01 00 00 00       	mov    $0x1,%eax
}
  4046c6:	41 5d                	pop    %r13
  4046c8:	c3                   	retq   
  4046c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000004046d0 <TMlist_insert>:
 * -- Return TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
TMlist_insert (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
  4046d0:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  4046d2:	49 89 fd             	mov    %rdi,%r13
 * -- Return TRUE on success, else FALSE
 * =============================================================================
 */
bool_t
TMlist_insert (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
  4046d5:	41 54                	push   %r12
  4046d7:	49 89 f4             	mov    %rsi,%r12
  4046da:	55                   	push   %rbp
  4046db:	48 89 fd             	mov    %rdi,%rbp
  4046de:	53                   	push   %rbx
  4046df:	48 83 ec 08          	sub    $0x8,%rsp
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr;

    for (nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  4046e3:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
  4046e7:	48 85 db             	test   %rbx,%rbx
  4046ea:	75 13                	jne    4046ff <TMlist_insert+0x2f>
  4046ec:	eb 4a                	jmp    404738 <TMlist_insert+0x68>
  4046ee:	66 90                	xchg   %ax,%ax
         nodePtr != NULL;
         nodePtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr))
  4046f0:	48 8b 43 08          	mov    0x8(%rbx),%rax
  4046f4:	49 89 dd             	mov    %rbx,%r13
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr;

    for (nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  4046f7:	48 85 c0             	test   %rax,%rax
  4046fa:	74 3c                	je     404738 <TMlist_insert+0x68>
         nodePtr != NULL;
         nodePtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr))
  4046fc:	48 89 c3             	mov    %rax,%rbx
    {
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  4046ff:	4c 89 e6             	mov    %r12,%rsi
  404702:	48 8b 3b             	mov    (%rbx),%rdi
  404705:	ff 55 10             	callq  *0x10(%rbp)
  404708:	48 85 c0             	test   %rax,%rax
  40470b:	78 e3                	js     4046f0 <TMlist_insert+0x20>
  40470d:	49 8b 5d 08          	mov    0x8(%r13),%rbx

    prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);
    currPtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
  404711:	48 85 db             	test   %rbx,%rbx
  404714:	74 24                	je     40473a <TMlist_insert+0x6a>
        listPtr->compare(currPtr->dataPtr, dataPtr) == 0) {
  404716:	4c 89 e6             	mov    %r12,%rsi
  404719:	48 8b 3b             	mov    (%rbx),%rdi
  40471c:	ff 55 10             	callq  *0x10(%rbp)

    prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);
    currPtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
  40471f:	48 85 c0             	test   %rax,%rax
  404722:	75 16                	jne    40473a <TMlist_insert+0x6a>
    nodePtr->nextPtr = currPtr;
    TM_SHARED_WRITE_P(prevPtr->nextPtr, nodePtr);
    TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) + 1));

    return TRUE;
}
  404724:	48 83 c4 08          	add    $0x8,%rsp
    currPtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);

#ifdef LIST_NO_DUPLICATES
    if ((currPtr != NULL) &&
        listPtr->compare(currPtr->dataPtr, dataPtr) == 0) {
        return FALSE;
  404728:	31 c0                	xor    %eax,%eax
    nodePtr->nextPtr = currPtr;
    TM_SHARED_WRITE_P(prevPtr->nextPtr, nodePtr);
    TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) + 1));

    return TRUE;
}
  40472a:	5b                   	pop    %rbx
  40472b:	5d                   	pop    %rbp
  40472c:	41 5c                	pop    %r12
  40472e:	41 5d                	pop    %r13
  404730:	c3                   	retq   
  404731:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    list_node_t* prevPtr;
    list_node_t* nodePtr;
    list_node_t* currPtr;

    prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);
    currPtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  404738:	31 db                	xor    %ebx,%ebx
 * =============================================================================
 */
static list_node_t*
TMallocNode (TM_ARGDECL  void* dataPtr)
{
    list_node_t* nodePtr = (list_node_t*)TM_MALLOC(sizeof(list_node_t));
  40473a:	bf 10 00 00 00       	mov    $0x10,%edi
  40473f:	e8 3c c5 ff ff       	callq  400c80 <malloc@plt>
    if (nodePtr == NULL) {
  404744:	48 85 c0             	test   %rax,%rax
  404747:	74 db                	je     404724 <TMlist_insert+0x54>
        return NULL;
    }

    nodePtr->dataPtr = dataPtr;
  404749:	4c 89 20             	mov    %r12,(%rax)
    nodePtr = TMallocNode(TM_ARG  dataPtr);
    if (nodePtr == NULL) {
        return FALSE;
    }

    nodePtr->nextPtr = currPtr;
  40474c:	48 89 58 08          	mov    %rbx,0x8(%rax)
    TM_SHARED_WRITE_P(prevPtr->nextPtr, nodePtr);
  404750:	49 89 45 08          	mov    %rax,0x8(%r13)
    TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) + 1));
  404754:	48 83 45 18 01       	addq   $0x1,0x18(%rbp)

    return TRUE;
}
  404759:	48 83 c4 08          	add    $0x8,%rsp
  40475d:	5b                   	pop    %rbx
  40475e:	5d                   	pop    %rbp
  40475f:	41 5c                	pop    %r12

    nodePtr->nextPtr = currPtr;
    TM_SHARED_WRITE_P(prevPtr->nextPtr, nodePtr);
    TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) + 1));

    return TRUE;
  404761:	b8 01 00 00 00       	mov    $0x1,%eax
}
  404766:	41 5d                	pop    %r13
  404768:	c3                   	retq   
  404769:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000404770 <list_remove>:
 * -- Returns TRUE if successful, else FALSE
 * =============================================================================
 */
bool_t
list_remove (list_t* listPtr, void* dataPtr)
{
  404770:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  404772:	49 89 fd             	mov    %rdi,%r13
 * -- Returns TRUE if successful, else FALSE
 * =============================================================================
 */
bool_t
list_remove (list_t* listPtr, void* dataPtr)
{
  404775:	41 54                	push   %r12
  404777:	49 89 f4             	mov    %rsi,%r12
  40477a:	55                   	push   %rbp
  40477b:	48 89 fd             	mov    %rdi,%rbp
  40477e:	53                   	push   %rbx
  40477f:	48 83 ec 08          	sub    $0x8,%rsp
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr = prevPtr->nextPtr;
  404783:	48 8b 5f 08          	mov    0x8(%rdi),%rbx

    for (; nodePtr != NULL; nodePtr = nodePtr->nextPtr) {
  404787:	48 85 db             	test   %rbx,%rbx
  40478a:	75 13                	jne    40479f <list_remove+0x2f>
  40478c:	eb 6a                	jmp    4047f8 <list_remove+0x88>
  40478e:	66 90                	xchg   %ax,%ax
  404790:	48 8b 43 08          	mov    0x8(%rbx),%rax
  404794:	48 85 c0             	test   %rax,%rax
  404797:	74 5f                	je     4047f8 <list_remove+0x88>
  404799:	49 89 dd             	mov    %rbx,%r13
  40479c:	48 89 c3             	mov    %rax,%rbx
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  40479f:	4c 89 e6             	mov    %r12,%rsi
  4047a2:	48 8b 3b             	mov    (%rbx),%rdi
  4047a5:	ff 55 10             	callq  *0x10(%rbp)
  4047a8:	48 85 c0             	test   %rax,%rax
  4047ab:	78 e3                	js     404790 <list_remove+0x20>
  4047ad:	49 8b 5d 08          	mov    0x8(%r13),%rbx
    list_node_t* nodePtr;

    prevPtr = findPrevious(listPtr, dataPtr);

    nodePtr = prevPtr->nextPtr;
    if ((nodePtr != NULL) &&
  4047b1:	48 85 db             	test   %rbx,%rbx
  4047b4:	74 42                	je     4047f8 <list_remove+0x88>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
  4047b6:	4c 89 e6             	mov    %r12,%rsi
  4047b9:	48 8b 3b             	mov    (%rbx),%rdi
  4047bc:	ff 55 10             	callq  *0x10(%rbp)
    list_node_t* nodePtr;

    prevPtr = findPrevious(listPtr, dataPtr);

    nodePtr = prevPtr->nextPtr;
    if ((nodePtr != NULL) &&
  4047bf:	48 85 c0             	test   %rax,%rax
  4047c2:	75 34                	jne    4047f8 <list_remove+0x88>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
  4047c4:	48 8b 43 08          	mov    0x8(%rbx),%rax
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  4047c8:	48 89 df             	mov    %rbx,%rdi

    nodePtr = prevPtr->nextPtr;
    if ((nodePtr != NULL) &&
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
  4047cb:	49 89 45 08          	mov    %rax,0x8(%r13)
        nodePtr->nextPtr = NULL;
  4047cf:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  4047d6:	00 
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  4047d7:	e8 d4 c4 ff ff       	callq  400cb0 <free@plt>
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
        nodePtr->nextPtr = NULL;
        freeNode(nodePtr);
        listPtr->size--;
        assert(listPtr->size >= 0);
  4047dc:	48 83 6d 18 01       	subq   $0x1,0x18(%rbp)
  4047e1:	78 22                	js     404805 <list_remove+0x95>
        return TRUE;
    }

    return FALSE;
}
  4047e3:	48 83 c4 08          	add    $0x8,%rsp
        prevPtr->nextPtr = nodePtr->nextPtr;
        nodePtr->nextPtr = NULL;
        freeNode(nodePtr);
        listPtr->size--;
        assert(listPtr->size >= 0);
        return TRUE;
  4047e7:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return FALSE;
}
  4047ec:	5b                   	pop    %rbx
  4047ed:	5d                   	pop    %rbp
  4047ee:	41 5c                	pop    %r12
  4047f0:	41 5d                	pop    %r13
  4047f2:	c3                   	retq   
  4047f3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4047f8:	48 83 c4 08          	add    $0x8,%rsp
        listPtr->size--;
        assert(listPtr->size >= 0);
        return TRUE;
    }

    return FALSE;
  4047fc:	31 c0                	xor    %eax,%eax
}
  4047fe:	5b                   	pop    %rbx
  4047ff:	5d                   	pop    %rbp
  404800:	41 5c                	pop    %r12
  404802:	41 5d                	pop    %r13
  404804:	c3                   	retq   
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
        nodePtr->nextPtr = NULL;
        freeNode(nodePtr);
        listPtr->size--;
        assert(listPtr->size >= 0);
  404805:	b9 4c 94 40 00       	mov    $0x40944c,%ecx
  40480a:	ba bf 02 00 00       	mov    $0x2bf,%edx
  40480f:	be 10 94 40 00       	mov    $0x409410,%esi
  404814:	bf 1e 94 40 00       	mov    $0x40941e,%edi
  404819:	e8 32 c4 ff ff       	callq  400c50 <__assert_fail@plt>
  40481e:	66 90                	xchg   %ax,%ax

0000000000404820 <Plist_remove>:
 * -- Returns TRUE if successful, else FALSE
 * =============================================================================
 */
bool_t
Plist_remove (list_t* listPtr, void* dataPtr)
{
  404820:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  404822:	49 89 fd             	mov    %rdi,%r13
 * -- Returns TRUE if successful, else FALSE
 * =============================================================================
 */
bool_t
Plist_remove (list_t* listPtr, void* dataPtr)
{
  404825:	41 54                	push   %r12
  404827:	49 89 f4             	mov    %rsi,%r12
  40482a:	55                   	push   %rbp
  40482b:	48 89 fd             	mov    %rdi,%rbp
  40482e:	53                   	push   %rbx
  40482f:	48 83 ec 08          	sub    $0x8,%rsp
 */
static list_node_t*
findPrevious (list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr = prevPtr->nextPtr;
  404833:	48 8b 5f 08          	mov    0x8(%rdi),%rbx

    for (; nodePtr != NULL; nodePtr = nodePtr->nextPtr) {
  404837:	48 85 db             	test   %rbx,%rbx
  40483a:	75 13                	jne    40484f <Plist_remove+0x2f>
  40483c:	eb 6a                	jmp    4048a8 <Plist_remove+0x88>
  40483e:	66 90                	xchg   %ax,%ax
  404840:	48 8b 43 08          	mov    0x8(%rbx),%rax
  404844:	48 85 c0             	test   %rax,%rax
  404847:	74 5f                	je     4048a8 <Plist_remove+0x88>
  404849:	49 89 dd             	mov    %rbx,%r13
  40484c:	48 89 c3             	mov    %rax,%rbx
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  40484f:	4c 89 e6             	mov    %r12,%rsi
  404852:	48 8b 3b             	mov    (%rbx),%rdi
  404855:	ff 55 10             	callq  *0x10(%rbp)
  404858:	48 85 c0             	test   %rax,%rax
  40485b:	78 e3                	js     404840 <Plist_remove+0x20>
  40485d:	49 8b 5d 08          	mov    0x8(%r13),%rbx
    list_node_t* nodePtr;

    prevPtr = findPrevious(listPtr, dataPtr);

    nodePtr = prevPtr->nextPtr;
    if ((nodePtr != NULL) &&
  404861:	48 85 db             	test   %rbx,%rbx
  404864:	74 42                	je     4048a8 <Plist_remove+0x88>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
  404866:	4c 89 e6             	mov    %r12,%rsi
  404869:	48 8b 3b             	mov    (%rbx),%rdi
  40486c:	ff 55 10             	callq  *0x10(%rbp)
    list_node_t* nodePtr;

    prevPtr = findPrevious(listPtr, dataPtr);

    nodePtr = prevPtr->nextPtr;
    if ((nodePtr != NULL) &&
  40486f:	48 85 c0             	test   %rax,%rax
  404872:	75 34                	jne    4048a8 <Plist_remove+0x88>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
  404874:	48 8b 43 08          	mov    0x8(%rbx),%rax
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  404878:	48 89 df             	mov    %rbx,%rdi

    nodePtr = prevPtr->nextPtr;
    if ((nodePtr != NULL) &&
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
  40487b:	49 89 45 08          	mov    %rax,0x8(%r13)
        nodePtr->nextPtr = NULL;
  40487f:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  404886:	00 
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  404887:	e8 24 c4 ff ff       	callq  400cb0 <free@plt>
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
        nodePtr->nextPtr = NULL;
        PfreeNode(nodePtr);
        listPtr->size--;
        assert(listPtr->size >= 0);
  40488c:	48 83 6d 18 01       	subq   $0x1,0x18(%rbp)
  404891:	78 22                	js     4048b5 <Plist_remove+0x95>
        return TRUE;
    }

    return FALSE;
}
  404893:	48 83 c4 08          	add    $0x8,%rsp
        prevPtr->nextPtr = nodePtr->nextPtr;
        nodePtr->nextPtr = NULL;
        PfreeNode(nodePtr);
        listPtr->size--;
        assert(listPtr->size >= 0);
        return TRUE;
  404897:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return FALSE;
}
  40489c:	5b                   	pop    %rbx
  40489d:	5d                   	pop    %rbp
  40489e:	41 5c                	pop    %r12
  4048a0:	41 5d                	pop    %r13
  4048a2:	c3                   	retq   
  4048a3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  4048a8:	48 83 c4 08          	add    $0x8,%rsp
        listPtr->size--;
        assert(listPtr->size >= 0);
        return TRUE;
    }

    return FALSE;
  4048ac:	31 c0                	xor    %eax,%eax
}
  4048ae:	5b                   	pop    %rbx
  4048af:	5d                   	pop    %rbp
  4048b0:	41 5c                	pop    %r12
  4048b2:	41 5d                	pop    %r13
  4048b4:	c3                   	retq   
    {
        prevPtr->nextPtr = nodePtr->nextPtr;
        nodePtr->nextPtr = NULL;
        PfreeNode(nodePtr);
        listPtr->size--;
        assert(listPtr->size >= 0);
  4048b5:	b9 3f 94 40 00       	mov    $0x40943f,%ecx
  4048ba:	ba dc 02 00 00       	mov    $0x2dc,%edx
  4048bf:	be 10 94 40 00       	mov    $0x409410,%esi
  4048c4:	bf 1e 94 40 00       	mov    $0x40941e,%edi
  4048c9:	e8 82 c3 ff ff       	callq  400c50 <__assert_fail@plt>
  4048ce:	66 90                	xchg   %ax,%ax

00000000004048d0 <TMlist_remove>:
 * -- Returns TRUE if successful, else FALSE
 * =============================================================================
 */
bool_t
TMlist_remove (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
  4048d0:	41 55                	push   %r13
 * =============================================================================
 */
static list_node_t*
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
  4048d2:	49 89 fd             	mov    %rdi,%r13
 * -- Returns TRUE if successful, else FALSE
 * =============================================================================
 */
bool_t
TMlist_remove (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
  4048d5:	41 54                	push   %r12
  4048d7:	49 89 f4             	mov    %rsi,%r12
  4048da:	55                   	push   %rbp
  4048db:	48 89 fd             	mov    %rdi,%rbp
  4048de:	53                   	push   %rbx
  4048df:	48 83 ec 08          	sub    $0x8,%rsp
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr;

    for (nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  4048e3:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
  4048e7:	48 85 db             	test   %rbx,%rbx
  4048ea:	75 13                	jne    4048ff <TMlist_remove+0x2f>
  4048ec:	eb 6a                	jmp    404958 <TMlist_remove+0x88>
  4048ee:	66 90                	xchg   %ax,%ax
         nodePtr != NULL;
         nodePtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr))
  4048f0:	48 8b 43 08          	mov    0x8(%rbx),%rax
TMfindPrevious (TM_ARGDECL  list_t* listPtr, void* dataPtr)
{
    list_node_t* prevPtr = &(listPtr->head);
    list_node_t* nodePtr;

    for (nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
  4048f4:	48 85 c0             	test   %rax,%rax
  4048f7:	74 5f                	je     404958 <TMlist_remove+0x88>
  4048f9:	49 89 dd             	mov    %rbx,%r13
         nodePtr != NULL;
         nodePtr = (list_node_t*)TM_SHARED_READ_P(nodePtr->nextPtr))
  4048fc:	48 89 c3             	mov    %rax,%rbx
    {
        if (listPtr->compare(nodePtr->dataPtr, dataPtr) >= 0) {
  4048ff:	4c 89 e6             	mov    %r12,%rsi
  404902:	48 8b 3b             	mov    (%rbx),%rdi
  404905:	ff 55 10             	callq  *0x10(%rbp)
  404908:	48 85 c0             	test   %rax,%rax
  40490b:	78 e3                	js     4048f0 <TMlist_remove+0x20>
  40490d:	49 8b 5d 08          	mov    0x8(%r13),%rbx
    list_node_t* nodePtr;

    prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);

    nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
    if ((nodePtr != NULL) &&
  404911:	48 85 db             	test   %rbx,%rbx
  404914:	74 42                	je     404958 <TMlist_remove+0x88>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
  404916:	4c 89 e6             	mov    %r12,%rsi
  404919:	48 8b 3b             	mov    (%rbx),%rdi
  40491c:	ff 55 10             	callq  *0x10(%rbp)
    list_node_t* nodePtr;

    prevPtr = TMfindPrevious(TM_ARG  listPtr, dataPtr);

    nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
    if ((nodePtr != NULL) &&
  40491f:	48 85 c0             	test   %rax,%rax
  404922:	75 34                	jne    404958 <TMlist_remove+0x88>
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
    {
        TM_SHARED_WRITE_P(prevPtr->nextPtr, TM_SHARED_READ_P(nodePtr->nextPtr));
  404924:	48 8b 43 08          	mov    0x8(%rbx),%rax
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  list_node_t* nodePtr)
{
    TM_FREE(nodePtr);
  404928:	48 89 df             	mov    %rbx,%rdi

    nodePtr = (list_node_t*)TM_SHARED_READ_P(prevPtr->nextPtr);
    if ((nodePtr != NULL) &&
        (listPtr->compare(nodePtr->dataPtr, dataPtr) == 0))
    {
        TM_SHARED_WRITE_P(prevPtr->nextPtr, TM_SHARED_READ_P(nodePtr->nextPtr));
  40492b:	49 89 45 08          	mov    %rax,0x8(%r13)
        TM_SHARED_WRITE_P(nodePtr->nextPtr, (struct list_node*)NULL);
  40492f:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  404936:	00 
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  list_node_t* nodePtr)
{
    TM_FREE(nodePtr);
  404937:	e8 74 c3 ff ff       	callq  400cb0 <free@plt>
    {
        TM_SHARED_WRITE_P(prevPtr->nextPtr, TM_SHARED_READ_P(nodePtr->nextPtr));
        TM_SHARED_WRITE_P(nodePtr->nextPtr, (struct list_node*)NULL);
        TMfreeNode(TM_ARG  nodePtr);
        TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) - 1));
        assert(listPtr->size >= 0);
  40493c:	48 83 6d 18 01       	subq   $0x1,0x18(%rbp)
  404941:	78 22                	js     404965 <TMlist_remove+0x95>
        return TRUE;
    }

    return FALSE;
}
  404943:	48 83 c4 08          	add    $0x8,%rsp
        TM_SHARED_WRITE_P(prevPtr->nextPtr, TM_SHARED_READ_P(nodePtr->nextPtr));
        TM_SHARED_WRITE_P(nodePtr->nextPtr, (struct list_node*)NULL);
        TMfreeNode(TM_ARG  nodePtr);
        TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) - 1));
        assert(listPtr->size >= 0);
        return TRUE;
  404947:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return FALSE;
}
  40494c:	5b                   	pop    %rbx
  40494d:	5d                   	pop    %rbp
  40494e:	41 5c                	pop    %r12
  404950:	41 5d                	pop    %r13
  404952:	c3                   	retq   
  404953:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  404958:	48 83 c4 08          	add    $0x8,%rsp
        TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) - 1));
        assert(listPtr->size >= 0);
        return TRUE;
    }

    return FALSE;
  40495c:	31 c0                	xor    %eax,%eax
}
  40495e:	5b                   	pop    %rbx
  40495f:	5d                   	pop    %rbp
  404960:	41 5c                	pop    %r12
  404962:	41 5d                	pop    %r13
  404964:	c3                   	retq   
    {
        TM_SHARED_WRITE_P(prevPtr->nextPtr, TM_SHARED_READ_P(nodePtr->nextPtr));
        TM_SHARED_WRITE_P(nodePtr->nextPtr, (struct list_node*)NULL);
        TMfreeNode(TM_ARG  nodePtr);
        TM_SHARED_WRITE(listPtr->size, (TM_SHARED_READ(listPtr->size) - 1));
        assert(listPtr->size >= 0);
  404965:	b9 31 94 40 00       	mov    $0x409431,%ecx
  40496a:	ba f9 02 00 00       	mov    $0x2f9,%edx
  40496f:	be 10 94 40 00       	mov    $0x409410,%esi
  404974:	bf 1e 94 40 00       	mov    $0x40941e,%edi
  404979:	e8 d2 c2 ff ff       	callq  400c50 <__assert_fail@plt>
  40497e:	66 90                	xchg   %ax,%ax

0000000000404980 <list_clear>:
 * -- Removes all elements
 * =============================================================================
 */
void
list_clear (list_t* listPtr)
{
  404980:	41 57                	push   %r15
  404982:	41 56                	push   %r14
  404984:	41 55                	push   %r13
  404986:	41 54                	push   %r12
  404988:	55                   	push   %rbp
  404989:	53                   	push   %rbx
  40498a:	48 89 fb             	mov    %rdi,%rbx
  40498d:	48 83 ec 38          	sub    $0x38,%rsp
    freeList(listPtr->head.nextPtr);
  404991:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404995:	48 85 ed             	test   %rbp,%rbp
  404998:	0f 84 10 01 00 00    	je     404aae <list_clear+0x12e>
        freeList(nodePtr->nextPtr);
  40499e:	4c 8b 65 08          	mov    0x8(%rbp),%r12
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049a2:	4d 85 e4             	test   %r12,%r12
  4049a5:	0f 84 fb 00 00 00    	je     404aa6 <list_clear+0x126>
        freeList(nodePtr->nextPtr);
  4049ab:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049b0:	4d 85 ed             	test   %r13,%r13
  4049b3:	0f 84 e5 00 00 00    	je     404a9e <list_clear+0x11e>
        freeList(nodePtr->nextPtr);
  4049b9:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049bd:	4d 85 f6             	test   %r14,%r14
  4049c0:	0f 84 d0 00 00 00    	je     404a96 <list_clear+0x116>
        freeList(nodePtr->nextPtr);
  4049c6:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049ca:	4d 85 ff             	test   %r15,%r15
  4049cd:	0f 84 bb 00 00 00    	je     404a8e <list_clear+0x10e>
        freeList(nodePtr->nextPtr);
  4049d3:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049d7:	48 85 c0             	test   %rax,%rax
        freeList(nodePtr->nextPtr);
  4049da:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049df:	0f 84 a1 00 00 00    	je     404a86 <list_clear+0x106>
        freeList(nodePtr->nextPtr);
  4049e5:	48 8b 40 08          	mov    0x8(%rax),%rax
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049e9:	48 85 c0             	test   %rax,%rax
  4049ec:	0f 84 8a 00 00 00    	je     404a7c <list_clear+0xfc>
        freeList(nodePtr->nextPtr);
  4049f2:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049f6:	48 85 d2             	test   %rdx,%rdx
  4049f9:	74 79                	je     404a74 <list_clear+0xf4>
        freeList(nodePtr->nextPtr);
  4049fb:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  4049ff:	48 85 c9             	test   %rcx,%rcx
  404a02:	74 5e                	je     404a62 <list_clear+0xe2>
        freeList(nodePtr->nextPtr);
  404a04:	48 8b 71 08          	mov    0x8(%rcx),%rsi
 * =============================================================================
 */
static void
freeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404a08:	48 85 f6             	test   %rsi,%rsi
  404a0b:	74 39                	je     404a46 <list_clear+0xc6>
        freeList(nodePtr->nextPtr);
  404a0d:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  404a11:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  404a16:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
  404a1b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  404a20:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  404a25:	e8 c6 f2 ff ff       	callq  403cf0 <freeList>
 * =============================================================================
 */
static void
freeNode (list_node_t* nodePtr)
{
    free(nodePtr);
  404a2a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  404a2f:	48 89 f7             	mov    %rsi,%rdi
  404a32:	e8 79 c2 ff ff       	callq  400cb0 <free@plt>
  404a37:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  404a3c:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  404a41:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  404a46:	48 89 cf             	mov    %rcx,%rdi
  404a49:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  404a4e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  404a53:	e8 58 c2 ff ff       	callq  400cb0 <free@plt>
  404a58:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  404a5d:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404a62:	48 89 d7             	mov    %rdx,%rdi
  404a65:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  404a6a:	e8 41 c2 ff ff       	callq  400cb0 <free@plt>
  404a6f:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404a74:	48 89 c7             	mov    %rax,%rdi
  404a77:	e8 34 c2 ff ff       	callq  400cb0 <free@plt>
  404a7c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  404a81:	e8 2a c2 ff ff       	callq  400cb0 <free@plt>
  404a86:	4c 89 ff             	mov    %r15,%rdi
  404a89:	e8 22 c2 ff ff       	callq  400cb0 <free@plt>
  404a8e:	4c 89 f7             	mov    %r14,%rdi
  404a91:	e8 1a c2 ff ff       	callq  400cb0 <free@plt>
  404a96:	4c 89 ef             	mov    %r13,%rdi
  404a99:	e8 12 c2 ff ff       	callq  400cb0 <free@plt>
  404a9e:	4c 89 e7             	mov    %r12,%rdi
  404aa1:	e8 0a c2 ff ff       	callq  400cb0 <free@plt>
  404aa6:	48 89 ef             	mov    %rbp,%rdi
  404aa9:	e8 02 c2 ff ff       	callq  400cb0 <free@plt>
 */
void
list_clear (list_t* listPtr)
{
    freeList(listPtr->head.nextPtr);
    listPtr->head.nextPtr = NULL;
  404aae:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  404ab5:	00 
    listPtr->size = 0;
  404ab6:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  404abd:	00 
}
  404abe:	48 83 c4 38          	add    $0x38,%rsp
  404ac2:	5b                   	pop    %rbx
  404ac3:	5d                   	pop    %rbp
  404ac4:	41 5c                	pop    %r12
  404ac6:	41 5d                	pop    %r13
  404ac8:	41 5e                	pop    %r14
  404aca:	41 5f                	pop    %r15
  404acc:	c3                   	retq   
  404acd:	0f 1f 00             	nopl   (%rax)

0000000000404ad0 <Plist_clear>:
 * -- Removes all elements
 * =============================================================================
 */
void
Plist_clear (list_t* listPtr)
{
  404ad0:	41 57                	push   %r15
  404ad2:	41 56                	push   %r14
  404ad4:	41 55                	push   %r13
  404ad6:	41 54                	push   %r12
  404ad8:	55                   	push   %rbp
  404ad9:	53                   	push   %rbx
  404ada:	48 89 fb             	mov    %rdi,%rbx
  404add:	48 83 ec 38          	sub    $0x38,%rsp
    PfreeList(listPtr->head.nextPtr);
  404ae1:	48 8b 6f 08          	mov    0x8(%rdi),%rbp
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404ae5:	48 85 ed             	test   %rbp,%rbp
  404ae8:	0f 84 10 01 00 00    	je     404bfe <Plist_clear+0x12e>
        PfreeList(nodePtr->nextPtr);
  404aee:	4c 8b 65 08          	mov    0x8(%rbp),%r12
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404af2:	4d 85 e4             	test   %r12,%r12
  404af5:	0f 84 fb 00 00 00    	je     404bf6 <Plist_clear+0x126>
        PfreeList(nodePtr->nextPtr);
  404afb:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b00:	4d 85 ed             	test   %r13,%r13
  404b03:	0f 84 e5 00 00 00    	je     404bee <Plist_clear+0x11e>
        PfreeList(nodePtr->nextPtr);
  404b09:	4d 8b 75 08          	mov    0x8(%r13),%r14
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b0d:	4d 85 f6             	test   %r14,%r14
  404b10:	0f 84 d0 00 00 00    	je     404be6 <Plist_clear+0x116>
        PfreeList(nodePtr->nextPtr);
  404b16:	4d 8b 7e 08          	mov    0x8(%r14),%r15
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b1a:	4d 85 ff             	test   %r15,%r15
  404b1d:	0f 84 bb 00 00 00    	je     404bde <Plist_clear+0x10e>
        PfreeList(nodePtr->nextPtr);
  404b23:	49 8b 47 08          	mov    0x8(%r15),%rax
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b27:	48 85 c0             	test   %rax,%rax
        PfreeList(nodePtr->nextPtr);
  404b2a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b2f:	0f 84 a1 00 00 00    	je     404bd6 <Plist_clear+0x106>
        PfreeList(nodePtr->nextPtr);
  404b35:	48 8b 40 08          	mov    0x8(%rax),%rax
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b39:	48 85 c0             	test   %rax,%rax
  404b3c:	0f 84 8a 00 00 00    	je     404bcc <Plist_clear+0xfc>
        PfreeList(nodePtr->nextPtr);
  404b42:	48 8b 50 08          	mov    0x8(%rax),%rdx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b46:	48 85 d2             	test   %rdx,%rdx
  404b49:	74 79                	je     404bc4 <Plist_clear+0xf4>
        PfreeList(nodePtr->nextPtr);
  404b4b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b4f:	48 85 c9             	test   %rcx,%rcx
  404b52:	74 5e                	je     404bb2 <Plist_clear+0xe2>
        PfreeList(nodePtr->nextPtr);
  404b54:	48 8b 71 08          	mov    0x8(%rcx),%rsi
 * =============================================================================
 */
static void
PfreeList (list_node_t* nodePtr)
{
    if (nodePtr != NULL) {
  404b58:	48 85 f6             	test   %rsi,%rsi
  404b5b:	74 39                	je     404b96 <Plist_clear+0xc6>
        PfreeList(nodePtr->nextPtr);
  404b5d:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  404b61:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  404b66:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
  404b6b:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  404b70:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  404b75:	e8 86 f2 ff ff       	callq  403e00 <PfreeList>
 * =============================================================================
 */
static void
PfreeNode (list_node_t* nodePtr)
{
    P_FREE(nodePtr);
  404b7a:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  404b7f:	48 89 f7             	mov    %rsi,%rdi
  404b82:	e8 29 c1 ff ff       	callq  400cb0 <free@plt>
  404b87:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
  404b8c:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
  404b91:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  404b96:	48 89 cf             	mov    %rcx,%rdi
  404b99:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  404b9e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  404ba3:	e8 08 c1 ff ff       	callq  400cb0 <free@plt>
  404ba8:	48 8b 54 24 18       	mov    0x18(%rsp),%rdx
  404bad:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404bb2:	48 89 d7             	mov    %rdx,%rdi
  404bb5:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  404bba:	e8 f1 c0 ff ff       	callq  400cb0 <free@plt>
  404bbf:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  404bc4:	48 89 c7             	mov    %rax,%rdi
  404bc7:	e8 e4 c0 ff ff       	callq  400cb0 <free@plt>
  404bcc:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  404bd1:	e8 da c0 ff ff       	callq  400cb0 <free@plt>
  404bd6:	4c 89 ff             	mov    %r15,%rdi
  404bd9:	e8 d2 c0 ff ff       	callq  400cb0 <free@plt>
  404bde:	4c 89 f7             	mov    %r14,%rdi
  404be1:	e8 ca c0 ff ff       	callq  400cb0 <free@plt>
  404be6:	4c 89 ef             	mov    %r13,%rdi
  404be9:	e8 c2 c0 ff ff       	callq  400cb0 <free@plt>
  404bee:	4c 89 e7             	mov    %r12,%rdi
  404bf1:	e8 ba c0 ff ff       	callq  400cb0 <free@plt>
  404bf6:	48 89 ef             	mov    %rbp,%rdi
  404bf9:	e8 b2 c0 ff ff       	callq  400cb0 <free@plt>
 */
void
Plist_clear (list_t* listPtr)
{
    PfreeList(listPtr->head.nextPtr);
    listPtr->head.nextPtr = NULL;
  404bfe:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
  404c05:	00 
    listPtr->size = 0;
  404c06:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  404c0d:	00 
}
  404c0e:	48 83 c4 38          	add    $0x38,%rsp
  404c12:	5b                   	pop    %rbx
  404c13:	5d                   	pop    %rbp
  404c14:	41 5c                	pop    %r12
  404c16:	41 5d                	pop    %r13
  404c18:	41 5e                	pop    %r14
  404c1a:	41 5f                	pop    %r15
  404c1c:	c3                   	retq   
  404c1d:	0f 1f 00             	nopl   (%rax)

0000000000404c20 <pair_alloc>:
 * -- Returns NULL if failure
 * =============================================================================
 */
pair_t*
pair_alloc (void* firstPtr, void* secondPtr)
{
  404c20:	55                   	push   %rbp
  404c21:	48 89 f5             	mov    %rsi,%rbp
  404c24:	53                   	push   %rbx
  404c25:	48 89 fb             	mov    %rdi,%rbx
    pair_t* pairPtr;

    pairPtr = (pair_t*)malloc(sizeof(pair_t));
  404c28:	bf 10 00 00 00       	mov    $0x10,%edi
 * -- Returns NULL if failure
 * =============================================================================
 */
pair_t*
pair_alloc (void* firstPtr, void* secondPtr)
{
  404c2d:	48 83 ec 08          	sub    $0x8,%rsp
    pair_t* pairPtr;

    pairPtr = (pair_t*)malloc(sizeof(pair_t));
  404c31:	e8 4a c0 ff ff       	callq  400c80 <malloc@plt>
    if (pairPtr != NULL) {
  404c36:	48 85 c0             	test   %rax,%rax
  404c39:	74 07                	je     404c42 <pair_alloc+0x22>
        pairPtr->firstPtr = firstPtr;
  404c3b:	48 89 18             	mov    %rbx,(%rax)
        pairPtr->secondPtr = secondPtr;
  404c3e:	48 89 68 08          	mov    %rbp,0x8(%rax)
    }

    return pairPtr;
}
  404c42:	48 83 c4 08          	add    $0x8,%rsp
  404c46:	5b                   	pop    %rbx
  404c47:	5d                   	pop    %rbp
  404c48:	c3                   	retq   
  404c49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000404c50 <Ppair_alloc>:
 * -- Returns NULL if failure
 * =============================================================================
 */
pair_t*
Ppair_alloc (void* firstPtr, void* secondPtr)
{
  404c50:	55                   	push   %rbp
  404c51:	48 89 f5             	mov    %rsi,%rbp
  404c54:	53                   	push   %rbx
  404c55:	48 89 fb             	mov    %rdi,%rbx
    pair_t* pairPtr;

    pairPtr = (pair_t*)P_MALLOC(sizeof(pair_t));
  404c58:	bf 10 00 00 00       	mov    $0x10,%edi
 * -- Returns NULL if failure
 * =============================================================================
 */
pair_t*
Ppair_alloc (void* firstPtr, void* secondPtr)
{
  404c5d:	48 83 ec 08          	sub    $0x8,%rsp
    pair_t* pairPtr;

    pairPtr = (pair_t*)P_MALLOC(sizeof(pair_t));
  404c61:	e8 1a c0 ff ff       	callq  400c80 <malloc@plt>
    if (pairPtr != NULL) {
  404c66:	48 85 c0             	test   %rax,%rax
  404c69:	74 07                	je     404c72 <Ppair_alloc+0x22>
        pairPtr->firstPtr = firstPtr;
  404c6b:	48 89 18             	mov    %rbx,(%rax)
        pairPtr->secondPtr = secondPtr;
  404c6e:	48 89 68 08          	mov    %rbp,0x8(%rax)
    }

    return pairPtr;
}
  404c72:	48 83 c4 08          	add    $0x8,%rsp
  404c76:	5b                   	pop    %rbx
  404c77:	5d                   	pop    %rbp
  404c78:	c3                   	retq   
  404c79:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000404c80 <TMpair_alloc>:
 * -- Returns NULL if failure
 * =============================================================================
 */
pair_t*
TMpair_alloc (TM_ARGDECL  void* firstPtr, void* secondPtr)
{
  404c80:	55                   	push   %rbp
  404c81:	48 89 f5             	mov    %rsi,%rbp
  404c84:	53                   	push   %rbx
  404c85:	48 89 fb             	mov    %rdi,%rbx
    pair_t* pairPtr;

    pairPtr = (pair_t*)TM_MALLOC(sizeof(pair_t));
  404c88:	bf 10 00 00 00       	mov    $0x10,%edi
 * -- Returns NULL if failure
 * =============================================================================
 */
pair_t*
TMpair_alloc (TM_ARGDECL  void* firstPtr, void* secondPtr)
{
  404c8d:	48 83 ec 08          	sub    $0x8,%rsp
    pair_t* pairPtr;

    pairPtr = (pair_t*)TM_MALLOC(sizeof(pair_t));
  404c91:	e8 ea bf ff ff       	callq  400c80 <malloc@plt>
    if (pairPtr != NULL) {
  404c96:	48 85 c0             	test   %rax,%rax
  404c99:	74 07                	je     404ca2 <TMpair_alloc+0x22>
        pairPtr->firstPtr = firstPtr;
  404c9b:	48 89 18             	mov    %rbx,(%rax)
        pairPtr->secondPtr = secondPtr;
  404c9e:	48 89 68 08          	mov    %rbp,0x8(%rax)
    }

    return pairPtr;
}
  404ca2:	48 83 c4 08          	add    $0x8,%rsp
  404ca6:	5b                   	pop    %rbx
  404ca7:	5d                   	pop    %rbp
  404ca8:	c3                   	retq   
  404ca9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000404cb0 <pair_free>:
 * =============================================================================
 */
void
pair_free (pair_t* pairPtr)
{
    free(pairPtr);
  404cb0:	e9 fb bf ff ff       	jmpq   400cb0 <free@plt>
  404cb5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  404cbc:	00 00 00 00 

0000000000404cc0 <Ppair_free>:
 * =============================================================================
 */
void
Ppair_free (pair_t* pairPtr)
{
    P_FREE(pairPtr);
  404cc0:	e9 eb bf ff ff       	jmpq   400cb0 <free@plt>
  404cc5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  404ccc:	00 00 00 00 

0000000000404cd0 <TMpair_free>:
 * =============================================================================
 */
void
TMpair_free (TM_ARGDECL  pair_t* pairPtr)
{
    TM_FREE(pairPtr);
  404cd0:	e9 db bf ff ff       	jmpq   400cb0 <free@plt>
  404cd5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  404cdc:	00 00 00 00 

0000000000404ce0 <pair_swap>:
 * =============================================================================
 */
void
pair_swap (pair_t* pairPtr)
{
    void* tmpPtr = pairPtr->firstPtr;
  404ce0:	48 8b 07             	mov    (%rdi),%rax
    pairPtr->firstPtr = pairPtr->secondPtr;
  404ce3:	48 8b 57 08          	mov    0x8(%rdi),%rdx
    pairPtr->secondPtr = tmpPtr;
  404ce7:	48 89 47 08          	mov    %rax,0x8(%rdi)
 */
void
pair_swap (pair_t* pairPtr)
{
    void* tmpPtr = pairPtr->firstPtr;
    pairPtr->firstPtr = pairPtr->secondPtr;
  404ceb:	48 89 17             	mov    %rdx,(%rdi)
    pairPtr->secondPtr = tmpPtr;
  404cee:	c3                   	retq   
  404cef:	90                   	nop

0000000000404cf0 <init_genrand>:
/* initializes mt[N] with a seed */
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
  404cf0:	89 d1                	mov    %edx,%ecx
    for (mti=1; mti<N; mti++) {
  404cf2:	b8 01 00 00 00       	mov    $0x1,%eax
/* initializes mt[N] with a seed */
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
  404cf7:	48 89 0f             	mov    %rcx,(%rdi)
  404cfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    for (mti=1; mti<N; mti++) {
        mt[mti] =
          (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
  404d00:	48 89 ca             	mov    %rcx,%rdx
  404d03:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404d07:	48 31 ca             	xor    %rcx,%rdx
  404d0a:	48 69 ca 65 89 07 6c 	imul   $0x6c078965,%rdx,%rcx
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
  404d11:	01 c1                	add    %eax,%ecx
  404d13:	48 89 0c c7          	mov    %rcx,(%rdi,%rax,8)
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
  404d17:	48 83 c0 01          	add    $0x1,%rax
  404d1b:	48 3d 70 02 00 00    	cmp    $0x270,%rax
  404d21:	75 dd                	jne    404d00 <init_genrand+0x10>
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }

    (*mtiPtr) = mti;
  404d23:	48 c7 06 70 02 00 00 	movq   $0x270,(%rsi)
  404d2a:	c3                   	retq   
  404d2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000404d30 <init_by_array>:
/* initializes mt[N] with a seed */
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
  404d30:	48 c7 07 aa d6 2b 01 	movq   $0x12bd6aa,(%rdi)
  404d37:	41 b9 aa d6 2b 01    	mov    $0x12bd6aa,%r9d
    for (mti=1; mti<N; mti++) {
  404d3d:	b8 01 00 00 00       	mov    $0x1,%eax
  404d42:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        mt[mti] =
          (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
  404d48:	4d 89 c8             	mov    %r9,%r8
  404d4b:	49 c1 e8 1e          	shr    $0x1e,%r8
  404d4f:	4d 31 c8             	xor    %r9,%r8
  404d52:	4d 69 c8 65 89 07 6c 	imul   $0x6c078965,%r8,%r9
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
  404d59:	41 01 c1             	add    %eax,%r9d
  404d5c:	4c 89 0c c7          	mov    %r9,(%rdi,%rax,8)
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
  404d60:	48 83 c0 01          	add    $0x1,%rax
  404d64:	48 3d 70 02 00 00    	cmp    $0x270,%rax
  404d6a:	75 dc                	jne    404d48 <init_by_array+0x18>
/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long mt[], unsigned long * mtiPtr, unsigned long init_key[], long key_length)
{
  404d6c:	41 54                	push   %r12
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
  404d6e:	48 81 f9 70 02 00 00 	cmp    $0x270,%rcx
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }

    (*mtiPtr) = mti;
  404d75:	48 c7 06 70 02 00 00 	movq   $0x270,(%rsi)
void init_by_array(unsigned long mt[], unsigned long * mtiPtr, unsigned long init_key[], long key_length)
{
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
  404d7c:	48 0f 4d c1          	cmovge %rcx,%rax
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long mt[], unsigned long * mtiPtr, unsigned long init_key[], long key_length)
{
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
  404d80:	45 31 c0             	xor    %r8d,%r8d
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
  404d83:	45 31 e4             	xor    %r12d,%r12d
/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long mt[], unsigned long * mtiPtr, unsigned long init_key[], long key_length)
{
  404d86:	55                   	push   %rbp
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
  404d87:	49 89 c2             	mov    %rax,%r10
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long mt[], unsigned long * mtiPtr, unsigned long init_key[], long key_length)
{
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
  404d8a:	b8 01 00 00 00       	mov    $0x1,%eax
/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
void init_by_array(unsigned long mt[], unsigned long * mtiPtr, unsigned long init_key[], long key_length)
{
  404d8f:	53                   	push   %rbx
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
  404d90:	4c 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%r9
  404d97:	00 
          + init_key[j] + j; /* non linear */
  404d98:	4c 89 c5             	mov    %r8,%rbp
  404d9b:	4a 03 2c c2          	add    (%rdx,%r8,8),%rbp
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
  404d9f:	48 83 c0 01          	add    $0x1,%rax
  404da3:	49 83 c0 01          	add    $0x1,%r8
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
  404da7:	4a 8b 5c 0f f8       	mov    -0x8(%rdi,%r9,1),%rbx
  404dac:	4e 8d 1c 0f          	lea    (%rdi,%r9,1),%r11
  404db0:	49 89 d9             	mov    %rbx,%r9
  404db3:	49 c1 e9 1e          	shr    $0x1e,%r9
  404db7:	49 31 d9             	xor    %rbx,%r9
  404dba:	4d 69 c9 0d 66 19 00 	imul   $0x19660d,%r9,%r9
  404dc1:	4d 33 0b             	xor    (%r11),%r9
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
  404dc4:	41 01 e9             	add    %ebp,%r9d
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
  404dc7:	48 3d 6f 02 00 00    	cmp    $0x26f,%rax
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
          + init_key[j] + j; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
  404dcd:	4d 89 0b             	mov    %r9,(%r11)
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
  404dd0:	7e 0f                	jle    404de1 <init_by_array+0xb1>
  404dd2:	48 8b 87 78 13 00 00 	mov    0x1378(%rdi),%rax
  404dd9:	48 89 07             	mov    %rax,(%rdi)
  404ddc:	b8 01 00 00 00       	mov    $0x1,%eax
        if (j>=key_length) j=0;
  404de1:	4c 39 c1             	cmp    %r8,%rcx
  404de4:	4d 0f 4e c4          	cmovle %r12,%r8
{
    long i, j, k;
    init_genrand(mt, mtiPtr, 19650218UL);
    i=1; j=0;
    k = (N>key_length ? N : key_length);
    for (; k; k--) {
  404de8:	49 83 ea 01          	sub    $0x1,%r10
  404dec:	75 a2                	jne    404d90 <init_by_array+0x60>
  404dee:	b9 6f 02 00 00       	mov    $0x26f,%ecx
  404df3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
  404df8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  404dff:	00 
  404e00:	4c 8b 4c 17 f8       	mov    -0x8(%rdi,%rdx,1),%r9
  404e05:	4c 8d 04 17          	lea    (%rdi,%rdx,1),%r8
  404e09:	4c 89 ca             	mov    %r9,%rdx
  404e0c:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404e10:	4c 31 ca             	xor    %r9,%rdx
  404e13:	48 69 d2 65 8b 58 5d 	imul   $0x5d588b65,%rdx,%rdx
  404e1a:	49 33 10             	xor    (%r8),%rdx
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
  404e1d:	29 c2                	sub    %eax,%edx
        i++;
  404e1f:	48 83 c0 01          	add    $0x1,%rax
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
  404e23:	48 3d 6f 02 00 00    	cmp    $0x26f,%rax
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
          - i; /* non linear */
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
  404e29:	49 89 10             	mov    %rdx,(%r8)
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
  404e2c:	7e 0f                	jle    404e3d <init_by_array+0x10d>
  404e2e:	48 8b 87 78 13 00 00 	mov    0x1378(%rdi),%rax
  404e35:	48 89 07             	mov    %rax,(%rdi)
  404e38:	b8 01 00 00 00       	mov    $0x1,%eax
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++; j++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=N-1; k; k--) {
  404e3d:	48 83 e9 01          	sub    $0x1,%rcx
  404e41:	75 b5                	jne    404df8 <init_by_array+0xc8>
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
    (*mtiPtr) = N + 1;
}
  404e43:	5b                   	pop    %rbx
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
  404e44:	b8 00 00 00 80       	mov    $0x80000000,%eax
    (*mtiPtr) = N + 1;
}
  404e49:	5d                   	pop    %rbp
        mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
        i++;
        if (i>=N) { mt[0] = mt[N-1]; i=1; }
    }

    mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
  404e4a:	48 89 07             	mov    %rax,(%rdi)
    (*mtiPtr) = N + 1;
  404e4d:	48 c7 06 71 02 00 00 	movq   $0x271,(%rsi)
}
  404e54:	41 5c                	pop    %r12
  404e56:	c3                   	retq   
  404e57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  404e5e:	00 00 

0000000000404e60 <genrand_int32>:
/* generates a random number on [0,0xffffffff]-interval */
unsigned long genrand_int32(unsigned long mt[], unsigned long * mtiPtr)
{
    unsigned long y;
    static unsigned long mag01[2]={0x0UL, MATRIX_A};
    unsigned long mti = (*mtiPtr);
  404e60:	48 8b 06             	mov    (%rsi),%rax

    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
  404e63:	48 3d 6f 02 00 00    	cmp    $0x26f,%rax
  404e69:	0f 86 25 01 00 00    	jbe    404f94 <genrand_int32+0x134>
        long kk;

        if (mti == N+1)   /* if init_genrand() has not been called, */
  404e6f:	48 3d 71 02 00 00    	cmp    $0x271,%rax
  404e75:	0f 84 23 01 00 00    	je     404f9e <genrand_int32+0x13e>
            init_genrand(mt, mtiPtr, 5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
  404e7b:	48 8b 17             	mov    (%rdi),%rdx
  404e7e:	31 c0                	xor    %eax,%eax
  404e80:	eb 09                	jmp    404e8b <genrand_int32+0x2b>
  404e82:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  404e88:	4c 89 c2             	mov    %r8,%rdx
  404e8b:	4c 8b 44 c7 08       	mov    0x8(%rdi,%rax,8),%r8
  404e90:	81 e2 00 00 00 80    	and    $0x80000000,%edx
  404e96:	4c 89 c1             	mov    %r8,%rcx
  404e99:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  404e9f:	48 09 d1             	or     %rdx,%rcx
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
  404ea2:	48 89 ca             	mov    %rcx,%rdx
  404ea5:	83 e1 01             	and    $0x1,%ecx
  404ea8:	48 d1 ea             	shr    %rdx
  404eab:	48 33 94 c7 68 0c 00 	xor    0xc68(%rdi,%rax,8),%rdx
  404eb2:	00 
  404eb3:	48 33 14 cd 60 94 40 	xor    0x409460(,%rcx,8),%rdx
  404eba:	00 
  404ebb:	48 89 14 c7          	mov    %rdx,(%rdi,%rax,8)
        long kk;

        if (mti == N+1)   /* if init_genrand() has not been called, */
            init_genrand(mt, mtiPtr, 5489UL); /* a default initial seed is used */

        for (kk=0;kk<N-M;kk++) {
  404ebf:	48 83 c0 01          	add    $0x1,%rax
  404ec3:	48 3d e3 00 00 00    	cmp    $0xe3,%rax
  404ec9:	75 bd                	jne    404e88 <genrand_int32+0x28>
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
  404ecb:	48 8b 97 18 07 00 00 	mov    0x718(%rdi),%rdx
  404ed2:	eb 07                	jmp    404edb <genrand_int32+0x7b>
  404ed4:	0f 1f 40 00          	nopl   0x0(%rax)
  404ed8:	4c 89 c2             	mov    %r8,%rdx
  404edb:	4c 8b 44 c7 08       	mov    0x8(%rdi,%rax,8),%r8
  404ee0:	81 e2 00 00 00 80    	and    $0x80000000,%edx
  404ee6:	4c 89 c1             	mov    %r8,%rcx
  404ee9:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  404eef:	48 09 d1             	or     %rdx,%rcx
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
  404ef2:	48 89 ca             	mov    %rcx,%rdx
  404ef5:	83 e1 01             	and    $0x1,%ecx
  404ef8:	48 d1 ea             	shr    %rdx
  404efb:	48 33 94 c7 e8 f8 ff 	xor    -0x718(%rdi,%rax,8),%rdx
  404f02:	ff 
  404f03:	48 33 14 cd 60 94 40 	xor    0x409460(,%rcx,8),%rdx
  404f0a:	00 
  404f0b:	48 89 14 c7          	mov    %rdx,(%rdi,%rax,8)

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        for (;kk<N-1;kk++) {
  404f0f:	48 83 c0 01          	add    $0x1,%rax
  404f13:	48 3d 6f 02 00 00    	cmp    $0x26f,%rax
  404f19:	75 bd                	jne    404ed8 <genrand_int32+0x78>
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
  404f1b:	48 8b 97 78 13 00 00 	mov    0x1378(%rdi),%rdx
  404f22:	48 8b 07             	mov    (%rdi),%rax
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
  404f25:	b9 01 00 00 00       	mov    $0x1,%ecx
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
  404f2a:	81 e2 00 00 00 80    	and    $0x80000000,%edx
  404f30:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
  404f35:	48 09 d0             	or     %rdx,%rax
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
  404f38:	48 89 c2             	mov    %rax,%rdx
  404f3b:	83 e0 01             	and    $0x1,%eax
  404f3e:	48 d1 ea             	shr    %rdx
  404f41:	48 33 97 60 0c 00 00 	xor    0xc60(%rdi),%rdx
  404f48:	48 33 14 c5 60 94 40 	xor    0x409460(,%rax,8),%rdx
  404f4f:	00 
  404f50:	31 c0                	xor    %eax,%eax
  404f52:	48 89 97 78 13 00 00 	mov    %rdx,0x1378(%rdi)

        mti = 0;
    }

    y = mt[mti++];
  404f59:	48 8b 04 07          	mov    (%rdi,%rax,1),%rax
    y ^= (y >> 11);
    y ^= (y << 7) & 0x9d2c5680UL;
    y ^= (y << 15) & 0xefc60000UL;
    y ^= (y >> 18);

    (*mtiPtr) = mti;
  404f5d:	48 89 0e             	mov    %rcx,(%rsi)
    }

    y = mt[mti++];

    /* Tempering */
    y ^= (y >> 11);
  404f60:	48 89 c2             	mov    %rax,%rdx
  404f63:	48 c1 ea 0b          	shr    $0xb,%rdx
  404f67:	48 31 c2             	xor    %rax,%rdx
    y ^= (y << 7) & 0x9d2c5680UL;
  404f6a:	48 89 d0             	mov    %rdx,%rax
  404f6d:	48 c1 e0 07          	shl    $0x7,%rax
  404f71:	25 80 56 2c 9d       	and    $0x9d2c5680,%eax
  404f76:	48 31 d0             	xor    %rdx,%rax
    y ^= (y << 15) & 0xefc60000UL;
  404f79:	48 89 c2             	mov    %rax,%rdx
  404f7c:	48 c1 e2 0f          	shl    $0xf,%rdx
  404f80:	81 e2 00 00 c6 ef    	and    $0xefc60000,%edx
  404f86:	48 31 c2             	xor    %rax,%rdx
    y ^= (y >> 18);
  404f89:	48 89 d0             	mov    %rdx,%rax
  404f8c:	48 c1 e8 12          	shr    $0x12,%rax
  404f90:	48 31 d0             	xor    %rdx,%rax

    (*mtiPtr) = mti;

    return y;
}
  404f93:	c3                   	retq   
  404f94:	48 8d 48 01          	lea    0x1(%rax),%rcx
  404f98:	48 c1 e0 03          	shl    $0x3,%rax
  404f9c:	eb bb                	jmp    404f59 <genrand_int32+0xf9>
/* initializes mt[N] with a seed */
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
  404f9e:	48 c7 07 71 15 00 00 	movq   $0x1571,(%rdi)
  404fa5:	b9 71 15 00 00       	mov    $0x1571,%ecx
    for (mti=1; mti<N; mti++) {
  404faa:	66 b8 01 00          	mov    $0x1,%ax
  404fae:	66 90                	xchg   %ax,%ax
        mt[mti] =
          (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
  404fb0:	48 89 ca             	mov    %rcx,%rdx
  404fb3:	48 c1 ea 1e          	shr    $0x1e,%rdx
  404fb7:	48 31 ca             	xor    %rcx,%rdx
  404fba:	48 69 ca 65 89 07 6c 	imul   $0x6c078965,%rdx,%rcx
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array mt[].                        */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
  404fc1:	01 c1                	add    %eax,%ecx
  404fc3:	48 89 0c c7          	mov    %rcx,(%rdi,%rax,8)
void init_genrand(unsigned long mt[], unsigned long * mtiPtr, unsigned long s)
{
    unsigned long mti;

    mt[0]= s & 0xffffffffUL;
    for (mti=1; mti<N; mti++) {
  404fc7:	48 83 c0 01          	add    $0x1,%rax
  404fcb:	48 3d 70 02 00 00    	cmp    $0x270,%rax
  404fd1:	75 dd                	jne    404fb0 <genrand_int32+0x150>
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt[mti] &= 0xffffffffUL;
        /* for >32 bit machines */
    }

    (*mtiPtr) = mti;
  404fd3:	48 c7 06 70 02 00 00 	movq   $0x270,(%rsi)
  404fda:	e9 9c fe ff ff       	jmpq   404e7b <genrand_int32+0x1b>
  404fdf:	90                   	nop

0000000000404fe0 <genrand_int31>:
}

/* generates a random number on [0,0x7fffffff]-interval */
long genrand_int31(unsigned long mt[], unsigned long * mtiPtr)
{
    return (long)(genrand_int32(mt, mtiPtr)>>1);
  404fe0:	e8 7b fe ff ff       	callq  404e60 <genrand_int32>
  404fe5:	48 d1 e8             	shr    %rax
}
  404fe8:	c3                   	retq   
  404fe9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000404ff0 <genrand_real1>:

/* generates a random number on [0,1]-real-interval */
double genrand_real1(unsigned long mt[], unsigned long * mtiPtr)
{
    return genrand_int32(mt, mtiPtr)*(1.0/4294967295.0);
  404ff0:	e8 6b fe ff ff       	callq  404e60 <genrand_int32>
  404ff5:	48 85 c0             	test   %rax,%rax
  404ff8:	78 16                	js     405010 <genrand_real1+0x20>
  404ffa:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  404fff:	f2 0f 59 05 69 44 00 	mulsd  0x4469(%rip),%xmm0        # 409470 <mag01.2267+0x10>
  405006:	00 
    /* divided by 2^32-1 */
}
  405007:	c3                   	retq   
  405008:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40500f:	00 
}

/* generates a random number on [0,1]-real-interval */
double genrand_real1(unsigned long mt[], unsigned long * mtiPtr)
{
    return genrand_int32(mt, mtiPtr)*(1.0/4294967295.0);
  405010:	48 89 c2             	mov    %rax,%rdx
  405013:	83 e0 01             	and    $0x1,%eax
  405016:	48 d1 ea             	shr    %rdx
  405019:	48 09 c2             	or     %rax,%rdx
  40501c:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  405021:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  405025:	f2 0f 59 05 43 44 00 	mulsd  0x4443(%rip),%xmm0        # 409470 <mag01.2267+0x10>
  40502c:	00 
    /* divided by 2^32-1 */
}
  40502d:	c3                   	retq   
  40502e:	66 90                	xchg   %ax,%ax

0000000000405030 <genrand_real2>:

/* generates a random number on [0,1)-real-interval */
double genrand_real2(unsigned long mt[], unsigned long * mtiPtr)
{
    return genrand_int32(mt, mtiPtr)*(1.0/4294967296.0);
  405030:	e8 2b fe ff ff       	callq  404e60 <genrand_int32>
  405035:	48 85 c0             	test   %rax,%rax
  405038:	78 16                	js     405050 <genrand_real2+0x20>
  40503a:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40503f:	f2 0f 59 05 31 44 00 	mulsd  0x4431(%rip),%xmm0        # 409478 <mag01.2267+0x18>
  405046:	00 
    /* divided by 2^32 */
}
  405047:	c3                   	retq   
  405048:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40504f:	00 
}

/* generates a random number on [0,1)-real-interval */
double genrand_real2(unsigned long mt[], unsigned long * mtiPtr)
{
    return genrand_int32(mt, mtiPtr)*(1.0/4294967296.0);
  405050:	48 89 c2             	mov    %rax,%rdx
  405053:	83 e0 01             	and    $0x1,%eax
  405056:	48 d1 ea             	shr    %rdx
  405059:	48 09 c2             	or     %rax,%rdx
  40505c:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  405061:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  405065:	f2 0f 59 05 0b 44 00 	mulsd  0x440b(%rip),%xmm0        # 409478 <mag01.2267+0x18>
  40506c:	00 
    /* divided by 2^32 */
}
  40506d:	c3                   	retq   
  40506e:	66 90                	xchg   %ax,%ax

0000000000405070 <genrand_real3>:

/* generates a random number on (0,1)-real-interval */
double genrand_real3(unsigned long mt[], unsigned long * mtiPtr)
{
    return (((double)genrand_int32(mt, mtiPtr)) + 0.5)*(1.0/4294967296.0);
  405070:	e8 eb fd ff ff       	callq  404e60 <genrand_int32>
  405075:	48 85 c0             	test   %rax,%rax
  405078:	78 16                	js     405090 <genrand_real3+0x20>
  40507a:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  40507f:	f2 0f 58 05 21 43 00 	addsd  0x4321(%rip),%xmm0        # 4093a8 <__PRETTY_FUNCTION__.3923+0x16>
  405086:	00 
  405087:	f2 0f 59 05 e9 43 00 	mulsd  0x43e9(%rip),%xmm0        # 409478 <mag01.2267+0x18>
  40508e:	00 
    /* divided by 2^32 */
}
  40508f:	c3                   	retq   
}

/* generates a random number on (0,1)-real-interval */
double genrand_real3(unsigned long mt[], unsigned long * mtiPtr)
{
    return (((double)genrand_int32(mt, mtiPtr)) + 0.5)*(1.0/4294967296.0);
  405090:	48 89 c2             	mov    %rax,%rdx
  405093:	83 e0 01             	and    $0x1,%eax
  405096:	48 d1 ea             	shr    %rdx
  405099:	48 09 c2             	or     %rax,%rdx
  40509c:	f2 48 0f 2a c2       	cvtsi2sd %rdx,%xmm0
  4050a1:	f2 0f 58 c0          	addsd  %xmm0,%xmm0
  4050a5:	eb d8                	jmp    40507f <genrand_real3+0xf>
  4050a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4050ae:	00 00 

00000000004050b0 <genrand_res53>:
    /* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(unsigned long mt[], unsigned long * mtiPtr)
{
  4050b0:	41 54                	push   %r12
  4050b2:	55                   	push   %rbp
  4050b3:	48 89 f5             	mov    %rsi,%rbp
  4050b6:	53                   	push   %rbx
  4050b7:	48 89 fb             	mov    %rdi,%rbx
    unsigned long a=genrand_int32(mt, mtiPtr)>>5, b=genrand_int32(mt, mtiPtr)>>6;
  4050ba:	e8 a1 fd ff ff       	callq  404e60 <genrand_int32>
  4050bf:	49 89 c4             	mov    %rax,%r12
  4050c2:	48 89 ee             	mov    %rbp,%rsi
  4050c5:	48 89 df             	mov    %rbx,%rdi
  4050c8:	49 c1 ec 05          	shr    $0x5,%r12
  4050cc:	e8 8f fd ff ff       	callq  404e60 <genrand_int32>
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  4050d1:	f2 49 0f 2a c4       	cvtsi2sd %r12,%xmm0
}

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(unsigned long mt[], unsigned long * mtiPtr)
{
    unsigned long a=genrand_int32(mt, mtiPtr)>>5, b=genrand_int32(mt, mtiPtr)>>6;
  4050d6:	48 c1 e8 06          	shr    $0x6,%rax
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  4050da:	f2 48 0f 2a c8       	cvtsi2sd %rax,%xmm1
}
  4050df:	5b                   	pop    %rbx
  4050e0:	5d                   	pop    %rbp
  4050e1:	41 5c                	pop    %r12

/* generates a random number on [0,1) with 53-bit resolution*/
double genrand_res53(unsigned long mt[], unsigned long * mtiPtr)
{
    unsigned long a=genrand_int32(mt, mtiPtr)>>5, b=genrand_int32(mt, mtiPtr)>>6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  4050e3:	f2 0f 59 05 e5 42 00 	mulsd  0x42e5(%rip),%xmm0        # 4093d0 <__PRETTY_FUNCTION__.3923+0x3e>
  4050ea:	00 
  4050eb:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  4050ef:	f2 0f 59 05 89 43 00 	mulsd  0x4389(%rip),%xmm0        # 409480 <mag01.2267+0x20>
  4050f6:	00 
}
  4050f7:	c3                   	retq   
  4050f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4050ff:	00 

0000000000405100 <random_alloc>:
 * -- Returns NULL if failure
 * =============================================================================
 */
random_t*
random_alloc (void)
{
  405100:	53                   	push   %rbx
    random_t* randomPtr = (random_t*)malloc(sizeof(random_t));
  405101:	bf 90 13 00 00       	mov    $0x1390,%edi
  405106:	e8 75 bb ff ff       	callq  400c80 <malloc@plt>
    if (randomPtr != NULL) {
  40510b:	48 85 c0             	test   %rax,%rax
 * =============================================================================
 */
random_t*
random_alloc (void)
{
    random_t* randomPtr = (random_t*)malloc(sizeof(random_t));
  40510e:	48 89 c3             	mov    %rax,%rbx
    if (randomPtr != NULL) {
  405111:	74 1d                	je     405130 <random_alloc+0x30>
        randomPtr->mti = N;
        init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
  405113:	48 8d b0 88 13 00 00 	lea    0x1388(%rax),%rsi
  40511a:	48 8d 78 08          	lea    0x8(%rax),%rdi
random_t*
random_alloc (void)
{
    random_t* randomPtr = (random_t*)malloc(sizeof(random_t));
    if (randomPtr != NULL) {
        randomPtr->mti = N;
  40511e:	48 c7 80 88 13 00 00 	movq   $0x270,0x1388(%rax)
  405125:	70 02 00 00 
        init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
  405129:	31 d2                	xor    %edx,%edx
  40512b:	e8 c0 fb ff ff       	callq  404cf0 <init_genrand>
    }

    return randomPtr;
}
  405130:	48 89 d8             	mov    %rbx,%rax
  405133:	5b                   	pop    %rbx
  405134:	c3                   	retq   
  405135:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40513c:	00 00 00 00 

0000000000405140 <Prandom_alloc>:
 * -- Returns NULL if failure
 * =============================================================================
 */
random_t*
Prandom_alloc (void)
{
  405140:	53                   	push   %rbx
    random_t* randomPtr = (random_t*)P_MALLOC(sizeof(random_t));
  405141:	bf 90 13 00 00       	mov    $0x1390,%edi
  405146:	e8 35 bb ff ff       	callq  400c80 <malloc@plt>
    if (randomPtr != NULL) {
  40514b:	48 85 c0             	test   %rax,%rax
 * =============================================================================
 */
random_t*
Prandom_alloc (void)
{
    random_t* randomPtr = (random_t*)P_MALLOC(sizeof(random_t));
  40514e:	48 89 c3             	mov    %rax,%rbx
    if (randomPtr != NULL) {
  405151:	74 1d                	je     405170 <Prandom_alloc+0x30>
        randomPtr->mti = N;
        init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
  405153:	48 8d b0 88 13 00 00 	lea    0x1388(%rax),%rsi
  40515a:	48 8d 78 08          	lea    0x8(%rax),%rdi
random_t*
Prandom_alloc (void)
{
    random_t* randomPtr = (random_t*)P_MALLOC(sizeof(random_t));
    if (randomPtr != NULL) {
        randomPtr->mti = N;
  40515e:	48 c7 80 88 13 00 00 	movq   $0x270,0x1388(%rax)
  405165:	70 02 00 00 
        init_genrand(randomPtr->mt, &(randomPtr->mti), RANDOM_DEFAULT_SEED);
  405169:	31 d2                	xor    %edx,%edx
  40516b:	e8 80 fb ff ff       	callq  404cf0 <init_genrand>
    }

    return randomPtr;
}
  405170:	48 89 d8             	mov    %rbx,%rax
  405173:	5b                   	pop    %rbx
  405174:	c3                   	retq   
  405175:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40517c:	00 00 00 00 

0000000000405180 <random_free>:
 * =============================================================================
 */
void
random_free (random_t* randomPtr)
{
    free(randomPtr);
  405180:	e9 2b bb ff ff       	jmpq   400cb0 <free@plt>
  405185:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40518c:	00 00 00 00 

0000000000405190 <Prandom_free>:
 * =============================================================================
 */
void
Prandom_free (random_t* randomPtr)
{
    P_FREE(randomPtr);
  405190:	e9 1b bb ff ff       	jmpq   400cb0 <free@plt>
  405195:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40519c:	00 00 00 00 

00000000004051a0 <random_seed>:
 * random_seed
 * =============================================================================
 */
void
random_seed (random_t* randomPtr, unsigned long seed)
{
  4051a0:	48 89 f2             	mov    %rsi,%rdx
    init_genrand(randomPtr->mt, &(randomPtr->mti), seed);
  4051a3:	48 8d b7 88 13 00 00 	lea    0x1388(%rdi),%rsi
  4051aa:	48 83 c7 08          	add    $0x8,%rdi
  4051ae:	e9 3d fb ff ff       	jmpq   404cf0 <init_genrand>
  4051b3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4051ba:	84 00 00 00 00 00 

00000000004051c0 <random_generate>:
 * =============================================================================
 */
unsigned long
random_generate (random_t* randomPtr)
{
    return genrand_int32(randomPtr->mt, &(randomPtr->mti));
  4051c0:	48 8d b7 88 13 00 00 	lea    0x1388(%rdi),%rsi
  4051c7:	48 83 c7 08          	add    $0x8,%rdi
  4051cb:	e9 90 fc ff ff       	jmpq   404e60 <genrand_int32>

00000000004051d0 <compareKeysDefault>:
 * compareKeysDefault
 * =============================================================================
 */
static long
compareKeysDefault (const void* a, const void* b)
{
  4051d0:	48 89 f8             	mov    %rdi,%rax
    return ((long)a - (long)b);
  4051d3:	48 29 f0             	sub    %rsi,%rax
}
  4051d6:	c3                   	retq   
  4051d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4051de:	00 00 

00000000004051e0 <TMfreeNode>:
 * TMfreeNode
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
  4051e0:	41 57                	push   %r15
  4051e2:	41 56                	push   %r14
  4051e4:	41 55                	push   %r13
  4051e6:	41 54                	push   %r12
  4051e8:	55                   	push   %rbp
  4051e9:	53                   	push   %rbx
  4051ea:	48 89 fb             	mov    %rdi,%rbx
  4051ed:	48 83 ec 08          	sub    $0x8,%rsp
    if (n) {
  4051f1:	48 85 ff             	test   %rdi,%rdi
  4051f4:	0f 84 b6 06 00 00    	je     4058b0 <TMfreeNode+0x6d0>
        TMfreeNode(TM_ARG  n->l);
  4051fa:	48 8b 6f 18          	mov    0x18(%rdi),%rbp
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4051fe:	48 85 ed             	test   %rbp,%rbp
  405201:	0f 84 42 03 00 00    	je     405549 <TMfreeNode+0x369>
        TMfreeNode(TM_ARG  n->l);
  405207:	4c 8b 65 18          	mov    0x18(%rbp),%r12
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40520b:	4d 85 e4             	test   %r12,%r12
  40520e:	0f 84 90 01 00 00    	je     4053a4 <TMfreeNode+0x1c4>
        TMfreeNode(TM_ARG  n->l);
  405214:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405219:	4d 85 ed             	test   %r13,%r13
  40521c:	0f 84 b6 00 00 00    	je     4052d8 <TMfreeNode+0xf8>
        TMfreeNode(TM_ARG  n->l);
  405222:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405226:	4d 85 f6             	test   %r14,%r14
  405229:	74 4e                	je     405279 <TMfreeNode+0x99>
        TMfreeNode(TM_ARG  n->l);
  40522b:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40522f:	4d 85 ff             	test   %r15,%r15
  405232:	74 1a                	je     40524e <TMfreeNode+0x6e>
        TMfreeNode(TM_ARG  n->l);
  405234:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405238:	e8 a3 ff ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  40523d:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405241:	e8 9a ff ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405246:	4c 89 ff             	mov    %r15,%rdi
  405249:	e8 62 ba ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  40524e:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405252:	4d 85 ff             	test   %r15,%r15
  405255:	74 1a                	je     405271 <TMfreeNode+0x91>
        TMfreeNode(TM_ARG  n->l);
  405257:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40525b:	e8 80 ff ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405260:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405264:	e8 77 ff ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405269:	4c 89 ff             	mov    %r15,%rdi
  40526c:	e8 3f ba ff ff       	callq  400cb0 <free@plt>
  405271:	4c 89 f7             	mov    %r14,%rdi
  405274:	e8 37 ba ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405279:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40527d:	4d 85 f6             	test   %r14,%r14
  405280:	74 4e                	je     4052d0 <TMfreeNode+0xf0>
        TMfreeNode(TM_ARG  n->l);
  405282:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405286:	4d 85 ff             	test   %r15,%r15
  405289:	74 1a                	je     4052a5 <TMfreeNode+0xc5>
        TMfreeNode(TM_ARG  n->l);
  40528b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40528f:	e8 4c ff ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405294:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405298:	e8 43 ff ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40529d:	4c 89 ff             	mov    %r15,%rdi
  4052a0:	e8 0b ba ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4052a5:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4052a9:	4d 85 ff             	test   %r15,%r15
  4052ac:	74 1a                	je     4052c8 <TMfreeNode+0xe8>
        TMfreeNode(TM_ARG  n->l);
  4052ae:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4052b2:	e8 29 ff ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4052b7:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4052bb:	e8 20 ff ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4052c0:	4c 89 ff             	mov    %r15,%rdi
  4052c3:	e8 e8 b9 ff ff       	callq  400cb0 <free@plt>
  4052c8:	4c 89 f7             	mov    %r14,%rdi
  4052cb:	e8 e0 b9 ff ff       	callq  400cb0 <free@plt>
  4052d0:	4c 89 ef             	mov    %r13,%rdi
  4052d3:	e8 d8 b9 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4052d8:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4052dd:	4d 85 ed             	test   %r13,%r13
  4052e0:	0f 84 b6 00 00 00    	je     40539c <TMfreeNode+0x1bc>
        TMfreeNode(TM_ARG  n->l);
  4052e6:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4052ea:	4d 85 f6             	test   %r14,%r14
  4052ed:	74 4e                	je     40533d <TMfreeNode+0x15d>
        TMfreeNode(TM_ARG  n->l);
  4052ef:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4052f3:	4d 85 ff             	test   %r15,%r15
  4052f6:	74 1a                	je     405312 <TMfreeNode+0x132>
        TMfreeNode(TM_ARG  n->l);
  4052f8:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4052fc:	e8 df fe ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405301:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405305:	e8 d6 fe ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40530a:	4c 89 ff             	mov    %r15,%rdi
  40530d:	e8 9e b9 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405312:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405316:	4d 85 ff             	test   %r15,%r15
  405319:	74 1a                	je     405335 <TMfreeNode+0x155>
        TMfreeNode(TM_ARG  n->l);
  40531b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40531f:	e8 bc fe ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405324:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405328:	e8 b3 fe ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40532d:	4c 89 ff             	mov    %r15,%rdi
  405330:	e8 7b b9 ff ff       	callq  400cb0 <free@plt>
  405335:	4c 89 f7             	mov    %r14,%rdi
  405338:	e8 73 b9 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  40533d:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405341:	4d 85 f6             	test   %r14,%r14
  405344:	74 4e                	je     405394 <TMfreeNode+0x1b4>
        TMfreeNode(TM_ARG  n->l);
  405346:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40534a:	4d 85 ff             	test   %r15,%r15
  40534d:	74 1a                	je     405369 <TMfreeNode+0x189>
        TMfreeNode(TM_ARG  n->l);
  40534f:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405353:	e8 88 fe ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405358:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40535c:	e8 7f fe ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405361:	4c 89 ff             	mov    %r15,%rdi
  405364:	e8 47 b9 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405369:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40536d:	4d 85 ff             	test   %r15,%r15
  405370:	74 1a                	je     40538c <TMfreeNode+0x1ac>
        TMfreeNode(TM_ARG  n->l);
  405372:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405376:	e8 65 fe ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  40537b:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40537f:	e8 5c fe ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405384:	4c 89 ff             	mov    %r15,%rdi
  405387:	e8 24 b9 ff ff       	callq  400cb0 <free@plt>
  40538c:	4c 89 f7             	mov    %r14,%rdi
  40538f:	e8 1c b9 ff ff       	callq  400cb0 <free@plt>
  405394:	4c 89 ef             	mov    %r13,%rdi
  405397:	e8 14 b9 ff ff       	callq  400cb0 <free@plt>
  40539c:	4c 89 e7             	mov    %r12,%rdi
  40539f:	e8 0c b9 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4053a4:	4c 8b 65 20          	mov    0x20(%rbp),%r12
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4053a8:	4d 85 e4             	test   %r12,%r12
  4053ab:	0f 84 90 01 00 00    	je     405541 <TMfreeNode+0x361>
        TMfreeNode(TM_ARG  n->l);
  4053b1:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4053b6:	4d 85 ed             	test   %r13,%r13
  4053b9:	0f 84 b6 00 00 00    	je     405475 <TMfreeNode+0x295>
        TMfreeNode(TM_ARG  n->l);
  4053bf:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4053c3:	4d 85 f6             	test   %r14,%r14
  4053c6:	74 4e                	je     405416 <TMfreeNode+0x236>
        TMfreeNode(TM_ARG  n->l);
  4053c8:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4053cc:	4d 85 ff             	test   %r15,%r15
  4053cf:	74 1a                	je     4053eb <TMfreeNode+0x20b>
        TMfreeNode(TM_ARG  n->l);
  4053d1:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4053d5:	e8 06 fe ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4053da:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4053de:	e8 fd fd ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4053e3:	4c 89 ff             	mov    %r15,%rdi
  4053e6:	e8 c5 b8 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4053eb:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4053ef:	4d 85 ff             	test   %r15,%r15
  4053f2:	74 1a                	je     40540e <TMfreeNode+0x22e>
        TMfreeNode(TM_ARG  n->l);
  4053f4:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4053f8:	e8 e3 fd ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4053fd:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405401:	e8 da fd ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405406:	4c 89 ff             	mov    %r15,%rdi
  405409:	e8 a2 b8 ff ff       	callq  400cb0 <free@plt>
  40540e:	4c 89 f7             	mov    %r14,%rdi
  405411:	e8 9a b8 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405416:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40541a:	4d 85 f6             	test   %r14,%r14
  40541d:	74 4e                	je     40546d <TMfreeNode+0x28d>
        TMfreeNode(TM_ARG  n->l);
  40541f:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405423:	4d 85 ff             	test   %r15,%r15
  405426:	74 1a                	je     405442 <TMfreeNode+0x262>
        TMfreeNode(TM_ARG  n->l);
  405428:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40542c:	e8 af fd ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405431:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405435:	e8 a6 fd ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40543a:	4c 89 ff             	mov    %r15,%rdi
  40543d:	e8 6e b8 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405442:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405446:	4d 85 ff             	test   %r15,%r15
  405449:	74 1a                	je     405465 <TMfreeNode+0x285>
        TMfreeNode(TM_ARG  n->l);
  40544b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40544f:	e8 8c fd ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405454:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405458:	e8 83 fd ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40545d:	4c 89 ff             	mov    %r15,%rdi
  405460:	e8 4b b8 ff ff       	callq  400cb0 <free@plt>
  405465:	4c 89 f7             	mov    %r14,%rdi
  405468:	e8 43 b8 ff ff       	callq  400cb0 <free@plt>
  40546d:	4c 89 ef             	mov    %r13,%rdi
  405470:	e8 3b b8 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405475:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40547a:	4d 85 ed             	test   %r13,%r13
  40547d:	0f 84 b6 00 00 00    	je     405539 <TMfreeNode+0x359>
        TMfreeNode(TM_ARG  n->l);
  405483:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405487:	4d 85 f6             	test   %r14,%r14
  40548a:	74 4e                	je     4054da <TMfreeNode+0x2fa>
        TMfreeNode(TM_ARG  n->l);
  40548c:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405490:	4d 85 ff             	test   %r15,%r15
  405493:	74 1a                	je     4054af <TMfreeNode+0x2cf>
        TMfreeNode(TM_ARG  n->l);
  405495:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405499:	e8 42 fd ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  40549e:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4054a2:	e8 39 fd ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4054a7:	4c 89 ff             	mov    %r15,%rdi
  4054aa:	e8 01 b8 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4054af:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4054b3:	4d 85 ff             	test   %r15,%r15
  4054b6:	74 1a                	je     4054d2 <TMfreeNode+0x2f2>
        TMfreeNode(TM_ARG  n->l);
  4054b8:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4054bc:	e8 1f fd ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4054c1:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4054c5:	e8 16 fd ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4054ca:	4c 89 ff             	mov    %r15,%rdi
  4054cd:	e8 de b7 ff ff       	callq  400cb0 <free@plt>
  4054d2:	4c 89 f7             	mov    %r14,%rdi
  4054d5:	e8 d6 b7 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4054da:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4054de:	4d 85 f6             	test   %r14,%r14
  4054e1:	74 4e                	je     405531 <TMfreeNode+0x351>
        TMfreeNode(TM_ARG  n->l);
  4054e3:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4054e7:	4d 85 ff             	test   %r15,%r15
  4054ea:	74 1a                	je     405506 <TMfreeNode+0x326>
        TMfreeNode(TM_ARG  n->l);
  4054ec:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4054f0:	e8 eb fc ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4054f5:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4054f9:	e8 e2 fc ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4054fe:	4c 89 ff             	mov    %r15,%rdi
  405501:	e8 aa b7 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405506:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40550a:	4d 85 ff             	test   %r15,%r15
  40550d:	74 1a                	je     405529 <TMfreeNode+0x349>
        TMfreeNode(TM_ARG  n->l);
  40550f:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405513:	e8 c8 fc ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405518:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40551c:	e8 bf fc ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405521:	4c 89 ff             	mov    %r15,%rdi
  405524:	e8 87 b7 ff ff       	callq  400cb0 <free@plt>
  405529:	4c 89 f7             	mov    %r14,%rdi
  40552c:	e8 7f b7 ff ff       	callq  400cb0 <free@plt>
  405531:	4c 89 ef             	mov    %r13,%rdi
  405534:	e8 77 b7 ff ff       	callq  400cb0 <free@plt>
  405539:	4c 89 e7             	mov    %r12,%rdi
  40553c:	e8 6f b7 ff ff       	callq  400cb0 <free@plt>
  405541:	48 89 ef             	mov    %rbp,%rdi
  405544:	e8 67 b7 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405549:	48 8b 6b 20          	mov    0x20(%rbx),%rbp
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40554d:	48 85 ed             	test   %rbp,%rbp
  405550:	0f 84 42 03 00 00    	je     405898 <TMfreeNode+0x6b8>
        TMfreeNode(TM_ARG  n->l);
  405556:	4c 8b 65 18          	mov    0x18(%rbp),%r12
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40555a:	4d 85 e4             	test   %r12,%r12
  40555d:	0f 84 90 01 00 00    	je     4056f3 <TMfreeNode+0x513>
        TMfreeNode(TM_ARG  n->l);
  405563:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405568:	4d 85 ed             	test   %r13,%r13
  40556b:	0f 84 b6 00 00 00    	je     405627 <TMfreeNode+0x447>
        TMfreeNode(TM_ARG  n->l);
  405571:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405575:	4d 85 f6             	test   %r14,%r14
  405578:	74 4e                	je     4055c8 <TMfreeNode+0x3e8>
        TMfreeNode(TM_ARG  n->l);
  40557a:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40557e:	4d 85 ff             	test   %r15,%r15
  405581:	74 1a                	je     40559d <TMfreeNode+0x3bd>
        TMfreeNode(TM_ARG  n->l);
  405583:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405587:	e8 54 fc ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  40558c:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405590:	e8 4b fc ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405595:	4c 89 ff             	mov    %r15,%rdi
  405598:	e8 13 b7 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  40559d:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4055a1:	4d 85 ff             	test   %r15,%r15
  4055a4:	74 1a                	je     4055c0 <TMfreeNode+0x3e0>
        TMfreeNode(TM_ARG  n->l);
  4055a6:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4055aa:	e8 31 fc ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4055af:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4055b3:	e8 28 fc ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4055b8:	4c 89 ff             	mov    %r15,%rdi
  4055bb:	e8 f0 b6 ff ff       	callq  400cb0 <free@plt>
  4055c0:	4c 89 f7             	mov    %r14,%rdi
  4055c3:	e8 e8 b6 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4055c8:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4055cc:	4d 85 f6             	test   %r14,%r14
  4055cf:	74 4e                	je     40561f <TMfreeNode+0x43f>
        TMfreeNode(TM_ARG  n->l);
  4055d1:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4055d5:	4d 85 ff             	test   %r15,%r15
  4055d8:	74 1a                	je     4055f4 <TMfreeNode+0x414>
        TMfreeNode(TM_ARG  n->l);
  4055da:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4055de:	e8 fd fb ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4055e3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4055e7:	e8 f4 fb ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4055ec:	4c 89 ff             	mov    %r15,%rdi
  4055ef:	e8 bc b6 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4055f4:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4055f8:	4d 85 ff             	test   %r15,%r15
  4055fb:	74 1a                	je     405617 <TMfreeNode+0x437>
        TMfreeNode(TM_ARG  n->l);
  4055fd:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405601:	e8 da fb ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405606:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40560a:	e8 d1 fb ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40560f:	4c 89 ff             	mov    %r15,%rdi
  405612:	e8 99 b6 ff ff       	callq  400cb0 <free@plt>
  405617:	4c 89 f7             	mov    %r14,%rdi
  40561a:	e8 91 b6 ff ff       	callq  400cb0 <free@plt>
  40561f:	4c 89 ef             	mov    %r13,%rdi
  405622:	e8 89 b6 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405627:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40562c:	4d 85 ed             	test   %r13,%r13
  40562f:	0f 84 b6 00 00 00    	je     4056eb <TMfreeNode+0x50b>
        TMfreeNode(TM_ARG  n->l);
  405635:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405639:	4d 85 f6             	test   %r14,%r14
  40563c:	74 4e                	je     40568c <TMfreeNode+0x4ac>
        TMfreeNode(TM_ARG  n->l);
  40563e:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405642:	4d 85 ff             	test   %r15,%r15
  405645:	74 1a                	je     405661 <TMfreeNode+0x481>
        TMfreeNode(TM_ARG  n->l);
  405647:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40564b:	e8 90 fb ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405650:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405654:	e8 87 fb ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405659:	4c 89 ff             	mov    %r15,%rdi
  40565c:	e8 4f b6 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405661:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405665:	4d 85 ff             	test   %r15,%r15
  405668:	74 1a                	je     405684 <TMfreeNode+0x4a4>
        TMfreeNode(TM_ARG  n->l);
  40566a:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40566e:	e8 6d fb ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405673:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405677:	e8 64 fb ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40567c:	4c 89 ff             	mov    %r15,%rdi
  40567f:	e8 2c b6 ff ff       	callq  400cb0 <free@plt>
  405684:	4c 89 f7             	mov    %r14,%rdi
  405687:	e8 24 b6 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  40568c:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405690:	4d 85 f6             	test   %r14,%r14
  405693:	74 4e                	je     4056e3 <TMfreeNode+0x503>
        TMfreeNode(TM_ARG  n->l);
  405695:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405699:	4d 85 ff             	test   %r15,%r15
  40569c:	74 1a                	je     4056b8 <TMfreeNode+0x4d8>
        TMfreeNode(TM_ARG  n->l);
  40569e:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4056a2:	e8 39 fb ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4056a7:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4056ab:	e8 30 fb ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4056b0:	4c 89 ff             	mov    %r15,%rdi
  4056b3:	e8 f8 b5 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4056b8:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4056bc:	4d 85 ff             	test   %r15,%r15
  4056bf:	74 1a                	je     4056db <TMfreeNode+0x4fb>
        TMfreeNode(TM_ARG  n->l);
  4056c1:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4056c5:	e8 16 fb ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4056ca:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4056ce:	e8 0d fb ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4056d3:	4c 89 ff             	mov    %r15,%rdi
  4056d6:	e8 d5 b5 ff ff       	callq  400cb0 <free@plt>
  4056db:	4c 89 f7             	mov    %r14,%rdi
  4056de:	e8 cd b5 ff ff       	callq  400cb0 <free@plt>
  4056e3:	4c 89 ef             	mov    %r13,%rdi
  4056e6:	e8 c5 b5 ff ff       	callq  400cb0 <free@plt>
  4056eb:	4c 89 e7             	mov    %r12,%rdi
  4056ee:	e8 bd b5 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4056f3:	4c 8b 65 20          	mov    0x20(%rbp),%r12
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4056f7:	4d 85 e4             	test   %r12,%r12
  4056fa:	0f 84 90 01 00 00    	je     405890 <TMfreeNode+0x6b0>
        TMfreeNode(TM_ARG  n->l);
  405700:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405705:	4d 85 ed             	test   %r13,%r13
  405708:	0f 84 b6 00 00 00    	je     4057c4 <TMfreeNode+0x5e4>
        TMfreeNode(TM_ARG  n->l);
  40570e:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405712:	4d 85 f6             	test   %r14,%r14
  405715:	74 4e                	je     405765 <TMfreeNode+0x585>
        TMfreeNode(TM_ARG  n->l);
  405717:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40571b:	4d 85 ff             	test   %r15,%r15
  40571e:	74 1a                	je     40573a <TMfreeNode+0x55a>
        TMfreeNode(TM_ARG  n->l);
  405720:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405724:	e8 b7 fa ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405729:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40572d:	e8 ae fa ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405732:	4c 89 ff             	mov    %r15,%rdi
  405735:	e8 76 b5 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  40573a:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40573e:	4d 85 ff             	test   %r15,%r15
  405741:	74 1a                	je     40575d <TMfreeNode+0x57d>
        TMfreeNode(TM_ARG  n->l);
  405743:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405747:	e8 94 fa ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  40574c:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405750:	e8 8b fa ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405755:	4c 89 ff             	mov    %r15,%rdi
  405758:	e8 53 b5 ff ff       	callq  400cb0 <free@plt>
  40575d:	4c 89 f7             	mov    %r14,%rdi
  405760:	e8 4b b5 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405765:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405769:	4d 85 f6             	test   %r14,%r14
  40576c:	74 4e                	je     4057bc <TMfreeNode+0x5dc>
        TMfreeNode(TM_ARG  n->l);
  40576e:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405772:	4d 85 ff             	test   %r15,%r15
  405775:	74 1a                	je     405791 <TMfreeNode+0x5b1>
        TMfreeNode(TM_ARG  n->l);
  405777:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40577b:	e8 60 fa ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405780:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405784:	e8 57 fa ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405789:	4c 89 ff             	mov    %r15,%rdi
  40578c:	e8 1f b5 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405791:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405795:	4d 85 ff             	test   %r15,%r15
  405798:	74 1a                	je     4057b4 <TMfreeNode+0x5d4>
        TMfreeNode(TM_ARG  n->l);
  40579a:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40579e:	e8 3d fa ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4057a3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4057a7:	e8 34 fa ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4057ac:	4c 89 ff             	mov    %r15,%rdi
  4057af:	e8 fc b4 ff ff       	callq  400cb0 <free@plt>
  4057b4:	4c 89 f7             	mov    %r14,%rdi
  4057b7:	e8 f4 b4 ff ff       	callq  400cb0 <free@plt>
  4057bc:	4c 89 ef             	mov    %r13,%rdi
  4057bf:	e8 ec b4 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4057c4:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4057c9:	4d 85 ed             	test   %r13,%r13
  4057cc:	0f 84 b6 00 00 00    	je     405888 <TMfreeNode+0x6a8>
        TMfreeNode(TM_ARG  n->l);
  4057d2:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4057d6:	4d 85 f6             	test   %r14,%r14
  4057d9:	74 4e                	je     405829 <TMfreeNode+0x649>
        TMfreeNode(TM_ARG  n->l);
  4057db:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  4057df:	4d 85 ff             	test   %r15,%r15
  4057e2:	74 1a                	je     4057fe <TMfreeNode+0x61e>
        TMfreeNode(TM_ARG  n->l);
  4057e4:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4057e8:	e8 f3 f9 ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  4057ed:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4057f1:	e8 ea f9 ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4057f6:	4c 89 ff             	mov    %r15,%rdi
  4057f9:	e8 b2 b4 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  4057fe:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405802:	4d 85 ff             	test   %r15,%r15
  405805:	74 1a                	je     405821 <TMfreeNode+0x641>
        TMfreeNode(TM_ARG  n->l);
  405807:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40580b:	e8 d0 f9 ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405810:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405814:	e8 c7 f9 ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405819:	4c 89 ff             	mov    %r15,%rdi
  40581c:	e8 8f b4 ff ff       	callq  400cb0 <free@plt>
  405821:	4c 89 f7             	mov    %r14,%rdi
  405824:	e8 87 b4 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405829:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40582d:	4d 85 f6             	test   %r14,%r14
  405830:	74 4e                	je     405880 <TMfreeNode+0x6a0>
        TMfreeNode(TM_ARG  n->l);
  405832:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405836:	4d 85 ff             	test   %r15,%r15
  405839:	74 1a                	je     405855 <TMfreeNode+0x675>
        TMfreeNode(TM_ARG  n->l);
  40583b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40583f:	e8 9c f9 ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405844:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405848:	e8 93 f9 ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40584d:	4c 89 ff             	mov    %r15,%rdi
  405850:	e8 5b b4 ff ff       	callq  400cb0 <free@plt>
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
  405855:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  405859:	4d 85 ff             	test   %r15,%r15
  40585c:	74 1a                	je     405878 <TMfreeNode+0x698>
        TMfreeNode(TM_ARG  n->l);
  40585e:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405862:	e8 79 f9 ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  405867:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40586b:	e8 70 f9 ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  405870:	4c 89 ff             	mov    %r15,%rdi
  405873:	e8 38 b4 ff ff       	callq  400cb0 <free@plt>
  405878:	4c 89 f7             	mov    %r14,%rdi
  40587b:	e8 30 b4 ff ff       	callq  400cb0 <free@plt>
  405880:	4c 89 ef             	mov    %r13,%rdi
  405883:	e8 28 b4 ff ff       	callq  400cb0 <free@plt>
  405888:	4c 89 e7             	mov    %r12,%rdi
  40588b:	e8 20 b4 ff ff       	callq  400cb0 <free@plt>
  405890:	48 89 ef             	mov    %rbp,%rdi
  405893:	e8 18 b4 ff ff       	callq  400cb0 <free@plt>
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
        TMreleaseNode(TM_ARG  n);
    }
}
  405898:	48 83 c4 08          	add    $0x8,%rsp
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  40589c:	48 89 df             	mov    %rbx,%rdi
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
        TMreleaseNode(TM_ARG  n);
    }
}
  40589f:	5b                   	pop    %rbx
  4058a0:	5d                   	pop    %rbp
  4058a1:	41 5c                	pop    %r12
  4058a3:	41 5d                	pop    %r13
  4058a5:	41 5e                	pop    %r14
  4058a7:	41 5f                	pop    %r15
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  4058a9:	e9 02 b4 ff ff       	jmpq   400cb0 <free@plt>
  4058ae:	66 90                	xchg   %ax,%ax
    if (n) {
        TMfreeNode(TM_ARG  n->l);
        TMfreeNode(TM_ARG  n->r);
        TMreleaseNode(TM_ARG  n);
    }
}
  4058b0:	48 83 c4 08          	add    $0x8,%rsp
  4058b4:	5b                   	pop    %rbx
  4058b5:	5d                   	pop    %rbp
  4058b6:	41 5c                	pop    %r12
  4058b8:	41 5d                	pop    %r13
  4058ba:	41 5e                	pop    %r14
  4058bc:	41 5f                	pop    %r15
  4058be:	c3                   	retq   
  4058bf:	90                   	nop

00000000004058c0 <freeNode>:
 * freeNode
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
  4058c0:	41 57                	push   %r15
  4058c2:	41 56                	push   %r14
  4058c4:	41 55                	push   %r13
  4058c6:	41 54                	push   %r12
  4058c8:	55                   	push   %rbp
  4058c9:	53                   	push   %rbx
  4058ca:	48 89 fb             	mov    %rdi,%rbx
  4058cd:	48 83 ec 08          	sub    $0x8,%rsp
    if (n) {
  4058d1:	48 85 ff             	test   %rdi,%rdi
  4058d4:	0f 84 b6 06 00 00    	je     405f90 <freeNode+0x6d0>
        freeNode(n->l);
  4058da:	48 8b 6f 18          	mov    0x18(%rdi),%rbp
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4058de:	48 85 ed             	test   %rbp,%rbp
  4058e1:	0f 84 42 03 00 00    	je     405c29 <freeNode+0x369>
        freeNode(n->l);
  4058e7:	4c 8b 65 18          	mov    0x18(%rbp),%r12
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4058eb:	4d 85 e4             	test   %r12,%r12
  4058ee:	0f 84 90 01 00 00    	je     405a84 <freeNode+0x1c4>
        freeNode(n->l);
  4058f4:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4058f9:	4d 85 ed             	test   %r13,%r13
  4058fc:	0f 84 b6 00 00 00    	je     4059b8 <freeNode+0xf8>
        freeNode(n->l);
  405902:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405906:	4d 85 f6             	test   %r14,%r14
  405909:	74 4e                	je     405959 <freeNode+0x99>
        freeNode(n->l);
  40590b:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  40590f:	4d 85 ff             	test   %r15,%r15
  405912:	74 1a                	je     40592e <freeNode+0x6e>
        freeNode(n->l);
  405914:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405918:	e8 a3 ff ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  40591d:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405921:	e8 9a ff ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405926:	4c 89 ff             	mov    %r15,%rdi
  405929:	e8 82 b3 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  40592e:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405932:	4d 85 ff             	test   %r15,%r15
  405935:	74 1a                	je     405951 <freeNode+0x91>
        freeNode(n->l);
  405937:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40593b:	e8 80 ff ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405940:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405944:	e8 77 ff ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405949:	4c 89 ff             	mov    %r15,%rdi
  40594c:	e8 5f b3 ff ff       	callq  400cb0 <free@plt>
  405951:	4c 89 f7             	mov    %r14,%rdi
  405954:	e8 57 b3 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405959:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  40595d:	4d 85 f6             	test   %r14,%r14
  405960:	74 4e                	je     4059b0 <freeNode+0xf0>
        freeNode(n->l);
  405962:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405966:	4d 85 ff             	test   %r15,%r15
  405969:	74 1a                	je     405985 <freeNode+0xc5>
        freeNode(n->l);
  40596b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  40596f:	e8 4c ff ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405974:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405978:	e8 43 ff ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  40597d:	4c 89 ff             	mov    %r15,%rdi
  405980:	e8 2b b3 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405985:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405989:	4d 85 ff             	test   %r15,%r15
  40598c:	74 1a                	je     4059a8 <freeNode+0xe8>
        freeNode(n->l);
  40598e:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405992:	e8 29 ff ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405997:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  40599b:	e8 20 ff ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  4059a0:	4c 89 ff             	mov    %r15,%rdi
  4059a3:	e8 08 b3 ff ff       	callq  400cb0 <free@plt>
  4059a8:	4c 89 f7             	mov    %r14,%rdi
  4059ab:	e8 00 b3 ff ff       	callq  400cb0 <free@plt>
  4059b0:	4c 89 ef             	mov    %r13,%rdi
  4059b3:	e8 f8 b2 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  4059b8:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4059bd:	4d 85 ed             	test   %r13,%r13
  4059c0:	0f 84 b6 00 00 00    	je     405a7c <freeNode+0x1bc>
        freeNode(n->l);
  4059c6:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4059ca:	4d 85 f6             	test   %r14,%r14
  4059cd:	74 4e                	je     405a1d <freeNode+0x15d>
        freeNode(n->l);
  4059cf:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4059d3:	4d 85 ff             	test   %r15,%r15
  4059d6:	74 1a                	je     4059f2 <freeNode+0x132>
        freeNode(n->l);
  4059d8:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4059dc:	e8 df fe ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  4059e1:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4059e5:	e8 d6 fe ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  4059ea:	4c 89 ff             	mov    %r15,%rdi
  4059ed:	e8 be b2 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  4059f2:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4059f6:	4d 85 ff             	test   %r15,%r15
  4059f9:	74 1a                	je     405a15 <freeNode+0x155>
        freeNode(n->l);
  4059fb:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4059ff:	e8 bc fe ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405a04:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405a08:	e8 b3 fe ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405a0d:	4c 89 ff             	mov    %r15,%rdi
  405a10:	e8 9b b2 ff ff       	callq  400cb0 <free@plt>
  405a15:	4c 89 f7             	mov    %r14,%rdi
  405a18:	e8 93 b2 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405a1d:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405a21:	4d 85 f6             	test   %r14,%r14
  405a24:	74 4e                	je     405a74 <freeNode+0x1b4>
        freeNode(n->l);
  405a26:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405a2a:	4d 85 ff             	test   %r15,%r15
  405a2d:	74 1a                	je     405a49 <freeNode+0x189>
        freeNode(n->l);
  405a2f:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405a33:	e8 88 fe ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405a38:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405a3c:	e8 7f fe ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405a41:	4c 89 ff             	mov    %r15,%rdi
  405a44:	e8 67 b2 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405a49:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405a4d:	4d 85 ff             	test   %r15,%r15
  405a50:	74 1a                	je     405a6c <freeNode+0x1ac>
        freeNode(n->l);
  405a52:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405a56:	e8 65 fe ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405a5b:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405a5f:	e8 5c fe ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405a64:	4c 89 ff             	mov    %r15,%rdi
  405a67:	e8 44 b2 ff ff       	callq  400cb0 <free@plt>
  405a6c:	4c 89 f7             	mov    %r14,%rdi
  405a6f:	e8 3c b2 ff ff       	callq  400cb0 <free@plt>
  405a74:	4c 89 ef             	mov    %r13,%rdi
  405a77:	e8 34 b2 ff ff       	callq  400cb0 <free@plt>
  405a7c:	4c 89 e7             	mov    %r12,%rdi
  405a7f:	e8 2c b2 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405a84:	4c 8b 65 20          	mov    0x20(%rbp),%r12
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405a88:	4d 85 e4             	test   %r12,%r12
  405a8b:	0f 84 90 01 00 00    	je     405c21 <freeNode+0x361>
        freeNode(n->l);
  405a91:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405a96:	4d 85 ed             	test   %r13,%r13
  405a99:	0f 84 b6 00 00 00    	je     405b55 <freeNode+0x295>
        freeNode(n->l);
  405a9f:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405aa3:	4d 85 f6             	test   %r14,%r14
  405aa6:	74 4e                	je     405af6 <freeNode+0x236>
        freeNode(n->l);
  405aa8:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405aac:	4d 85 ff             	test   %r15,%r15
  405aaf:	74 1a                	je     405acb <freeNode+0x20b>
        freeNode(n->l);
  405ab1:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405ab5:	e8 06 fe ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405aba:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405abe:	e8 fd fd ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405ac3:	4c 89 ff             	mov    %r15,%rdi
  405ac6:	e8 e5 b1 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405acb:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405acf:	4d 85 ff             	test   %r15,%r15
  405ad2:	74 1a                	je     405aee <freeNode+0x22e>
        freeNode(n->l);
  405ad4:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405ad8:	e8 e3 fd ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405add:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405ae1:	e8 da fd ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405ae6:	4c 89 ff             	mov    %r15,%rdi
  405ae9:	e8 c2 b1 ff ff       	callq  400cb0 <free@plt>
  405aee:	4c 89 f7             	mov    %r14,%rdi
  405af1:	e8 ba b1 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405af6:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405afa:	4d 85 f6             	test   %r14,%r14
  405afd:	74 4e                	je     405b4d <freeNode+0x28d>
        freeNode(n->l);
  405aff:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405b03:	4d 85 ff             	test   %r15,%r15
  405b06:	74 1a                	je     405b22 <freeNode+0x262>
        freeNode(n->l);
  405b08:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405b0c:	e8 af fd ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405b11:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405b15:	e8 a6 fd ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405b1a:	4c 89 ff             	mov    %r15,%rdi
  405b1d:	e8 8e b1 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405b22:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405b26:	4d 85 ff             	test   %r15,%r15
  405b29:	74 1a                	je     405b45 <freeNode+0x285>
        freeNode(n->l);
  405b2b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405b2f:	e8 8c fd ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405b34:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405b38:	e8 83 fd ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405b3d:	4c 89 ff             	mov    %r15,%rdi
  405b40:	e8 6b b1 ff ff       	callq  400cb0 <free@plt>
  405b45:	4c 89 f7             	mov    %r14,%rdi
  405b48:	e8 63 b1 ff ff       	callq  400cb0 <free@plt>
  405b4d:	4c 89 ef             	mov    %r13,%rdi
  405b50:	e8 5b b1 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405b55:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405b5a:	4d 85 ed             	test   %r13,%r13
  405b5d:	0f 84 b6 00 00 00    	je     405c19 <freeNode+0x359>
        freeNode(n->l);
  405b63:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405b67:	4d 85 f6             	test   %r14,%r14
  405b6a:	74 4e                	je     405bba <freeNode+0x2fa>
        freeNode(n->l);
  405b6c:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405b70:	4d 85 ff             	test   %r15,%r15
  405b73:	74 1a                	je     405b8f <freeNode+0x2cf>
        freeNode(n->l);
  405b75:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405b79:	e8 42 fd ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405b7e:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405b82:	e8 39 fd ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405b87:	4c 89 ff             	mov    %r15,%rdi
  405b8a:	e8 21 b1 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405b8f:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405b93:	4d 85 ff             	test   %r15,%r15
  405b96:	74 1a                	je     405bb2 <freeNode+0x2f2>
        freeNode(n->l);
  405b98:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405b9c:	e8 1f fd ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405ba1:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405ba5:	e8 16 fd ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405baa:	4c 89 ff             	mov    %r15,%rdi
  405bad:	e8 fe b0 ff ff       	callq  400cb0 <free@plt>
  405bb2:	4c 89 f7             	mov    %r14,%rdi
  405bb5:	e8 f6 b0 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405bba:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405bbe:	4d 85 f6             	test   %r14,%r14
  405bc1:	74 4e                	je     405c11 <freeNode+0x351>
        freeNode(n->l);
  405bc3:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405bc7:	4d 85 ff             	test   %r15,%r15
  405bca:	74 1a                	je     405be6 <freeNode+0x326>
        freeNode(n->l);
  405bcc:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405bd0:	e8 eb fc ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405bd5:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405bd9:	e8 e2 fc ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405bde:	4c 89 ff             	mov    %r15,%rdi
  405be1:	e8 ca b0 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405be6:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405bea:	4d 85 ff             	test   %r15,%r15
  405bed:	74 1a                	je     405c09 <freeNode+0x349>
        freeNode(n->l);
  405bef:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405bf3:	e8 c8 fc ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405bf8:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405bfc:	e8 bf fc ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405c01:	4c 89 ff             	mov    %r15,%rdi
  405c04:	e8 a7 b0 ff ff       	callq  400cb0 <free@plt>
  405c09:	4c 89 f7             	mov    %r14,%rdi
  405c0c:	e8 9f b0 ff ff       	callq  400cb0 <free@plt>
  405c11:	4c 89 ef             	mov    %r13,%rdi
  405c14:	e8 97 b0 ff ff       	callq  400cb0 <free@plt>
  405c19:	4c 89 e7             	mov    %r12,%rdi
  405c1c:	e8 8f b0 ff ff       	callq  400cb0 <free@plt>
  405c21:	48 89 ef             	mov    %rbp,%rdi
  405c24:	e8 87 b0 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405c29:	48 8b 6b 20          	mov    0x20(%rbx),%rbp
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405c2d:	48 85 ed             	test   %rbp,%rbp
  405c30:	0f 84 42 03 00 00    	je     405f78 <freeNode+0x6b8>
        freeNode(n->l);
  405c36:	4c 8b 65 18          	mov    0x18(%rbp),%r12
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405c3a:	4d 85 e4             	test   %r12,%r12
  405c3d:	0f 84 90 01 00 00    	je     405dd3 <freeNode+0x513>
        freeNode(n->l);
  405c43:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405c48:	4d 85 ed             	test   %r13,%r13
  405c4b:	0f 84 b6 00 00 00    	je     405d07 <freeNode+0x447>
        freeNode(n->l);
  405c51:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405c55:	4d 85 f6             	test   %r14,%r14
  405c58:	74 4e                	je     405ca8 <freeNode+0x3e8>
        freeNode(n->l);
  405c5a:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405c5e:	4d 85 ff             	test   %r15,%r15
  405c61:	74 1a                	je     405c7d <freeNode+0x3bd>
        freeNode(n->l);
  405c63:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405c67:	e8 54 fc ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405c6c:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405c70:	e8 4b fc ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405c75:	4c 89 ff             	mov    %r15,%rdi
  405c78:	e8 33 b0 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405c7d:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405c81:	4d 85 ff             	test   %r15,%r15
  405c84:	74 1a                	je     405ca0 <freeNode+0x3e0>
        freeNode(n->l);
  405c86:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405c8a:	e8 31 fc ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405c8f:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405c93:	e8 28 fc ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405c98:	4c 89 ff             	mov    %r15,%rdi
  405c9b:	e8 10 b0 ff ff       	callq  400cb0 <free@plt>
  405ca0:	4c 89 f7             	mov    %r14,%rdi
  405ca3:	e8 08 b0 ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405ca8:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405cac:	4d 85 f6             	test   %r14,%r14
  405caf:	74 4e                	je     405cff <freeNode+0x43f>
        freeNode(n->l);
  405cb1:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405cb5:	4d 85 ff             	test   %r15,%r15
  405cb8:	74 1a                	je     405cd4 <freeNode+0x414>
        freeNode(n->l);
  405cba:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405cbe:	e8 fd fb ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405cc3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405cc7:	e8 f4 fb ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405ccc:	4c 89 ff             	mov    %r15,%rdi
  405ccf:	e8 dc af ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405cd4:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405cd8:	4d 85 ff             	test   %r15,%r15
  405cdb:	74 1a                	je     405cf7 <freeNode+0x437>
        freeNode(n->l);
  405cdd:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405ce1:	e8 da fb ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405ce6:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405cea:	e8 d1 fb ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405cef:	4c 89 ff             	mov    %r15,%rdi
  405cf2:	e8 b9 af ff ff       	callq  400cb0 <free@plt>
  405cf7:	4c 89 f7             	mov    %r14,%rdi
  405cfa:	e8 b1 af ff ff       	callq  400cb0 <free@plt>
  405cff:	4c 89 ef             	mov    %r13,%rdi
  405d02:	e8 a9 af ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405d07:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d0c:	4d 85 ed             	test   %r13,%r13
  405d0f:	0f 84 b6 00 00 00    	je     405dcb <freeNode+0x50b>
        freeNode(n->l);
  405d15:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d19:	4d 85 f6             	test   %r14,%r14
  405d1c:	74 4e                	je     405d6c <freeNode+0x4ac>
        freeNode(n->l);
  405d1e:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d22:	4d 85 ff             	test   %r15,%r15
  405d25:	74 1a                	je     405d41 <freeNode+0x481>
        freeNode(n->l);
  405d27:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405d2b:	e8 90 fb ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405d30:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405d34:	e8 87 fb ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405d39:	4c 89 ff             	mov    %r15,%rdi
  405d3c:	e8 6f af ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405d41:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d45:	4d 85 ff             	test   %r15,%r15
  405d48:	74 1a                	je     405d64 <freeNode+0x4a4>
        freeNode(n->l);
  405d4a:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405d4e:	e8 6d fb ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405d53:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405d57:	e8 64 fb ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405d5c:	4c 89 ff             	mov    %r15,%rdi
  405d5f:	e8 4c af ff ff       	callq  400cb0 <free@plt>
  405d64:	4c 89 f7             	mov    %r14,%rdi
  405d67:	e8 44 af ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405d6c:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d70:	4d 85 f6             	test   %r14,%r14
  405d73:	74 4e                	je     405dc3 <freeNode+0x503>
        freeNode(n->l);
  405d75:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d79:	4d 85 ff             	test   %r15,%r15
  405d7c:	74 1a                	je     405d98 <freeNode+0x4d8>
        freeNode(n->l);
  405d7e:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405d82:	e8 39 fb ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405d87:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405d8b:	e8 30 fb ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405d90:	4c 89 ff             	mov    %r15,%rdi
  405d93:	e8 18 af ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405d98:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405d9c:	4d 85 ff             	test   %r15,%r15
  405d9f:	74 1a                	je     405dbb <freeNode+0x4fb>
        freeNode(n->l);
  405da1:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405da5:	e8 16 fb ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405daa:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405dae:	e8 0d fb ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405db3:	4c 89 ff             	mov    %r15,%rdi
  405db6:	e8 f5 ae ff ff       	callq  400cb0 <free@plt>
  405dbb:	4c 89 f7             	mov    %r14,%rdi
  405dbe:	e8 ed ae ff ff       	callq  400cb0 <free@plt>
  405dc3:	4c 89 ef             	mov    %r13,%rdi
  405dc6:	e8 e5 ae ff ff       	callq  400cb0 <free@plt>
  405dcb:	4c 89 e7             	mov    %r12,%rdi
  405dce:	e8 dd ae ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405dd3:	4c 8b 65 20          	mov    0x20(%rbp),%r12
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405dd7:	4d 85 e4             	test   %r12,%r12
  405dda:	0f 84 90 01 00 00    	je     405f70 <freeNode+0x6b0>
        freeNode(n->l);
  405de0:	4d 8b 6c 24 18       	mov    0x18(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405de5:	4d 85 ed             	test   %r13,%r13
  405de8:	0f 84 b6 00 00 00    	je     405ea4 <freeNode+0x5e4>
        freeNode(n->l);
  405dee:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405df2:	4d 85 f6             	test   %r14,%r14
  405df5:	74 4e                	je     405e45 <freeNode+0x585>
        freeNode(n->l);
  405df7:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405dfb:	4d 85 ff             	test   %r15,%r15
  405dfe:	74 1a                	je     405e1a <freeNode+0x55a>
        freeNode(n->l);
  405e00:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405e04:	e8 b7 fa ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405e09:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405e0d:	e8 ae fa ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405e12:	4c 89 ff             	mov    %r15,%rdi
  405e15:	e8 96 ae ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405e1a:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405e1e:	4d 85 ff             	test   %r15,%r15
  405e21:	74 1a                	je     405e3d <freeNode+0x57d>
        freeNode(n->l);
  405e23:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405e27:	e8 94 fa ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405e2c:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405e30:	e8 8b fa ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405e35:	4c 89 ff             	mov    %r15,%rdi
  405e38:	e8 73 ae ff ff       	callq  400cb0 <free@plt>
  405e3d:	4c 89 f7             	mov    %r14,%rdi
  405e40:	e8 6b ae ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405e45:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405e49:	4d 85 f6             	test   %r14,%r14
  405e4c:	74 4e                	je     405e9c <freeNode+0x5dc>
        freeNode(n->l);
  405e4e:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405e52:	4d 85 ff             	test   %r15,%r15
  405e55:	74 1a                	je     405e71 <freeNode+0x5b1>
        freeNode(n->l);
  405e57:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405e5b:	e8 60 fa ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405e60:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405e64:	e8 57 fa ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405e69:	4c 89 ff             	mov    %r15,%rdi
  405e6c:	e8 3f ae ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405e71:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405e75:	4d 85 ff             	test   %r15,%r15
  405e78:	74 1a                	je     405e94 <freeNode+0x5d4>
        freeNode(n->l);
  405e7a:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405e7e:	e8 3d fa ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405e83:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405e87:	e8 34 fa ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405e8c:	4c 89 ff             	mov    %r15,%rdi
  405e8f:	e8 1c ae ff ff       	callq  400cb0 <free@plt>
  405e94:	4c 89 f7             	mov    %r14,%rdi
  405e97:	e8 14 ae ff ff       	callq  400cb0 <free@plt>
  405e9c:	4c 89 ef             	mov    %r13,%rdi
  405e9f:	e8 0c ae ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405ea4:	4d 8b 6c 24 20       	mov    0x20(%r12),%r13
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405ea9:	4d 85 ed             	test   %r13,%r13
  405eac:	0f 84 b6 00 00 00    	je     405f68 <freeNode+0x6a8>
        freeNode(n->l);
  405eb2:	4d 8b 75 18          	mov    0x18(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405eb6:	4d 85 f6             	test   %r14,%r14
  405eb9:	74 4e                	je     405f09 <freeNode+0x649>
        freeNode(n->l);
  405ebb:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405ebf:	4d 85 ff             	test   %r15,%r15
  405ec2:	74 1a                	je     405ede <freeNode+0x61e>
        freeNode(n->l);
  405ec4:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405ec8:	e8 f3 f9 ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405ecd:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405ed1:	e8 ea f9 ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405ed6:	4c 89 ff             	mov    %r15,%rdi
  405ed9:	e8 d2 ad ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405ede:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405ee2:	4d 85 ff             	test   %r15,%r15
  405ee5:	74 1a                	je     405f01 <freeNode+0x641>
        freeNode(n->l);
  405ee7:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405eeb:	e8 d0 f9 ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405ef0:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405ef4:	e8 c7 f9 ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405ef9:	4c 89 ff             	mov    %r15,%rdi
  405efc:	e8 af ad ff ff       	callq  400cb0 <free@plt>
  405f01:	4c 89 f7             	mov    %r14,%rdi
  405f04:	e8 a7 ad ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405f09:	4d 8b 75 20          	mov    0x20(%r13),%r14
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405f0d:	4d 85 f6             	test   %r14,%r14
  405f10:	74 4e                	je     405f60 <freeNode+0x6a0>
        freeNode(n->l);
  405f12:	4d 8b 7e 18          	mov    0x18(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405f16:	4d 85 ff             	test   %r15,%r15
  405f19:	74 1a                	je     405f35 <freeNode+0x675>
        freeNode(n->l);
  405f1b:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405f1f:	e8 9c f9 ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405f24:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405f28:	e8 93 f9 ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405f2d:	4c 89 ff             	mov    %r15,%rdi
  405f30:	e8 7b ad ff ff       	callq  400cb0 <free@plt>
static void
freeNode (node_t* n)
{
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
  405f35:	4d 8b 7e 20          	mov    0x20(%r14),%r15
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  405f39:	4d 85 ff             	test   %r15,%r15
  405f3c:	74 1a                	je     405f58 <freeNode+0x698>
        freeNode(n->l);
  405f3e:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  405f42:	e8 79 f9 ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  405f47:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  405f4b:	e8 70 f9 ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405f50:	4c 89 ff             	mov    %r15,%rdi
  405f53:	e8 58 ad ff ff       	callq  400cb0 <free@plt>
  405f58:	4c 89 f7             	mov    %r14,%rdi
  405f5b:	e8 50 ad ff ff       	callq  400cb0 <free@plt>
  405f60:	4c 89 ef             	mov    %r13,%rdi
  405f63:	e8 48 ad ff ff       	callq  400cb0 <free@plt>
  405f68:	4c 89 e7             	mov    %r12,%rdi
  405f6b:	e8 40 ad ff ff       	callq  400cb0 <free@plt>
  405f70:	48 89 ef             	mov    %rbp,%rdi
  405f73:	e8 38 ad ff ff       	callq  400cb0 <free@plt>
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
        releaseNode(n);
    }
}
  405f78:	48 83 c4 08          	add    $0x8,%rsp
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405f7c:	48 89 df             	mov    %rbx,%rdi
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
        releaseNode(n);
    }
}
  405f7f:	5b                   	pop    %rbx
  405f80:	5d                   	pop    %rbp
  405f81:	41 5c                	pop    %r12
  405f83:	41 5d                	pop    %r13
  405f85:	41 5e                	pop    %r14
  405f87:	41 5f                	pop    %r15
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  405f89:	e9 22 ad ff ff       	jmpq   400cb0 <free@plt>
  405f8e:	66 90                	xchg   %ax,%ax
    if (n) {
        freeNode(n->l);
        freeNode(n->r);
        releaseNode(n);
    }
}
  405f90:	48 83 c4 08          	add    $0x8,%rsp
  405f94:	5b                   	pop    %rbx
  405f95:	5d                   	pop    %rbp
  405f96:	41 5c                	pop    %r12
  405f98:	41 5d                	pop    %r13
  405f9a:	41 5e                	pop    %r14
  405f9c:	41 5f                	pop    %r15
  405f9e:	c3                   	retq   
  405f9f:	90                   	nop

0000000000405fa0 <fixAfterInsertion>:
 * fixAfterInsertion
 * =============================================================================
 */
static void
fixAfterInsertion (rbtree_t* s, node_t* x)
{
  405fa0:	4c 8b 07             	mov    (%rdi),%r8
    STF(x, c, RED);
  405fa3:	48 c7 46 28 00 00 00 	movq   $0x0,0x28(%rsi)
  405faa:	00 
  405fab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    while (x != NULL && x != LDNODE(s, root)) {
  405fb0:	49 39 f0             	cmp    %rsi,%r8
  405fb3:	74 5b                	je     406010 <fixAfterInsertion+0x70>
        node_t* xp = LDNODE(x, p);
  405fb5:	48 8b 46 10          	mov    0x10(%rsi),%rax
        if (LDF(xp, c) != RED) {
  405fb9:	48 83 78 28 00       	cmpq   $0x0,0x28(%rax)
  405fbe:	75 50                	jne    406010 <fixAfterInsertion+0x70>
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  405fc0:	48 8b 50 10          	mov    0x10(%rax),%rdx
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  405fc4:	48 85 d2             	test   %rdx,%rdx
  405fc7:	74 5f                	je     406028 <fixAfterInsertion+0x88>
        node_t* xp = LDNODE(x, p);
        if (LDF(xp, c) != RED) {
            break;
        }
        /* TODO: cache g = ppx = PARENT_OF(PARENT_OF(x)) */
        if (PARENT_OF(x) == LEFT_OF(PARENT_OF(PARENT_OF(x)))) {
  405fc9:	48 3b 42 18          	cmp    0x18(%rdx),%rax
  405fcd:	0f 84 d5 00 00 00    	je     4060a8 <fixAfterInsertion+0x108>
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  405fd3:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  405fd7:	48 85 c9             	test   %rcx,%rcx
  405fda:	74 4c                	je     406028 <fixAfterInsertion+0x88>
                    ROTATE_RIGHT(s, PARENT_OF(PARENT_OF(x)));
                }
            }
        } else {
            node_t* y = LEFT_OF(PARENT_OF(PARENT_OF(x)));
            if (COLOR_OF(y) == RED) {
  405fdc:	48 83 79 28 00       	cmpq   $0x0,0x28(%rcx)
  405fe1:	75 45                	jne    406028 <fixAfterInsertion+0x88>
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  405fe3:	48 85 c0             	test   %rax,%rax
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  405fe6:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  405fed:	00 
  405fee:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  405ff5:	00 
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  405ff6:	74 08                	je     406000 <fixAfterInsertion+0x60>
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  405ff8:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  405fff:	00 
 */
static void
fixAfterInsertion (rbtree_t* s, node_t* x)
{
    STF(x, c, RED);
    while (x != NULL && x != LDNODE(s, root)) {
  406000:	48 85 d2             	test   %rdx,%rdx
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406003:	48 89 d6             	mov    %rdx,%rsi
 */
static void
fixAfterInsertion (rbtree_t* s, node_t* x)
{
    STF(x, c, RED);
    while (x != NULL && x != LDNODE(s, root)) {
  406006:	75 a8                	jne    405fb0 <fixAfterInsertion+0x10>
  406008:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40600f:	00 
                }
            }
        }
    }
    node_t* ro = LDNODE(s, root);
    if (LDF(ro, c) != BLACK) {
  406010:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  406015:	0f 84 c5 00 00 00    	je     4060e0 <fixAfterInsertion+0x140>
        STF(ro, c, BLACK);
  40601b:	49 c7 40 28 01 00 00 	movq   $0x1,0x28(%r8)
  406022:	00 
  406023:	c3                   	retq   
  406024:	0f 1f 40 00          	nopl   0x0(%rax)
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406028:	48 8b 48 18          	mov    0x18(%rax),%rcx
                SET_COLOR(PARENT_OF(x), BLACK);
                SET_COLOR(y, BLACK);
                SET_COLOR(PARENT_OF(PARENT_OF(x)), RED);
                x = PARENT_OF(PARENT_OF(x));
            } else {
                if (x == LEFT_OF(PARENT_OF(x))) {
  40602c:	48 39 f1             	cmp    %rsi,%rcx
  40602f:	0f 84 3b 01 00 00    	je     406170 <fixAfterInsertion+0x1d0>
  406035:	48 89 c2             	mov    %rax,%rdx
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406038:	48 85 f6             	test   %rsi,%rsi
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  40603b:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406042:	00 
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406043:	0f 84 9f 00 00 00    	je     4060e8 <fixAfterInsertion+0x148>
  406049:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  40604d:	48 85 c0             	test   %rax,%rax
  406050:	0f 84 f6 01 00 00    	je     40624c <fixAfterInsertion+0x2ac>
 * =============================================================================
 */
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
  406056:	48 8b 50 20          	mov    0x20(%rax),%rdx
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  40605a:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  406061:	00 
 */
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
  406062:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
    STF(x, r, rl);
    if (rl != NULL) {
  406066:	48 85 c9             	test   %rcx,%rcx
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
  406069:	48 89 48 20          	mov    %rcx,0x20(%rax)
    if (rl != NULL) {
  40606d:	74 04                	je     406073 <fixAfterInsertion+0xd3>
        STF(rl, p, x);
  40606f:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
  406073:	48 8b 48 10          	mov    0x10(%rax),%rcx
    STF(r, p, xp);
    if (xp == NULL) {
  406077:	48 85 c9             	test   %rcx,%rcx
    if (rl != NULL) {
        STF(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
  40607a:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  40607e:	0f 84 34 01 00 00    	je     4061b8 <fixAfterInsertion+0x218>
        STF(s, root, r);
    } else if (LDNODE(xp, l) == x) {
  406084:	48 3b 41 18          	cmp    0x18(%rcx),%rax
  406088:	0f 84 3a 01 00 00    	je     4061c8 <fixAfterInsertion+0x228>
  40608e:	4c 8b 07             	mov    (%rdi),%r8
        STF(xp, l, r);
    } else {
        STF(xp, r, r);
  406091:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    }
    STF(r, l, x);
  406095:	48 89 42 18          	mov    %rax,0x18(%rdx)
    STF(x, p, r);
  406099:	48 89 50 10          	mov    %rdx,0x10(%rax)
  40609d:	e9 0e ff ff ff       	jmpq   405fb0 <fixAfterInsertion+0x10>
  4060a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  4060a8:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  4060ac:	48 85 c9             	test   %rcx,%rcx
  4060af:	74 3f                	je     4060f0 <fixAfterInsertion+0x150>
            break;
        }
        /* TODO: cache g = ppx = PARENT_OF(PARENT_OF(x)) */
        if (PARENT_OF(x) == LEFT_OF(PARENT_OF(PARENT_OF(x)))) {
            node_t*  y = RIGHT_OF(PARENT_OF(PARENT_OF(x)));
            if (COLOR_OF(y) == RED) {
  4060b1:	48 83 79 28 00       	cmpq   $0x0,0x28(%rcx)
  4060b6:	75 38                	jne    4060f0 <fixAfterInsertion+0x150>
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  4060b8:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  4060bf:	00 
  4060c0:	48 89 d6             	mov    %rdx,%rsi
  4060c3:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  4060ca:	00 
  4060cb:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  4060d2:	00 
  4060d3:	e9 d8 fe ff ff       	jmpq   405fb0 <fixAfterInsertion+0x10>
  4060d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4060df:	00 
  4060e0:	f3 c3                	repz retq 
  4060e2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4060e8:	4c 8b 07             	mov    (%rdi),%r8
  4060eb:	e9 20 ff ff ff       	jmpq   406010 <fixAfterInsertion+0x70>
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  4060f0:	48 8b 48 20          	mov    0x20(%rax),%rcx
                SET_COLOR(PARENT_OF(x), BLACK);
                SET_COLOR(y, BLACK);
                SET_COLOR(PARENT_OF(PARENT_OF(x)), RED);
                x = PARENT_OF(PARENT_OF(x));
            } else {
                if (x == RIGHT_OF(PARENT_OF(x))) {
  4060f4:	48 39 f1             	cmp    %rsi,%rcx
  4060f7:	0f 84 db 00 00 00    	je     4061d8 <fixAfterInsertion+0x238>
  4060fd:	48 89 c2             	mov    %rax,%rdx
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406100:	48 85 f6             	test   %rsi,%rsi
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  406103:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  40610a:	00 
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  40610b:	74 db                	je     4060e8 <fixAfterInsertion+0x148>
  40610d:	48 85 d2             	test   %rdx,%rdx
  406110:	0f 84 36 01 00 00    	je     40624c <fixAfterInsertion+0x2ac>
  406116:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  40611a:	48 85 c0             	test   %rax,%rax
  40611d:	0f 84 29 01 00 00    	je     40624c <fixAfterInsertion+0x2ac>
 * =============================================================================
 */
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
  406123:	48 8b 50 18          	mov    0x18(%rax),%rdx
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  406127:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  40612e:	00 
 */
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
  40612f:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    STF(x, l, lr);
    if (lr != NULL) {
  406133:	48 85 c9             	test   %rcx,%rcx
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
  406136:	48 89 48 18          	mov    %rcx,0x18(%rax)
    if (lr != NULL) {
  40613a:	74 04                	je     406140 <fixAfterInsertion+0x1a0>
        STF(lr, p, x);
  40613c:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    node_t* xp = LDNODE(x, p);
  406140:	48 8b 48 10          	mov    0x10(%rax),%rcx
    STF(l, p, xp);
    if (xp == NULL) {
  406144:	48 85 c9             	test   %rcx,%rcx
    STF(x, l, lr);
    if (lr != NULL) {
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
  406147:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  40614b:	0f 84 c2 00 00 00    	je     406213 <fixAfterInsertion+0x273>
        STF(s, root, l);
    } else if (LDNODE(xp, r) == x) {
  406151:	48 3b 41 20          	cmp    0x20(%rcx),%rax
  406155:	0f 84 d4 00 00 00    	je     40622f <fixAfterInsertion+0x28f>
  40615b:	4c 8b 07             	mov    (%rdi),%r8
        STF(xp, r, l);
    } else {
        STF(xp, l, l);
  40615e:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    }
    STF(l, r, x);
  406162:	48 89 42 20          	mov    %rax,0x20(%rdx)
    STF(x, p, l);
  406166:	48 89 50 10          	mov    %rdx,0x10(%rax)
  40616a:	e9 41 fe ff ff       	jmpq   405fb0 <fixAfterInsertion+0x10>
  40616f:	90                   	nop
 */
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
  406170:	48 8b 76 20          	mov    0x20(%rsi),%rsi
    STF(x, l, lr);
    if (lr != NULL) {
  406174:	48 85 f6             	test   %rsi,%rsi
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
  406177:	48 89 70 18          	mov    %rsi,0x18(%rax)
    if (lr != NULL) {
  40617b:	74 08                	je     406185 <fixAfterInsertion+0x1e5>
        STF(lr, p, x);
  40617d:	48 89 46 10          	mov    %rax,0x10(%rsi)
  406181:	48 8b 50 10          	mov    0x10(%rax),%rdx
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
    if (xp == NULL) {
  406185:	48 85 d2             	test   %rdx,%rdx
    STF(x, l, lr);
    if (lr != NULL) {
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
  406188:	48 89 51 10          	mov    %rdx,0x10(%rcx)
    if (xp == NULL) {
  40618c:	0f 84 8c 00 00 00    	je     40621e <fixAfterInsertion+0x27e>
        STF(s, root, l);
    } else if (LDNODE(xp, r) == x) {
  406192:	48 3b 42 20          	cmp    0x20(%rdx),%rax
  406196:	0f 84 8a 00 00 00    	je     406226 <fixAfterInsertion+0x286>
        STF(xp, r, l);
    } else {
        STF(xp, l, l);
  40619c:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
    }
    STF(l, r, x);
  4061a0:	48 89 41 20          	mov    %rax,0x20(%rcx)
    STF(x, p, l);
  4061a4:	48 89 ca             	mov    %rcx,%rdx
  4061a7:	48 89 48 10          	mov    %rcx,0x10(%rax)
  4061ab:	48 89 c6             	mov    %rax,%rsi
  4061ae:	e9 85 fe ff ff       	jmpq   406038 <fixAfterInsertion+0x98>
  4061b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
    if (xp == NULL) {
        STF(s, root, r);
  4061b8:	48 89 17             	mov    %rdx,(%rdi)
  4061bb:	49 89 d0             	mov    %rdx,%r8
  4061be:	e9 d2 fe ff ff       	jmpq   406095 <fixAfterInsertion+0xf5>
  4061c3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    } else if (LDNODE(xp, l) == x) {
        STF(xp, l, r);
  4061c8:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  4061cc:	4c 8b 07             	mov    (%rdi),%r8
  4061cf:	e9 c1 fe ff ff       	jmpq   406095 <fixAfterInsertion+0xf5>
  4061d4:	0f 1f 40 00          	nopl   0x0(%rax)
 */
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
  4061d8:	4c 8b 46 18          	mov    0x18(%rsi),%r8
    STF(x, r, rl);
    if (rl != NULL) {
  4061dc:	4d 85 c0             	test   %r8,%r8
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
  4061df:	4c 89 40 20          	mov    %r8,0x20(%rax)
    if (rl != NULL) {
  4061e3:	74 56                	je     40623b <fixAfterInsertion+0x29b>
        STF(rl, p, x);
  4061e5:	49 89 40 10          	mov    %rax,0x10(%r8)
  4061e9:	48 8b 50 10          	mov    0x10(%rax),%rdx
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
    if (xp == NULL) {
  4061ed:	48 85 d2             	test   %rdx,%rdx
    if (rl != NULL) {
        STF(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
  4061f0:	48 89 56 10          	mov    %rdx,0x10(%rsi)
    if (xp == NULL) {
  4061f4:	74 4b                	je     406241 <fixAfterInsertion+0x2a1>
        STF(s, root, r);
    } else if (LDNODE(xp, l) == x) {
  4061f6:	48 3b 42 18          	cmp    0x18(%rdx),%rax
  4061fa:	74 4a                	je     406246 <fixAfterInsertion+0x2a6>
        STF(xp, l, r);
    } else {
        STF(xp, r, r);
  4061fc:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
    }
    STF(r, l, x);
  406200:	48 89 41 18          	mov    %rax,0x18(%rcx)
    STF(x, p, r);
  406204:	48 89 ca             	mov    %rcx,%rdx
  406207:	48 89 48 10          	mov    %rcx,0x10(%rax)
  40620b:	48 89 c6             	mov    %rax,%rsi
  40620e:	e9 ed fe ff ff       	jmpq   406100 <fixAfterInsertion+0x160>
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
    if (xp == NULL) {
        STF(s, root, l);
  406213:	48 89 17             	mov    %rdx,(%rdi)
  406216:	49 89 d0             	mov    %rdx,%r8
  406219:	e9 44 ff ff ff       	jmpq   406162 <fixAfterInsertion+0x1c2>
  40621e:	48 89 0f             	mov    %rcx,(%rdi)
  406221:	e9 7a ff ff ff       	jmpq   4061a0 <fixAfterInsertion+0x200>
    } else if (LDNODE(xp, r) == x) {
        STF(xp, r, l);
  406226:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
  40622a:	e9 71 ff ff ff       	jmpq   4061a0 <fixAfterInsertion+0x200>
  40622f:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  406233:	4c 8b 07             	mov    (%rdi),%r8
  406236:	e9 27 ff ff ff       	jmpq   406162 <fixAfterInsertion+0x1c2>
    if (rl != NULL) {
        STF(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
  40623b:	48 89 56 10          	mov    %rdx,0x10(%rsi)
  40623f:	eb b5                	jmp    4061f6 <fixAfterInsertion+0x256>
    if (xp == NULL) {
        STF(s, root, r);
  406241:	48 89 37             	mov    %rsi,(%rdi)
  406244:	eb ba                	jmp    406200 <fixAfterInsertion+0x260>
    } else if (LDNODE(xp, l) == x) {
        STF(xp, l, r);
  406246:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
  40624a:	eb b4                	jmp    406200 <fixAfterInsertion+0x260>
  40624c:	4c 8b 07             	mov    (%rdi),%r8
  40624f:	e9 5c fd ff ff       	jmpq   405fb0 <fixAfterInsertion+0x10>
  406254:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40625b:	00 00 00 00 00 

0000000000406260 <TMfixAfterInsertion>:
 * TMfixAfterInsertion
 * =============================================================================
 */
static void
TMfixAfterInsertion (TM_ARGDECL  rbtree_t* s, node_t* x)
{
  406260:	4c 8b 07             	mov    (%rdi),%r8
    TX_STF(x, c, RED);
  406263:	48 c7 46 28 00 00 00 	movq   $0x0,0x28(%rsi)
  40626a:	00 
  40626b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    while (x != NULL && x != TX_LDNODE(s, root)) {
  406270:	49 39 f0             	cmp    %rsi,%r8
  406273:	74 5b                	je     4062d0 <TMfixAfterInsertion+0x70>
        node_t* xp = TX_LDNODE(x, p);
  406275:	48 8b 46 10          	mov    0x10(%rsi),%rax
        if (TX_LDF(xp, c) != RED) {
  406279:	48 83 78 28 00       	cmpq   $0x0,0x28(%rax)
  40627e:	75 50                	jne    4062d0 <TMfixAfterInsertion+0x70>
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  406280:	48 8b 50 10          	mov    0x10(%rax),%rdx
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  406284:	48 85 d2             	test   %rdx,%rdx
  406287:	74 5f                	je     4062e8 <TMfixAfterInsertion+0x88>
        node_t* xp = TX_LDNODE(x, p);
        if (TX_LDF(xp, c) != RED) {
            break;
        }
        /* TODO: cache g = ppx = TX_PARENT_OF(TX_PARENT_OF(x)) */
        if (TX_PARENT_OF(x) == TX_LEFT_OF(TX_PARENT_OF(TX_PARENT_OF(x)))) {
  406289:	48 3b 42 18          	cmp    0x18(%rdx),%rax
  40628d:	0f 84 d5 00 00 00    	je     406368 <TMfixAfterInsertion+0x108>
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  406293:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  406297:	48 85 c9             	test   %rcx,%rcx
  40629a:	74 4c                	je     4062e8 <TMfixAfterInsertion+0x88>
                    TX_ROTATE_RIGHT(s, TX_PARENT_OF(TX_PARENT_OF(x)));
                }
            }
        } else {
            node_t* y = TX_LEFT_OF(TX_PARENT_OF(TX_PARENT_OF(x)));
            if (TX_COLOR_OF(y) == RED) {
  40629c:	48 83 79 28 00       	cmpq   $0x0,0x28(%rcx)
  4062a1:	75 45                	jne    4062e8 <TMfixAfterInsertion+0x88>
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4062a3:	48 85 c0             	test   %rax,%rax
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4062a6:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  4062ad:	00 
  4062ae:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  4062b5:	00 
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4062b6:	74 08                	je     4062c0 <TMfixAfterInsertion+0x60>
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4062b8:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  4062bf:	00 
 */
static void
TMfixAfterInsertion (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    TX_STF(x, c, RED);
    while (x != NULL && x != TX_LDNODE(s, root)) {
  4062c0:	48 85 d2             	test   %rdx,%rdx
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4062c3:	48 89 d6             	mov    %rdx,%rsi
 */
static void
TMfixAfterInsertion (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    TX_STF(x, c, RED);
    while (x != NULL && x != TX_LDNODE(s, root)) {
  4062c6:	75 a8                	jne    406270 <TMfixAfterInsertion+0x10>
  4062c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4062cf:	00 
                }
            }
        }
    }
    node_t* ro = TX_LDNODE(s, root);
    if (TX_LDF(ro, c) != BLACK) {
  4062d0:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  4062d5:	0f 84 c5 00 00 00    	je     4063a0 <TMfixAfterInsertion+0x140>
        TX_STF(ro, c, BLACK);
  4062db:	49 c7 40 28 01 00 00 	movq   $0x1,0x28(%r8)
  4062e2:	00 
  4062e3:	c3                   	retq   
  4062e4:	0f 1f 40 00          	nopl   0x0(%rax)
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  4062e8:	48 8b 48 18          	mov    0x18(%rax),%rcx
                TX_SET_COLOR(TX_PARENT_OF(x), BLACK);
                TX_SET_COLOR(y, BLACK);
                TX_SET_COLOR(TX_PARENT_OF(TX_PARENT_OF(x)), RED);
                x = TX_PARENT_OF(TX_PARENT_OF(x));
            } else {
                if (x == TX_LEFT_OF(TX_PARENT_OF(x))) {
  4062ec:	48 39 f1             	cmp    %rsi,%rcx
  4062ef:	0f 84 3b 01 00 00    	je     406430 <TMfixAfterInsertion+0x1d0>
  4062f5:	48 89 c2             	mov    %rax,%rdx
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4062f8:	48 85 f6             	test   %rsi,%rsi
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4062fb:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406302:	00 
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  406303:	0f 84 9f 00 00 00    	je     4063a8 <TMfixAfterInsertion+0x148>
  406309:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  40630d:	48 85 c0             	test   %rax,%rax
  406310:	0f 84 f6 01 00 00    	je     40650c <TMfixAfterInsertion+0x2ac>
 * =============================================================================
 */
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
  406316:	48 8b 50 20          	mov    0x20(%rax),%rdx
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  40631a:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  406321:	00 
 */
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
  406322:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
    TX_STF_P(x, r, rl);
    if (rl != NULL) {
  406326:	48 85 c9             	test   %rcx,%rcx
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
  406329:	48 89 48 20          	mov    %rcx,0x20(%rax)
    if (rl != NULL) {
  40632d:	74 04                	je     406333 <TMfixAfterInsertion+0xd3>
        TX_STF_P(rl, p, x);
  40632f:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
  406333:	48 8b 48 10          	mov    0x10(%rax),%rcx
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
  406337:	48 85 c9             	test   %rcx,%rcx
    if (rl != NULL) {
        TX_STF_P(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
  40633a:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  40633e:	0f 84 34 01 00 00    	je     406478 <TMfixAfterInsertion+0x218>
        TX_STF_P(s, root, r);
    } else if (TX_LDNODE(xp, l) == x) {
  406344:	48 3b 41 18          	cmp    0x18(%rcx),%rax
  406348:	0f 84 3a 01 00 00    	je     406488 <TMfixAfterInsertion+0x228>
  40634e:	4c 8b 07             	mov    (%rdi),%r8
        TX_STF_P(xp, l, r);
    } else {
        TX_STF_P(xp, r, r);
  406351:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    }
    TX_STF_P(r, l, x);
  406355:	48 89 42 18          	mov    %rax,0x18(%rdx)
    TX_STF_P(x, p, r);
  406359:	48 89 50 10          	mov    %rdx,0x10(%rax)
  40635d:	e9 0e ff ff ff       	jmpq   406270 <TMfixAfterInsertion+0x10>
  406362:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  406368:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  40636c:	48 85 c9             	test   %rcx,%rcx
  40636f:	74 3f                	je     4063b0 <TMfixAfterInsertion+0x150>
            break;
        }
        /* TODO: cache g = ppx = TX_PARENT_OF(TX_PARENT_OF(x)) */
        if (TX_PARENT_OF(x) == TX_LEFT_OF(TX_PARENT_OF(TX_PARENT_OF(x)))) {
            node_t*  y = TX_RIGHT_OF(TX_PARENT_OF(TX_PARENT_OF(x)));
            if (TX_COLOR_OF(y) == RED) {
  406371:	48 83 79 28 00       	cmpq   $0x0,0x28(%rcx)
  406376:	75 38                	jne    4063b0 <TMfixAfterInsertion+0x150>
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  406378:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  40637f:	00 
  406380:	48 89 d6             	mov    %rdx,%rsi
  406383:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  40638a:	00 
  40638b:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  406392:	00 
  406393:	e9 d8 fe ff ff       	jmpq   406270 <TMfixAfterInsertion+0x10>
  406398:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40639f:	00 
  4063a0:	f3 c3                	repz retq 
  4063a2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4063a8:	4c 8b 07             	mov    (%rdi),%r8
  4063ab:	e9 20 ff ff ff       	jmpq   4062d0 <TMfixAfterInsertion+0x70>
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  4063b0:	48 8b 48 20          	mov    0x20(%rax),%rcx
                TX_SET_COLOR(TX_PARENT_OF(x), BLACK);
                TX_SET_COLOR(y, BLACK);
                TX_SET_COLOR(TX_PARENT_OF(TX_PARENT_OF(x)), RED);
                x = TX_PARENT_OF(TX_PARENT_OF(x));
            } else {
                if (x == TX_RIGHT_OF(TX_PARENT_OF(x))) {
  4063b4:	48 39 f1             	cmp    %rsi,%rcx
  4063b7:	0f 84 db 00 00 00    	je     406498 <TMfixAfterInsertion+0x238>
  4063bd:	48 89 c2             	mov    %rax,%rdx
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4063c0:	48 85 f6             	test   %rsi,%rsi
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4063c3:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  4063ca:	00 
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4063cb:	74 db                	je     4063a8 <TMfixAfterInsertion+0x148>
  4063cd:	48 85 d2             	test   %rdx,%rdx
  4063d0:	0f 84 36 01 00 00    	je     40650c <TMfixAfterInsertion+0x2ac>
  4063d6:	48 8b 42 10          	mov    0x10(%rdx),%rax
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  4063da:	48 85 c0             	test   %rax,%rax
  4063dd:	0f 84 29 01 00 00    	je     40650c <TMfixAfterInsertion+0x2ac>
 * =============================================================================
 */
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
  4063e3:	48 8b 50 18          	mov    0x18(%rax),%rdx
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4063e7:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  4063ee:	00 
 */
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
  4063ef:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
  4063f3:	48 85 c9             	test   %rcx,%rcx
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
  4063f6:	48 89 48 18          	mov    %rcx,0x18(%rax)
    if (lr != NULL) {
  4063fa:	74 04                	je     406400 <TMfixAfterInsertion+0x1a0>
        TX_STF_P(lr, p, x);
  4063fc:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    node_t* xp = TX_LDNODE(x, p);
  406400:	48 8b 48 10          	mov    0x10(%rax),%rcx
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
  406404:	48 85 c9             	test   %rcx,%rcx
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
  406407:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  40640b:	0f 84 c2 00 00 00    	je     4064d3 <TMfixAfterInsertion+0x273>
        TX_STF_P(s, root, l);
    } else if (TX_LDNODE(xp, r) == x) {
  406411:	48 3b 41 20          	cmp    0x20(%rcx),%rax
  406415:	0f 84 d4 00 00 00    	je     4064ef <TMfixAfterInsertion+0x28f>
  40641b:	4c 8b 07             	mov    (%rdi),%r8
        TX_STF_P(xp, r, l);
    } else {
        TX_STF_P(xp, l, l);
  40641e:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    }
    TX_STF_P(l, r, x);
  406422:	48 89 42 20          	mov    %rax,0x20(%rdx)
    TX_STF_P(x, p, l);
  406426:	48 89 50 10          	mov    %rdx,0x10(%rax)
  40642a:	e9 41 fe ff ff       	jmpq   406270 <TMfixAfterInsertion+0x10>
  40642f:	90                   	nop
 */
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
  406430:	48 8b 76 20          	mov    0x20(%rsi),%rsi
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
  406434:	48 85 f6             	test   %rsi,%rsi
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
  406437:	48 89 70 18          	mov    %rsi,0x18(%rax)
    if (lr != NULL) {
  40643b:	74 08                	je     406445 <TMfixAfterInsertion+0x1e5>
        TX_STF_P(lr, p, x);
  40643d:	48 89 46 10          	mov    %rax,0x10(%rsi)
  406441:	48 8b 50 10          	mov    0x10(%rax),%rdx
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
  406445:	48 85 d2             	test   %rdx,%rdx
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
  406448:	48 89 51 10          	mov    %rdx,0x10(%rcx)
    if (xp == NULL) {
  40644c:	0f 84 8c 00 00 00    	je     4064de <TMfixAfterInsertion+0x27e>
        TX_STF_P(s, root, l);
    } else if (TX_LDNODE(xp, r) == x) {
  406452:	48 3b 42 20          	cmp    0x20(%rdx),%rax
  406456:	0f 84 8a 00 00 00    	je     4064e6 <TMfixAfterInsertion+0x286>
        TX_STF_P(xp, r, l);
    } else {
        TX_STF_P(xp, l, l);
  40645c:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
    }
    TX_STF_P(l, r, x);
  406460:	48 89 41 20          	mov    %rax,0x20(%rcx)
    TX_STF_P(x, p, l);
  406464:	48 89 ca             	mov    %rcx,%rdx
  406467:	48 89 48 10          	mov    %rcx,0x10(%rax)
  40646b:	48 89 c6             	mov    %rax,%rsi
  40646e:	e9 85 fe ff ff       	jmpq   4062f8 <TMfixAfterInsertion+0x98>
  406473:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, r);
  406478:	48 89 17             	mov    %rdx,(%rdi)
  40647b:	49 89 d0             	mov    %rdx,%r8
  40647e:	e9 d2 fe ff ff       	jmpq   406355 <TMfixAfterInsertion+0xf5>
  406483:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    } else if (TX_LDNODE(xp, l) == x) {
        TX_STF_P(xp, l, r);
  406488:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  40648c:	4c 8b 07             	mov    (%rdi),%r8
  40648f:	e9 c1 fe ff ff       	jmpq   406355 <TMfixAfterInsertion+0xf5>
  406494:	0f 1f 40 00          	nopl   0x0(%rax)
 */
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
  406498:	4c 8b 46 18          	mov    0x18(%rsi),%r8
    TX_STF_P(x, r, rl);
    if (rl != NULL) {
  40649c:	4d 85 c0             	test   %r8,%r8
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
  40649f:	4c 89 40 20          	mov    %r8,0x20(%rax)
    if (rl != NULL) {
  4064a3:	74 56                	je     4064fb <TMfixAfterInsertion+0x29b>
        TX_STF_P(rl, p, x);
  4064a5:	49 89 40 10          	mov    %rax,0x10(%r8)
  4064a9:	48 8b 50 10          	mov    0x10(%rax),%rdx
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
  4064ad:	48 85 d2             	test   %rdx,%rdx
    if (rl != NULL) {
        TX_STF_P(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
  4064b0:	48 89 56 10          	mov    %rdx,0x10(%rsi)
    if (xp == NULL) {
  4064b4:	74 4b                	je     406501 <TMfixAfterInsertion+0x2a1>
        TX_STF_P(s, root, r);
    } else if (TX_LDNODE(xp, l) == x) {
  4064b6:	48 3b 42 18          	cmp    0x18(%rdx),%rax
  4064ba:	74 4a                	je     406506 <TMfixAfterInsertion+0x2a6>
        TX_STF_P(xp, l, r);
    } else {
        TX_STF_P(xp, r, r);
  4064bc:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
    }
    TX_STF_P(r, l, x);
  4064c0:	48 89 41 18          	mov    %rax,0x18(%rcx)
    TX_STF_P(x, p, r);
  4064c4:	48 89 ca             	mov    %rcx,%rdx
  4064c7:	48 89 48 10          	mov    %rcx,0x10(%rax)
  4064cb:	48 89 c6             	mov    %rax,%rsi
  4064ce:	e9 ed fe ff ff       	jmpq   4063c0 <TMfixAfterInsertion+0x160>
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, l);
  4064d3:	48 89 17             	mov    %rdx,(%rdi)
  4064d6:	49 89 d0             	mov    %rdx,%r8
  4064d9:	e9 44 ff ff ff       	jmpq   406422 <TMfixAfterInsertion+0x1c2>
  4064de:	48 89 0f             	mov    %rcx,(%rdi)
  4064e1:	e9 7a ff ff ff       	jmpq   406460 <TMfixAfterInsertion+0x200>
    } else if (TX_LDNODE(xp, r) == x) {
        TX_STF_P(xp, r, l);
  4064e6:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
  4064ea:	e9 71 ff ff ff       	jmpq   406460 <TMfixAfterInsertion+0x200>
  4064ef:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  4064f3:	4c 8b 07             	mov    (%rdi),%r8
  4064f6:	e9 27 ff ff ff       	jmpq   406422 <TMfixAfterInsertion+0x1c2>
    if (rl != NULL) {
        TX_STF_P(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
  4064fb:	48 89 56 10          	mov    %rdx,0x10(%rsi)
  4064ff:	eb b5                	jmp    4064b6 <TMfixAfterInsertion+0x256>
    if (xp == NULL) {
        TX_STF_P(s, root, r);
  406501:	48 89 37             	mov    %rsi,(%rdi)
  406504:	eb ba                	jmp    4064c0 <TMfixAfterInsertion+0x260>
    } else if (TX_LDNODE(xp, l) == x) {
        TX_STF_P(xp, l, r);
  406506:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
  40650a:	eb b4                	jmp    4064c0 <TMfixAfterInsertion+0x260>
  40650c:	4c 8b 07             	mov    (%rdi),%r8
  40650f:	e9 5c fd ff ff       	jmpq   406270 <TMfixAfterInsertion+0x10>
  406514:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40651b:	00 00 00 00 00 

0000000000406520 <TMfixAfterDeletion>:
 * TMfixAfterDeletion
 * =============================================================================
 */
static void
TMfixAfterDeletion  (TM_ARGDECL  rbtree_t* s, node_t* x)
{
  406520:	48 8b 07             	mov    (%rdi),%rax
    while (x != TX_LDNODE(s,root) && TX_COLOR_OF(x) == BLACK) {
  406523:	48 39 c6             	cmp    %rax,%rsi
  406526:	0f 84 50 01 00 00    	je     40667c <TMfixAfterDeletion+0x15c>
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  40652c:	48 85 f6             	test   %rsi,%rsi
  40652f:	74 ef                	je     406520 <TMfixAfterDeletion>
 * =============================================================================
 */
static void
TMfixAfterDeletion  (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    while (x != TX_LDNODE(s,root) && TX_COLOR_OF(x) == BLACK) {
  406531:	48 83 7e 28 01       	cmpq   $0x1,0x28(%rsi)
  406536:	0f 85 4c 01 00 00    	jne    406688 <TMfixAfterDeletion+0x168>
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  40653c:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  406540:	48 85 c0             	test   %rax,%rax
  406543:	0f 84 73 01 00 00    	je     4066bc <TMfixAfterDeletion+0x19c>
  406549:	48 8b 50 18          	mov    0x18(%rax),%rdx
 */
static void
TMfixAfterDeletion  (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    while (x != TX_LDNODE(s,root) && TX_COLOR_OF(x) == BLACK) {
        if (x == TX_LEFT_OF(TX_PARENT_OF(x))) {
  40654d:	48 39 d6             	cmp    %rdx,%rsi
  406550:	0f 84 da 01 00 00    	je     406730 <TMfixAfterDeletion+0x210>
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  406556:	48 85 d2             	test   %rdx,%rdx
  406559:	0f 84 5d 01 00 00    	je     4066bc <TMfixAfterDeletion+0x19c>
                x = TX_LDNODE(s,root);
            }
        } else { /* symmetric */
            node_t* sib = TX_LEFT_OF(TX_PARENT_OF(x));

            if (TX_COLOR_OF(sib) == RED) {
  40655f:	48 83 7a 28 00       	cmpq   $0x0,0x28(%rdx)
  406564:	75 62                	jne    4065c8 <TMfixAfterDeletion+0xa8>
 */
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
  406566:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  40656a:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406571:	00 
  406572:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  406579:	00 
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
  40657a:	48 85 c9             	test   %rcx,%rcx
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
  40657d:	48 89 48 18          	mov    %rcx,0x18(%rax)
    if (lr != NULL) {
  406581:	74 04                	je     406587 <TMfixAfterDeletion+0x67>
        TX_STF_P(lr, p, x);
  406583:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    node_t* xp = TX_LDNODE(x, p);
  406587:	48 8b 48 10          	mov    0x10(%rax),%rcx
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
  40658b:	48 85 c9             	test   %rcx,%rcx
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
  40658e:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406592:	0f 84 e8 02 00 00    	je     406880 <TMfixAfterDeletion+0x360>
        TX_STF_P(s, root, l);
    } else if (TX_LDNODE(xp, r) == x) {
  406598:	48 3b 41 20          	cmp    0x20(%rcx),%rax
  40659c:	0f 84 ee 02 00 00    	je     406890 <TMfixAfterDeletion+0x370>
        TX_STF_P(xp, r, l);
    } else {
        TX_STF_P(xp, l, l);
  4065a2:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    }
    TX_STF_P(l, r, x);
  4065a6:	48 89 42 20          	mov    %rax,0x20(%rdx)
    TX_STF_P(x, p, l);
  4065aa:	48 89 50 10          	mov    %rdx,0x10(%rax)
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4065ae:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  4065b2:	48 85 c0             	test   %rax,%rax
  4065b5:	0f 84 01 01 00 00    	je     4066bc <TMfixAfterDeletion+0x19c>
  4065bb:	48 8b 50 18          	mov    0x18(%rax),%rdx
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  4065bf:	48 85 d2             	test   %rdx,%rdx
  4065c2:	0f 84 f4 00 00 00    	je     4066bc <TMfixAfterDeletion+0x19c>
  4065c8:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4065cc:	48 85 c9             	test   %rcx,%rcx
  4065cf:	0f 84 cb 00 00 00    	je     4066a0 <TMfixAfterDeletion+0x180>
                TX_SET_COLOR(sib, BLACK);
                TX_SET_COLOR(TX_PARENT_OF(x), RED);
                TX_ROTATE_RIGHT(s, TX_PARENT_OF(x));
                sib = TX_LEFT_OF(TX_PARENT_OF(x));
            }
            if (TX_COLOR_OF(TX_RIGHT_OF(sib)) == BLACK &&
  4065d5:	48 83 79 28 01       	cmpq   $0x1,0x28(%rcx)
  4065da:	0f 84 c0 00 00 00    	je     4066a0 <TMfixAfterDeletion+0x180>
  4065e0:	4c 8b 42 18          	mov    0x18(%rdx),%r8
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4065e4:	4d 85 c0             	test   %r8,%r8
  4065e7:	0f 84 e0 00 00 00    	je     4066cd <TMfixAfterDeletion+0x1ad>
            if (TX_COLOR_OF(TX_RIGHT_OF(sib)) == BLACK &&
                TX_COLOR_OF(TX_LEFT_OF(sib)) == BLACK) {
                TX_SET_COLOR(sib,  RED);
                x = TX_PARENT_OF(x);
            } else {
                if (TX_COLOR_OF(TX_LEFT_OF(sib)) == BLACK) {
  4065ed:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  4065f2:	0f 84 d0 00 00 00    	je     4066c8 <TMfixAfterDeletion+0x1a8>
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4065f8:	48 85 c0             	test   %rax,%rax
  4065fb:	0f 84 7f 03 00 00    	je     406980 <TMfixAfterDeletion+0x460>
  406601:	48 8b 48 28          	mov    0x28(%rax),%rcx
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  406605:	48 85 d2             	test   %rdx,%rdx
  406608:	74 04                	je     40660e <TMfixAfterDeletion+0xee>
        TX_STF(n, c, c);
  40660a:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  40660e:	48 85 c0             	test   %rax,%rax
  406611:	74 08                	je     40661b <TMfixAfterDeletion+0xfb>
        TX_STF(n, c, c);
  406613:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  40661a:	00 
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  40661b:	48 85 d2             	test   %rdx,%rdx
  40661e:	74 11                	je     406631 <TMfixAfterDeletion+0x111>
  406620:	48 8b 52 18          	mov    0x18(%rdx),%rdx
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  406624:	48 85 d2             	test   %rdx,%rdx
  406627:	74 08                	je     406631 <TMfixAfterDeletion+0x111>
        TX_STF(n, c, c);
  406629:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406630:	00 
 * =============================================================================
 */
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
  406631:	48 8b 50 18          	mov    0x18(%rax),%rdx
    node_t* lr = TX_LDNODE(l, r);
  406635:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
  406639:	48 85 c9             	test   %rcx,%rcx
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
  40663c:	48 89 48 18          	mov    %rcx,0x18(%rax)
    if (lr != NULL) {
  406640:	74 04                	je     406646 <TMfixAfterDeletion+0x126>
        TX_STF_P(lr, p, x);
  406642:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    node_t* xp = TX_LDNODE(x, p);
  406646:	48 8b 48 10          	mov    0x10(%rax),%rcx
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
  40664a:	48 85 c9             	test   %rcx,%rcx
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
  40664d:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406651:	0f 84 09 02 00 00    	je     406860 <TMfixAfterDeletion+0x340>
        TX_STF_P(s, root, l);
    } else if (TX_LDNODE(xp, r) == x) {
  406657:	48 3b 41 20          	cmp    0x20(%rcx),%rax
  40665b:	0f 84 0f 02 00 00    	je     406870 <TMfixAfterDeletion+0x350>
  406661:	48 8b 37             	mov    (%rdi),%rsi
        TX_STF_P(xp, r, l);
    } else {
        TX_STF_P(xp, l, l);
  406664:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    }
    TX_STF_P(l, r, x);
  406668:	48 89 42 20          	mov    %rax,0x20(%rdx)
    TX_STF_P(x, p, l);
  40666c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  406670:	48 89 f0             	mov    %rsi,%rax
 * =============================================================================
 */
static void
TMfixAfterDeletion  (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    while (x != TX_LDNODE(s,root) && TX_COLOR_OF(x) == BLACK) {
  406673:	48 39 c6             	cmp    %rax,%rsi
  406676:	0f 85 b0 fe ff ff    	jne    40652c <TMfixAfterDeletion+0xc>
                x = TX_LDNODE(s, root);
            }
        }
    }

    if (x != NULL && TX_LDF(x,c) != BLACK) {
  40667c:	48 85 f6             	test   %rsi,%rsi
  40667f:	74 17                	je     406698 <TMfixAfterDeletion+0x178>
  406681:	48 83 7e 28 01       	cmpq   $0x1,0x28(%rsi)
  406686:	74 10                	je     406698 <TMfixAfterDeletion+0x178>
       TX_STF(x, c, BLACK);
  406688:	48 c7 46 28 01 00 00 	movq   $0x1,0x28(%rsi)
  40668f:	00 
  406690:	c3                   	retq   
  406691:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  406698:	f3 c3                	repz retq 
  40669a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  4066a0:	4c 8b 42 18          	mov    0x18(%rdx),%r8
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4066a4:	4d 85 c0             	test   %r8,%r8
  4066a7:	74 0b                	je     4066b4 <TMfixAfterDeletion+0x194>
                TX_SET_COLOR(sib, BLACK);
                TX_SET_COLOR(TX_PARENT_OF(x), RED);
                TX_ROTATE_RIGHT(s, TX_PARENT_OF(x));
                sib = TX_LEFT_OF(TX_PARENT_OF(x));
            }
            if (TX_COLOR_OF(TX_RIGHT_OF(sib)) == BLACK &&
  4066a9:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  4066ae:	0f 85 39 ff ff ff    	jne    4065ed <TMfixAfterDeletion+0xcd>
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4066b4:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  4066bb:	00 
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  4066bc:	48 89 c6             	mov    %rax,%rsi
  4066bf:	e9 5c fe ff ff       	jmpq   406520 <TMfixAfterDeletion>
  4066c4:	0f 1f 40 00          	nopl   0x0(%rax)
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  4066c8:	48 85 c9             	test   %rcx,%rcx
  4066cb:	74 08                	je     4066d5 <TMfixAfterDeletion+0x1b5>
        TX_STF(n, c, c);
  4066cd:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  4066d4:	00 
 */
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
  4066d5:	48 8b 41 18          	mov    0x18(%rcx),%rax
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4066d9:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  4066e0:	00 
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
    if (rl != NULL) {
  4066e1:	48 85 c0             	test   %rax,%rax
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
  4066e4:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (rl != NULL) {
  4066e8:	74 04                	je     4066ee <TMfixAfterDeletion+0x1ce>
        TX_STF_P(rl, p, x);
  4066ea:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
  4066ee:	48 8b 42 10          	mov    0x10(%rdx),%rax
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
  4066f2:	48 85 c0             	test   %rax,%rax
    if (rl != NULL) {
        TX_STF_P(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
  4066f5:	48 89 41 10          	mov    %rax,0x10(%rcx)
    if (xp == NULL) {
  4066f9:	0f 84 19 02 00 00    	je     406918 <TMfixAfterDeletion+0x3f8>
        TX_STF_P(s, root, r);
    } else if (TX_LDNODE(xp, l) == x) {
  4066ff:	48 3b 50 18          	cmp    0x18(%rax),%rdx
  406703:	0f 84 17 02 00 00    	je     406920 <TMfixAfterDeletion+0x400>
        TX_STF_P(xp, l, r);
    } else {
        TX_STF_P(xp, r, r);
  406709:	48 89 48 20          	mov    %rcx,0x20(%rax)
    }
    TX_STF_P(r, l, x);
  40670d:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    TX_STF_P(x, p, r);
  406711:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  406715:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  406719:	48 85 c0             	test   %rax,%rax
  40671c:	0f 84 4d 02 00 00    	je     40696f <TMfixAfterDeletion+0x44f>
  406722:	48 8b 50 18          	mov    0x18(%rax),%rdx
  406726:	e9 cd fe ff ff       	jmpq   4065f8 <TMfixAfterDeletion+0xd8>
  40672b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  406730:	48 8b 50 20          	mov    0x20(%rax),%rdx
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  406734:	48 85 d2             	test   %rdx,%rdx
  406737:	0f 84 4d 02 00 00    	je     40698a <TMfixAfterDeletion+0x46a>
TMfixAfterDeletion  (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    while (x != TX_LDNODE(s,root) && TX_COLOR_OF(x) == BLACK) {
        if (x == TX_LEFT_OF(TX_PARENT_OF(x))) {
            node_t* sib = TX_RIGHT_OF(TX_PARENT_OF(x));
            if (TX_COLOR_OF(sib) == RED) {
  40673d:	48 83 7a 28 00       	cmpq   $0x0,0x28(%rdx)
  406742:	75 62                	jne    4067a6 <TMfixAfterDeletion+0x286>
 */
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
  406744:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  406748:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  40674f:	00 
  406750:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  406757:	00 
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
    if (rl != NULL) {
  406758:	48 85 c9             	test   %rcx,%rcx
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
  40675b:	48 89 48 20          	mov    %rcx,0x20(%rax)
    if (rl != NULL) {
  40675f:	74 04                	je     406765 <TMfixAfterDeletion+0x245>
        TX_STF_P(rl, p, x);
  406761:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
  406765:	48 8b 48 10          	mov    0x10(%rax),%rcx
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
  406769:	48 85 c9             	test   %rcx,%rcx
    if (rl != NULL) {
        TX_STF_P(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
  40676c:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406770:	0f 84 d6 01 00 00    	je     40694c <TMfixAfterDeletion+0x42c>
        TX_STF_P(s, root, r);
    } else if (TX_LDNODE(xp, l) == x) {
  406776:	48 3b 41 18          	cmp    0x18(%rcx),%rax
  40677a:	0f 84 d4 01 00 00    	je     406954 <TMfixAfterDeletion+0x434>
        TX_STF_P(xp, l, r);
    } else {
        TX_STF_P(xp, r, r);
  406780:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    }
    TX_STF_P(r, l, x);
  406784:	48 89 42 18          	mov    %rax,0x18(%rdx)
    TX_STF_P(x, p, r);
  406788:	48 89 50 10          	mov    %rdx,0x10(%rax)
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  40678c:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  406790:	48 85 c0             	test   %rax,%rax
  406793:	0f 84 f1 01 00 00    	je     40698a <TMfixAfterDeletion+0x46a>
  406799:	48 8b 50 20          	mov    0x20(%rax),%rdx
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  40679d:	48 85 d2             	test   %rdx,%rdx
  4067a0:	0f 84 e4 01 00 00    	je     40698a <TMfixAfterDeletion+0x46a>
  4067a6:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4067aa:	48 85 c9             	test   %rcx,%rcx
  4067ad:	0f 84 ed 00 00 00    	je     4068a0 <TMfixAfterDeletion+0x380>
                TX_SET_COLOR(sib, BLACK);
                TX_SET_COLOR(TX_PARENT_OF(x), RED);
                TX_ROTATE_LEFT(s, TX_PARENT_OF(x));
                sib = TX_RIGHT_OF(TX_PARENT_OF(x));
            }
            if (TX_COLOR_OF(TX_LEFT_OF(sib)) == BLACK &&
  4067b3:	48 83 79 28 01       	cmpq   $0x1,0x28(%rcx)
  4067b8:	0f 84 e2 00 00 00    	je     4068a0 <TMfixAfterDeletion+0x380>
  4067be:	4c 8b 42 20          	mov    0x20(%rdx),%r8
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4067c2:	4d 85 c0             	test   %r8,%r8
  4067c5:	0f 84 f7 00 00 00    	je     4068c2 <TMfixAfterDeletion+0x3a2>
            if (TX_COLOR_OF(TX_LEFT_OF(sib)) == BLACK &&
                TX_COLOR_OF(TX_RIGHT_OF(sib)) == BLACK) {
                TX_SET_COLOR(sib, RED);
                x = TX_PARENT_OF(x);
            } else {
                if (TX_COLOR_OF(TX_RIGHT_OF(sib)) == BLACK) {
  4067cb:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  4067d0:	0f 84 e7 00 00 00    	je     4068bd <TMfixAfterDeletion+0x39d>
  4067d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4067dd:	00 00 00 
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4067e0:	48 85 c0             	test   %rax,%rax
  4067e3:	0f 84 8d 01 00 00    	je     406976 <TMfixAfterDeletion+0x456>
  4067e9:	48 8b 48 28          	mov    0x28(%rax),%rcx
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  4067ed:	48 85 d2             	test   %rdx,%rdx
  4067f0:	74 04                	je     4067f6 <TMfixAfterDeletion+0x2d6>
        TX_STF(n, c, c);
  4067f2:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  4067f6:	48 85 c0             	test   %rax,%rax
  4067f9:	74 08                	je     406803 <TMfixAfterDeletion+0x2e3>
        TX_STF(n, c, c);
  4067fb:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  406802:	00 
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  406803:	48 85 d2             	test   %rdx,%rdx
  406806:	74 11                	je     406819 <TMfixAfterDeletion+0x2f9>
  406808:	48 8b 52 20          	mov    0x20(%rdx),%rdx
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  40680c:	48 85 d2             	test   %rdx,%rdx
  40680f:	74 08                	je     406819 <TMfixAfterDeletion+0x2f9>
        TX_STF(n, c, c);
  406811:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406818:	00 
 * =============================================================================
 */
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
  406819:	48 8b 50 20          	mov    0x20(%rax),%rdx
    node_t* rl = TX_LDNODE(r, l);
  40681d:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
    TX_STF_P(x, r, rl);
    if (rl != NULL) {
  406821:	48 85 c9             	test   %rcx,%rcx
static void
TMrotateLeft (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* r = TX_LDNODE(x, r); /* AKA r, y */
    node_t* rl = TX_LDNODE(r, l);
    TX_STF_P(x, r, rl);
  406824:	48 89 48 20          	mov    %rcx,0x20(%rax)
    if (rl != NULL) {
  406828:	74 04                	je     40682e <TMfixAfterDeletion+0x30e>
        TX_STF_P(rl, p, x);
  40682a:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
  40682e:	48 8b 48 10          	mov    0x10(%rax),%rcx
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
  406832:	48 85 c9             	test   %rcx,%rcx
    if (rl != NULL) {
        TX_STF_P(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
  406835:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406839:	0f 84 f1 00 00 00    	je     406930 <TMfixAfterDeletion+0x410>
        TX_STF_P(s, root, r);
    } else if (TX_LDNODE(xp, l) == x) {
  40683f:	48 3b 41 18          	cmp    0x18(%rcx),%rax
  406843:	0f 84 f7 00 00 00    	je     406940 <TMfixAfterDeletion+0x420>
  406849:	48 8b 37             	mov    (%rdi),%rsi
        TX_STF_P(xp, l, r);
    } else {
        TX_STF_P(xp, r, r);
  40684c:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    }
    TX_STF_P(r, l, x);
  406850:	48 89 42 18          	mov    %rax,0x18(%rdx)
    TX_STF_P(x, p, r);
  406854:	48 89 50 10          	mov    %rdx,0x10(%rax)
  406858:	48 89 f0             	mov    %rsi,%rax
  40685b:	e9 c3 fc ff ff       	jmpq   406523 <TMfixAfterDeletion+0x3>
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, l);
  406860:	48 89 17             	mov    %rdx,(%rdi)
  406863:	48 89 d6             	mov    %rdx,%rsi
  406866:	e9 fd fd ff ff       	jmpq   406668 <TMfixAfterDeletion+0x148>
  40686b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    } else if (TX_LDNODE(xp, r) == x) {
        TX_STF_P(xp, r, l);
  406870:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  406874:	48 8b 37             	mov    (%rdi),%rsi
  406877:	e9 ec fd ff ff       	jmpq   406668 <TMfixAfterDeletion+0x148>
  40687c:	0f 1f 40 00          	nopl   0x0(%rax)
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, l);
  406880:	48 89 17             	mov    %rdx,(%rdi)
  406883:	e9 1e fd ff ff       	jmpq   4065a6 <TMfixAfterDeletion+0x86>
  406888:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40688f:	00 
    } else if (TX_LDNODE(xp, r) == x) {
        TX_STF_P(xp, r, l);
  406890:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  406894:	e9 0d fd ff ff       	jmpq   4065a6 <TMfixAfterDeletion+0x86>
  406899:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  4068a0:	4c 8b 42 20          	mov    0x20(%rdx),%r8
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  4068a4:	4d 85 c0             	test   %r8,%r8
  4068a7:	0f 84 07 fe ff ff    	je     4066b4 <TMfixAfterDeletion+0x194>
                TX_SET_COLOR(sib, BLACK);
                TX_SET_COLOR(TX_PARENT_OF(x), RED);
                TX_ROTATE_LEFT(s, TX_PARENT_OF(x));
                sib = TX_RIGHT_OF(TX_PARENT_OF(x));
            }
            if (TX_COLOR_OF(TX_LEFT_OF(sib)) == BLACK &&
  4068ad:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  4068b2:	0f 85 13 ff ff ff    	jne    4067cb <TMfixAfterDeletion+0x2ab>
  4068b8:	e9 f7 fd ff ff       	jmpq   4066b4 <TMfixAfterDeletion+0x194>
 * =============================================================================
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
  4068bd:	48 85 c9             	test   %rcx,%rcx
  4068c0:	74 08                	je     4068ca <TMfixAfterDeletion+0x3aa>
        TX_STF(n, c, c);
  4068c2:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  4068c9:	00 
 */
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
  4068ca:	48 8b 41 20          	mov    0x20(%rcx),%rax
 */
static inline void
TMsetColor (TM_ARGDECL  node_t* n, long c)
{
    if (n != NULL) {
        TX_STF(n, c, c);
  4068ce:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  4068d5:	00 
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
  4068d6:	48 85 c0             	test   %rax,%rax
static void
TMrotateRight (TM_ARGDECL  rbtree_t* s, node_t* x)
{
    node_t* l = TX_LDNODE(x, l); /* AKA l,y */
    node_t* lr = TX_LDNODE(l, r);
    TX_STF_P(x, l, lr);
  4068d9:	48 89 42 18          	mov    %rax,0x18(%rdx)
    if (lr != NULL) {
  4068dd:	74 04                	je     4068e3 <TMfixAfterDeletion+0x3c3>
        TX_STF_P(lr, p, x);
  4068df:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    node_t* xp = TX_LDNODE(x, p);
  4068e3:	48 8b 42 10          	mov    0x10(%rdx),%rax
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
  4068e7:	48 85 c0             	test   %rax,%rax
    TX_STF_P(x, l, lr);
    if (lr != NULL) {
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
  4068ea:	48 89 41 10          	mov    %rax,0x10(%rcx)
    if (xp == NULL) {
  4068ee:	74 6d                	je     40695d <TMfixAfterDeletion+0x43d>
        TX_STF_P(s, root, l);
    } else if (TX_LDNODE(xp, r) == x) {
  4068f0:	48 3b 50 20          	cmp    0x20(%rax),%rdx
  4068f4:	74 6c                	je     406962 <TMfixAfterDeletion+0x442>
        TX_STF_P(xp, r, l);
    } else {
        TX_STF_P(xp, l, l);
  4068f6:	48 89 48 18          	mov    %rcx,0x18(%rax)
    }
    TX_STF_P(l, r, x);
  4068fa:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    TX_STF_P(x, p, l);
  4068fe:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  406902:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  406906:	48 85 c0             	test   %rax,%rax
  406909:	74 5d                	je     406968 <TMfixAfterDeletion+0x448>
  40690b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  40690f:	e9 cc fe ff ff       	jmpq   4067e0 <TMfixAfterDeletion+0x2c0>
  406914:	0f 1f 40 00          	nopl   0x0(%rax)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, r);
  406918:	48 89 0f             	mov    %rcx,(%rdi)
  40691b:	e9 ed fd ff ff       	jmpq   40670d <TMfixAfterDeletion+0x1ed>
    } else if (TX_LDNODE(xp, l) == x) {
        TX_STF_P(xp, l, r);
  406920:	48 89 48 18          	mov    %rcx,0x18(%rax)
  406924:	e9 e4 fd ff ff       	jmpq   40670d <TMfixAfterDeletion+0x1ed>
  406929:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, r);
  406930:	48 89 17             	mov    %rdx,(%rdi)
  406933:	48 89 d6             	mov    %rdx,%rsi
  406936:	e9 15 ff ff ff       	jmpq   406850 <TMfixAfterDeletion+0x330>
  40693b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    } else if (TX_LDNODE(xp, l) == x) {
        TX_STF_P(xp, l, r);
  406940:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  406944:	48 8b 37             	mov    (%rdi),%rsi
  406947:	e9 04 ff ff ff       	jmpq   406850 <TMfixAfterDeletion+0x330>
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(r, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, r);
  40694c:	48 89 17             	mov    %rdx,(%rdi)
  40694f:	e9 30 fe ff ff       	jmpq   406784 <TMfixAfterDeletion+0x264>
    } else if (TX_LDNODE(xp, l) == x) {
        TX_STF_P(xp, l, r);
  406954:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  406958:	e9 27 fe ff ff       	jmpq   406784 <TMfixAfterDeletion+0x264>
        TX_STF_P(lr, p, x);
    }
    node_t* xp = TX_LDNODE(x, p);
    TX_STF_P(l, p, xp);
    if (xp == NULL) {
        TX_STF_P(s, root, l);
  40695d:	48 89 0f             	mov    %rcx,(%rdi)
  406960:	eb 98                	jmp    4068fa <TMfixAfterDeletion+0x3da>
    } else if (TX_LDNODE(xp, r) == x) {
        TX_STF_P(xp, r, l);
  406962:	48 89 48 20          	mov    %rcx,0x20(%rax)
  406966:	eb 92                	jmp    4068fa <TMfixAfterDeletion+0x3da>
 * =============================================================================
 */
static inline node_t*
TMrightOf (TM_ARGDECL  node_t* n)
{
    return (n ? TX_LDNODE(n, r) : NULL);
  406968:	31 d2                	xor    %edx,%edx
  40696a:	e9 71 fe ff ff       	jmpq   4067e0 <TMfixAfterDeletion+0x2c0>
 * =============================================================================
 */
static inline node_t*
TMleftOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n, l) : NULL);
  40696f:	31 d2                	xor    %edx,%edx
  406971:	e9 82 fc ff ff       	jmpq   4065f8 <TMfixAfterDeletion+0xd8>
 * =============================================================================
 */
static inline long
TMcolorOf (TM_ARGDECL  node_t* n)
{
    return (n ? (long)TX_LDF(n, c) : BLACK);
  406976:	b9 01 00 00 00       	mov    $0x1,%ecx
  40697b:	e9 6d fe ff ff       	jmpq   4067ed <TMfixAfterDeletion+0x2cd>
  406980:	b9 01 00 00 00       	mov    $0x1,%ecx
  406985:	e9 7b fc ff ff       	jmpq   406605 <TMfixAfterDeletion+0xe5>
 * =============================================================================
 */
static inline node_t*
TMparentOf (TM_ARGDECL  node_t* n)
{
   return (n ? TX_LDNODE(n,p) : NULL);
  40698a:	48 85 f6             	test   %rsi,%rsi
  40698d:	0f 85 29 fd ff ff    	jne    4066bc <TMfixAfterDeletion+0x19c>
  406993:	e9 88 fb ff ff       	jmpq   406520 <TMfixAfterDeletion>
  406998:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40699f:	00 

00000000004069a0 <fixAfterDeletion>:
 * fixAfterDeletion
 * =============================================================================
 */
static void
fixAfterDeletion (rbtree_t* s, node_t* x)
{
  4069a0:	48 8b 07             	mov    (%rdi),%rax
    while (x != LDNODE(s,root) && COLOR_OF(x) == BLACK) {
  4069a3:	48 39 c6             	cmp    %rax,%rsi
  4069a6:	0f 84 50 01 00 00    	je     406afc <fixAfterDeletion+0x15c>
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  4069ac:	48 85 f6             	test   %rsi,%rsi
  4069af:	74 ef                	je     4069a0 <fixAfterDeletion>
 * =============================================================================
 */
static void
fixAfterDeletion (rbtree_t* s, node_t* x)
{
    while (x != LDNODE(s,root) && COLOR_OF(x) == BLACK) {
  4069b1:	48 83 7e 28 01       	cmpq   $0x1,0x28(%rsi)
  4069b6:	0f 85 4c 01 00 00    	jne    406b08 <fixAfterDeletion+0x168>
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  4069bc:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  4069c0:	48 85 c0             	test   %rax,%rax
  4069c3:	0f 84 73 01 00 00    	je     406b3c <fixAfterDeletion+0x19c>
  4069c9:	48 8b 50 18          	mov    0x18(%rax),%rdx
 */
static void
fixAfterDeletion (rbtree_t* s, node_t* x)
{
    while (x != LDNODE(s,root) && COLOR_OF(x) == BLACK) {
        if (x == LEFT_OF(PARENT_OF(x))) {
  4069cd:	48 39 d6             	cmp    %rdx,%rsi
  4069d0:	0f 84 da 01 00 00    	je     406bb0 <fixAfterDeletion+0x210>
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  4069d6:	48 85 d2             	test   %rdx,%rdx
  4069d9:	0f 84 5d 01 00 00    	je     406b3c <fixAfterDeletion+0x19c>
                /* TODO: consider break ... */
                x = LDNODE(s,root);
            }
        } else { /* symmetric */
            node_t* sib = LEFT_OF(PARENT_OF(x));
            if (COLOR_OF(sib) == RED) {
  4069df:	48 83 7a 28 00       	cmpq   $0x0,0x28(%rdx)
  4069e4:	75 62                	jne    406a48 <fixAfterDeletion+0xa8>
 */
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
  4069e6:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  4069ea:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  4069f1:	00 
  4069f2:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  4069f9:	00 
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
    if (lr != NULL) {
  4069fa:	48 85 c9             	test   %rcx,%rcx
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
  4069fd:	48 89 48 18          	mov    %rcx,0x18(%rax)
    if (lr != NULL) {
  406a01:	74 04                	je     406a07 <fixAfterDeletion+0x67>
        STF(lr, p, x);
  406a03:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    node_t* xp = LDNODE(x, p);
  406a07:	48 8b 48 10          	mov    0x10(%rax),%rcx
    STF(l, p, xp);
    if (xp == NULL) {
  406a0b:	48 85 c9             	test   %rcx,%rcx
    STF(x, l, lr);
    if (lr != NULL) {
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
  406a0e:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406a12:	0f 84 e8 02 00 00    	je     406d00 <fixAfterDeletion+0x360>
        STF(s, root, l);
    } else if (LDNODE(xp, r) == x) {
  406a18:	48 3b 41 20          	cmp    0x20(%rcx),%rax
  406a1c:	0f 84 ee 02 00 00    	je     406d10 <fixAfterDeletion+0x370>
        STF(xp, r, l);
    } else {
        STF(xp, l, l);
  406a22:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    }
    STF(l, r, x);
  406a26:	48 89 42 20          	mov    %rax,0x20(%rdx)
    STF(x, p, l);
  406a2a:	48 89 50 10          	mov    %rdx,0x10(%rax)
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406a2e:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406a32:	48 85 c0             	test   %rax,%rax
  406a35:	0f 84 01 01 00 00    	je     406b3c <fixAfterDeletion+0x19c>
  406a3b:	48 8b 50 18          	mov    0x18(%rax),%rdx
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406a3f:	48 85 d2             	test   %rdx,%rdx
  406a42:	0f 84 f4 00 00 00    	je     406b3c <fixAfterDeletion+0x19c>
  406a48:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406a4c:	48 85 c9             	test   %rcx,%rcx
  406a4f:	0f 84 cb 00 00 00    	je     406b20 <fixAfterDeletion+0x180>
                SET_COLOR(sib, BLACK);
                SET_COLOR(PARENT_OF(x), RED);
                ROTATE_RIGHT(s, PARENT_OF(x));
                sib = LEFT_OF(PARENT_OF(x));
            }
            if (COLOR_OF(RIGHT_OF(sib)) == BLACK &&
  406a55:	48 83 79 28 01       	cmpq   $0x1,0x28(%rcx)
  406a5a:	0f 84 c0 00 00 00    	je     406b20 <fixAfterDeletion+0x180>
  406a60:	4c 8b 42 18          	mov    0x18(%rdx),%r8
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406a64:	4d 85 c0             	test   %r8,%r8
  406a67:	0f 84 e0 00 00 00    	je     406b4d <fixAfterDeletion+0x1ad>
            if (COLOR_OF(RIGHT_OF(sib)) == BLACK &&
                COLOR_OF(LEFT_OF(sib)) == BLACK) {
                SET_COLOR(sib,  RED);
                x = PARENT_OF(x);
            } else {
                if (COLOR_OF(LEFT_OF(sib)) == BLACK) {
  406a6d:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  406a72:	0f 84 d0 00 00 00    	je     406b48 <fixAfterDeletion+0x1a8>
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406a78:	48 85 c0             	test   %rax,%rax
  406a7b:	0f 84 7f 03 00 00    	je     406e00 <fixAfterDeletion+0x460>
  406a81:	48 8b 48 28          	mov    0x28(%rax),%rcx
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406a85:	48 85 d2             	test   %rdx,%rdx
  406a88:	74 04                	je     406a8e <fixAfterDeletion+0xee>
        STF(n, c, c);
  406a8a:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406a8e:	48 85 c0             	test   %rax,%rax
  406a91:	74 08                	je     406a9b <fixAfterDeletion+0xfb>
        STF(n, c, c);
  406a93:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  406a9a:	00 
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406a9b:	48 85 d2             	test   %rdx,%rdx
  406a9e:	74 11                	je     406ab1 <fixAfterDeletion+0x111>
  406aa0:	48 8b 52 18          	mov    0x18(%rdx),%rdx
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406aa4:	48 85 d2             	test   %rdx,%rdx
  406aa7:	74 08                	je     406ab1 <fixAfterDeletion+0x111>
        STF(n, c, c);
  406aa9:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406ab0:	00 
 * =============================================================================
 */
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
  406ab1:	48 8b 50 18          	mov    0x18(%rax),%rdx
    node_t* lr = LDNODE(l, r);
  406ab5:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
    STF(x, l, lr);
    if (lr != NULL) {
  406ab9:	48 85 c9             	test   %rcx,%rcx
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
  406abc:	48 89 48 18          	mov    %rcx,0x18(%rax)
    if (lr != NULL) {
  406ac0:	74 04                	je     406ac6 <fixAfterDeletion+0x126>
        STF(lr, p, x);
  406ac2:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    node_t* xp = LDNODE(x, p);
  406ac6:	48 8b 48 10          	mov    0x10(%rax),%rcx
    STF(l, p, xp);
    if (xp == NULL) {
  406aca:	48 85 c9             	test   %rcx,%rcx
    STF(x, l, lr);
    if (lr != NULL) {
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
  406acd:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406ad1:	0f 84 09 02 00 00    	je     406ce0 <fixAfterDeletion+0x340>
        STF(s, root, l);
    } else if (LDNODE(xp, r) == x) {
  406ad7:	48 3b 41 20          	cmp    0x20(%rcx),%rax
  406adb:	0f 84 0f 02 00 00    	je     406cf0 <fixAfterDeletion+0x350>
  406ae1:	48 8b 37             	mov    (%rdi),%rsi
        STF(xp, r, l);
    } else {
        STF(xp, l, l);
  406ae4:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    }
    STF(l, r, x);
  406ae8:	48 89 42 20          	mov    %rax,0x20(%rdx)
    STF(x, p, l);
  406aec:	48 89 50 10          	mov    %rdx,0x10(%rax)
  406af0:	48 89 f0             	mov    %rsi,%rax
 * =============================================================================
 */
static void
fixAfterDeletion (rbtree_t* s, node_t* x)
{
    while (x != LDNODE(s,root) && COLOR_OF(x) == BLACK) {
  406af3:	48 39 c6             	cmp    %rax,%rsi
  406af6:	0f 85 b0 fe ff ff    	jne    4069ac <fixAfterDeletion+0xc>
                x = LDNODE(s, root);
            }
        }
    }

    if (x != NULL && LDF(x,c) != BLACK) {
  406afc:	48 85 f6             	test   %rsi,%rsi
  406aff:	74 17                	je     406b18 <fixAfterDeletion+0x178>
  406b01:	48 83 7e 28 01       	cmpq   $0x1,0x28(%rsi)
  406b06:	74 10                	je     406b18 <fixAfterDeletion+0x178>
       STF(x, c, BLACK);
  406b08:	48 c7 46 28 01 00 00 	movq   $0x1,0x28(%rsi)
  406b0f:	00 
  406b10:	c3                   	retq   
  406b11:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  406b18:	f3 c3                	repz retq 
  406b1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406b20:	4c 8b 42 18          	mov    0x18(%rdx),%r8
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406b24:	4d 85 c0             	test   %r8,%r8
  406b27:	74 0b                	je     406b34 <fixAfterDeletion+0x194>
                SET_COLOR(sib, BLACK);
                SET_COLOR(PARENT_OF(x), RED);
                ROTATE_RIGHT(s, PARENT_OF(x));
                sib = LEFT_OF(PARENT_OF(x));
            }
            if (COLOR_OF(RIGHT_OF(sib)) == BLACK &&
  406b29:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  406b2e:	0f 85 39 ff ff ff    	jne    406a6d <fixAfterDeletion+0xcd>
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  406b34:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  406b3b:	00 
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406b3c:	48 89 c6             	mov    %rax,%rsi
  406b3f:	e9 5c fe ff ff       	jmpq   4069a0 <fixAfterDeletion>
  406b44:	0f 1f 40 00          	nopl   0x0(%rax)
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406b48:	48 85 c9             	test   %rcx,%rcx
  406b4b:	74 08                	je     406b55 <fixAfterDeletion+0x1b5>
        STF(n, c, c);
  406b4d:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  406b54:	00 
 */
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
  406b55:	48 8b 41 18          	mov    0x18(%rcx),%rax
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  406b59:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  406b60:	00 
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
    if (rl != NULL) {
  406b61:	48 85 c0             	test   %rax,%rax
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
  406b64:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (rl != NULL) {
  406b68:	74 04                	je     406b6e <fixAfterDeletion+0x1ce>
        STF(rl, p, x);
  406b6a:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
  406b6e:	48 8b 42 10          	mov    0x10(%rdx),%rax
    STF(r, p, xp);
    if (xp == NULL) {
  406b72:	48 85 c0             	test   %rax,%rax
    if (rl != NULL) {
        STF(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
  406b75:	48 89 41 10          	mov    %rax,0x10(%rcx)
    if (xp == NULL) {
  406b79:	0f 84 19 02 00 00    	je     406d98 <fixAfterDeletion+0x3f8>
        STF(s, root, r);
    } else if (LDNODE(xp, l) == x) {
  406b7f:	48 3b 50 18          	cmp    0x18(%rax),%rdx
  406b83:	0f 84 17 02 00 00    	je     406da0 <fixAfterDeletion+0x400>
        STF(xp, l, r);
    } else {
        STF(xp, r, r);
  406b89:	48 89 48 20          	mov    %rcx,0x20(%rax)
    }
    STF(r, l, x);
  406b8d:	48 89 51 18          	mov    %rdx,0x18(%rcx)
    STF(x, p, r);
  406b91:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406b95:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406b99:	48 85 c0             	test   %rax,%rax
  406b9c:	0f 84 4d 02 00 00    	je     406def <fixAfterDeletion+0x44f>
  406ba2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  406ba6:	e9 cd fe ff ff       	jmpq   406a78 <fixAfterDeletion+0xd8>
  406bab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406bb0:	48 8b 50 20          	mov    0x20(%rax),%rdx
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406bb4:	48 85 d2             	test   %rdx,%rdx
  406bb7:	0f 84 4d 02 00 00    	je     406e0a <fixAfterDeletion+0x46a>
fixAfterDeletion (rbtree_t* s, node_t* x)
{
    while (x != LDNODE(s,root) && COLOR_OF(x) == BLACK) {
        if (x == LEFT_OF(PARENT_OF(x))) {
            node_t* sib = RIGHT_OF(PARENT_OF(x));
            if (COLOR_OF(sib) == RED) {
  406bbd:	48 83 7a 28 00       	cmpq   $0x0,0x28(%rdx)
  406bc2:	75 62                	jne    406c26 <fixAfterDeletion+0x286>
 */
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
  406bc4:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  406bc8:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406bcf:	00 
  406bd0:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  406bd7:	00 
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
    if (rl != NULL) {
  406bd8:	48 85 c9             	test   %rcx,%rcx
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
  406bdb:	48 89 48 20          	mov    %rcx,0x20(%rax)
    if (rl != NULL) {
  406bdf:	74 04                	je     406be5 <fixAfterDeletion+0x245>
        STF(rl, p, x);
  406be1:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
  406be5:	48 8b 48 10          	mov    0x10(%rax),%rcx
    STF(r, p, xp);
    if (xp == NULL) {
  406be9:	48 85 c9             	test   %rcx,%rcx
    if (rl != NULL) {
        STF(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
  406bec:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406bf0:	0f 84 d6 01 00 00    	je     406dcc <fixAfterDeletion+0x42c>
        STF(s, root, r);
    } else if (LDNODE(xp, l) == x) {
  406bf6:	48 3b 41 18          	cmp    0x18(%rcx),%rax
  406bfa:	0f 84 d4 01 00 00    	je     406dd4 <fixAfterDeletion+0x434>
        STF(xp, l, r);
    } else {
        STF(xp, r, r);
  406c00:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    }
    STF(r, l, x);
  406c04:	48 89 42 18          	mov    %rax,0x18(%rdx)
    STF(x, p, r);
  406c08:	48 89 50 10          	mov    %rdx,0x10(%rax)
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406c0c:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406c10:	48 85 c0             	test   %rax,%rax
  406c13:	0f 84 f1 01 00 00    	je     406e0a <fixAfterDeletion+0x46a>
  406c19:	48 8b 50 20          	mov    0x20(%rax),%rdx
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406c1d:	48 85 d2             	test   %rdx,%rdx
  406c20:	0f 84 e4 01 00 00    	je     406e0a <fixAfterDeletion+0x46a>
  406c26:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406c2a:	48 85 c9             	test   %rcx,%rcx
  406c2d:	0f 84 ed 00 00 00    	je     406d20 <fixAfterDeletion+0x380>
                SET_COLOR(sib, BLACK);
                SET_COLOR(PARENT_OF(x), RED);
                ROTATE_LEFT(s, PARENT_OF(x));
                sib = RIGHT_OF(PARENT_OF(x));
            }
            if (COLOR_OF(LEFT_OF(sib)) == BLACK &&
  406c33:	48 83 79 28 01       	cmpq   $0x1,0x28(%rcx)
  406c38:	0f 84 e2 00 00 00    	je     406d20 <fixAfterDeletion+0x380>
  406c3e:	4c 8b 42 20          	mov    0x20(%rdx),%r8
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406c42:	4d 85 c0             	test   %r8,%r8
  406c45:	0f 84 f7 00 00 00    	je     406d42 <fixAfterDeletion+0x3a2>
            if (COLOR_OF(LEFT_OF(sib)) == BLACK &&
                COLOR_OF(RIGHT_OF(sib)) == BLACK) {
                SET_COLOR(sib, RED);
                x = PARENT_OF(x);
            } else {
                if (COLOR_OF(RIGHT_OF(sib)) == BLACK) {
  406c4b:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  406c50:	0f 84 e7 00 00 00    	je     406d3d <fixAfterDeletion+0x39d>
  406c56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  406c5d:	00 00 00 
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406c60:	48 85 c0             	test   %rax,%rax
  406c63:	0f 84 8d 01 00 00    	je     406df6 <fixAfterDeletion+0x456>
  406c69:	48 8b 48 28          	mov    0x28(%rax),%rcx
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406c6d:	48 85 d2             	test   %rdx,%rdx
  406c70:	74 04                	je     406c76 <fixAfterDeletion+0x2d6>
        STF(n, c, c);
  406c72:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406c76:	48 85 c0             	test   %rax,%rax
  406c79:	74 08                	je     406c83 <fixAfterDeletion+0x2e3>
        STF(n, c, c);
  406c7b:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  406c82:	00 
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406c83:	48 85 d2             	test   %rdx,%rdx
  406c86:	74 11                	je     406c99 <fixAfterDeletion+0x2f9>
  406c88:	48 8b 52 20          	mov    0x20(%rdx),%rdx
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406c8c:	48 85 d2             	test   %rdx,%rdx
  406c8f:	74 08                	je     406c99 <fixAfterDeletion+0x2f9>
        STF(n, c, c);
  406c91:	48 c7 42 28 01 00 00 	movq   $0x1,0x28(%rdx)
  406c98:	00 
 * =============================================================================
 */
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
  406c99:	48 8b 50 20          	mov    0x20(%rax),%rdx
    node_t* rl = LDNODE(r, l);
  406c9d:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
    STF(x, r, rl);
    if (rl != NULL) {
  406ca1:	48 85 c9             	test   %rcx,%rcx
static void
rotateLeft (rbtree_t* s, node_t* x)
{
    node_t* r = LDNODE(x, r); /* AKA r, y */
    node_t* rl = LDNODE(r, l);
    STF(x, r, rl);
  406ca4:	48 89 48 20          	mov    %rcx,0x20(%rax)
    if (rl != NULL) {
  406ca8:	74 04                	je     406cae <fixAfterDeletion+0x30e>
        STF(rl, p, x);
  406caa:	48 89 41 10          	mov    %rax,0x10(%rcx)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
  406cae:	48 8b 48 10          	mov    0x10(%rax),%rcx
    STF(r, p, xp);
    if (xp == NULL) {
  406cb2:	48 85 c9             	test   %rcx,%rcx
    if (rl != NULL) {
        STF(rl, p, x);
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
  406cb5:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
    if (xp == NULL) {
  406cb9:	0f 84 f1 00 00 00    	je     406db0 <fixAfterDeletion+0x410>
        STF(s, root, r);
    } else if (LDNODE(xp, l) == x) {
  406cbf:	48 3b 41 18          	cmp    0x18(%rcx),%rax
  406cc3:	0f 84 f7 00 00 00    	je     406dc0 <fixAfterDeletion+0x420>
  406cc9:	48 8b 37             	mov    (%rdi),%rsi
        STF(xp, l, r);
    } else {
        STF(xp, r, r);
  406ccc:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    }
    STF(r, l, x);
  406cd0:	48 89 42 18          	mov    %rax,0x18(%rdx)
    STF(x, p, r);
  406cd4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  406cd8:	48 89 f0             	mov    %rsi,%rax
  406cdb:	e9 c3 fc ff ff       	jmpq   4069a3 <fixAfterDeletion+0x3>
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
    if (xp == NULL) {
        STF(s, root, l);
  406ce0:	48 89 17             	mov    %rdx,(%rdi)
  406ce3:	48 89 d6             	mov    %rdx,%rsi
  406ce6:	e9 fd fd ff ff       	jmpq   406ae8 <fixAfterDeletion+0x148>
  406ceb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    } else if (LDNODE(xp, r) == x) {
        STF(xp, r, l);
  406cf0:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  406cf4:	48 8b 37             	mov    (%rdi),%rsi
  406cf7:	e9 ec fd ff ff       	jmpq   406ae8 <fixAfterDeletion+0x148>
  406cfc:	0f 1f 40 00          	nopl   0x0(%rax)
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
    if (xp == NULL) {
        STF(s, root, l);
  406d00:	48 89 17             	mov    %rdx,(%rdi)
  406d03:	e9 1e fd ff ff       	jmpq   406a26 <fixAfterDeletion+0x86>
  406d08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  406d0f:	00 
    } else if (LDNODE(xp, r) == x) {
        STF(xp, r, l);
  406d10:	48 89 51 20          	mov    %rdx,0x20(%rcx)
  406d14:	e9 0d fd ff ff       	jmpq   406a26 <fixAfterDeletion+0x86>
  406d19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406d20:	4c 8b 42 20          	mov    0x20(%rdx),%r8
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406d24:	4d 85 c0             	test   %r8,%r8
  406d27:	0f 84 07 fe ff ff    	je     406b34 <fixAfterDeletion+0x194>
                SET_COLOR(sib, BLACK);
                SET_COLOR(PARENT_OF(x), RED);
                ROTATE_LEFT(s, PARENT_OF(x));
                sib = RIGHT_OF(PARENT_OF(x));
            }
            if (COLOR_OF(LEFT_OF(sib)) == BLACK &&
  406d2d:	49 83 78 28 01       	cmpq   $0x1,0x28(%r8)
  406d32:	0f 85 13 ff ff ff    	jne    406c4b <fixAfterDeletion+0x2ab>
  406d38:	e9 f7 fd ff ff       	jmpq   406b34 <fixAfterDeletion+0x194>
 * =============================================================================
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
  406d3d:	48 85 c9             	test   %rcx,%rcx
  406d40:	74 08                	je     406d4a <fixAfterDeletion+0x3aa>
        STF(n, c, c);
  406d42:	48 c7 41 28 01 00 00 	movq   $0x1,0x28(%rcx)
  406d49:	00 
 */
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
  406d4a:	48 8b 41 20          	mov    0x20(%rcx),%rax
 */
static inline void
setColor (node_t* n, long c)
{
    if (n != NULL) {
        STF(n, c, c);
  406d4e:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
  406d55:	00 
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
    if (lr != NULL) {
  406d56:	48 85 c0             	test   %rax,%rax
static void
rotateRight (rbtree_t* s, node_t* x)
{
    node_t* l = LDNODE(x, l); /* AKA l,y */
    node_t* lr = LDNODE(l, r);
    STF(x, l, lr);
  406d59:	48 89 42 18          	mov    %rax,0x18(%rdx)
    if (lr != NULL) {
  406d5d:	74 04                	je     406d63 <fixAfterDeletion+0x3c3>
        STF(lr, p, x);
  406d5f:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    node_t* xp = LDNODE(x, p);
  406d63:	48 8b 42 10          	mov    0x10(%rdx),%rax
    STF(l, p, xp);
    if (xp == NULL) {
  406d67:	48 85 c0             	test   %rax,%rax
    STF(x, l, lr);
    if (lr != NULL) {
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
  406d6a:	48 89 41 10          	mov    %rax,0x10(%rcx)
    if (xp == NULL) {
  406d6e:	74 6d                	je     406ddd <fixAfterDeletion+0x43d>
        STF(s, root, l);
    } else if (LDNODE(xp, r) == x) {
  406d70:	48 3b 50 20          	cmp    0x20(%rax),%rdx
  406d74:	74 6c                	je     406de2 <fixAfterDeletion+0x442>
        STF(xp, r, l);
    } else {
        STF(xp, l, l);
  406d76:	48 89 48 18          	mov    %rcx,0x18(%rax)
    }
    STF(l, r, x);
  406d7a:	48 89 51 20          	mov    %rdx,0x20(%rcx)
    STF(x, p, l);
  406d7e:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406d82:	48 8b 46 10          	mov    0x10(%rsi),%rax
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406d86:	48 85 c0             	test   %rax,%rax
  406d89:	74 5d                	je     406de8 <fixAfterDeletion+0x448>
  406d8b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  406d8f:	e9 cc fe ff ff       	jmpq   406c60 <fixAfterDeletion+0x2c0>
  406d94:	0f 1f 40 00          	nopl   0x0(%rax)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
    if (xp == NULL) {
        STF(s, root, r);
  406d98:	48 89 0f             	mov    %rcx,(%rdi)
  406d9b:	e9 ed fd ff ff       	jmpq   406b8d <fixAfterDeletion+0x1ed>
    } else if (LDNODE(xp, l) == x) {
        STF(xp, l, r);
  406da0:	48 89 48 18          	mov    %rcx,0x18(%rax)
  406da4:	e9 e4 fd ff ff       	jmpq   406b8d <fixAfterDeletion+0x1ed>
  406da9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
    if (xp == NULL) {
        STF(s, root, r);
  406db0:	48 89 17             	mov    %rdx,(%rdi)
  406db3:	48 89 d6             	mov    %rdx,%rsi
  406db6:	e9 15 ff ff ff       	jmpq   406cd0 <fixAfterDeletion+0x330>
  406dbb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    } else if (LDNODE(xp, l) == x) {
        STF(xp, l, r);
  406dc0:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  406dc4:	48 8b 37             	mov    (%rdi),%rsi
  406dc7:	e9 04 ff ff ff       	jmpq   406cd0 <fixAfterDeletion+0x330>
    }
    /* TODO: compute p = xp = x->p.  Use xp for R-Values in following */
    node_t* xp = LDNODE(x, p);
    STF(r, p, xp);
    if (xp == NULL) {
        STF(s, root, r);
  406dcc:	48 89 17             	mov    %rdx,(%rdi)
  406dcf:	e9 30 fe ff ff       	jmpq   406c04 <fixAfterDeletion+0x264>
    } else if (LDNODE(xp, l) == x) {
        STF(xp, l, r);
  406dd4:	48 89 51 18          	mov    %rdx,0x18(%rcx)
  406dd8:	e9 27 fe ff ff       	jmpq   406c04 <fixAfterDeletion+0x264>
        STF(lr, p, x);
    }
    node_t* xp = LDNODE(x, p);
    STF(l, p, xp);
    if (xp == NULL) {
        STF(s, root, l);
  406ddd:	48 89 0f             	mov    %rcx,(%rdi)
  406de0:	eb 98                	jmp    406d7a <fixAfterDeletion+0x3da>
    } else if (LDNODE(xp, r) == x) {
        STF(xp, r, l);
  406de2:	48 89 48 20          	mov    %rcx,0x20(%rax)
  406de6:	eb 92                	jmp    406d7a <fixAfterDeletion+0x3da>
 * =============================================================================
 */
static inline node_t*
rightOf (node_t* n)
{
    return (n ? LDNODE(n, r) : NULL);
  406de8:	31 d2                	xor    %edx,%edx
  406dea:	e9 71 fe ff ff       	jmpq   406c60 <fixAfterDeletion+0x2c0>
 * =============================================================================
 */
static inline node_t*
leftOf (node_t* n)
{
   return (n ? LDNODE(n, l) : NULL);
  406def:	31 d2                	xor    %edx,%edx
  406df1:	e9 82 fc ff ff       	jmpq   406a78 <fixAfterDeletion+0xd8>
 * =============================================================================
 */
static inline long
colorOf (node_t* n)
{
    return (n ? (long)LDNODE(n, c) : BLACK);
  406df6:	b9 01 00 00 00       	mov    $0x1,%ecx
  406dfb:	e9 6d fe ff ff       	jmpq   406c6d <fixAfterDeletion+0x2cd>
  406e00:	b9 01 00 00 00       	mov    $0x1,%ecx
  406e05:	e9 7b fc ff ff       	jmpq   406a85 <fixAfterDeletion+0xe5>
 * =============================================================================
 */
static inline node_t*
parentOf (node_t* n)
{
   return (n ? LDNODE(n,p) : NULL);
  406e0a:	48 85 f6             	test   %rsi,%rsi
  406e0d:	0f 85 29 fd ff ff    	jne    406b3c <fixAfterDeletion+0x19c>
  406e13:	e9 88 fb ff ff       	jmpq   4069a0 <fixAfterDeletion>
  406e18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  406e1f:	00 

0000000000406e20 <verifyRedBlack>:
 * verifyRedBlack
 * =============================================================================
 */
static long
verifyRedBlack (node_t* root, long depth)
{
  406e20:	41 57                	push   %r15
  406e22:	41 56                	push   %r14
  406e24:	41 55                	push   %r13
  406e26:	41 54                	push   %r12
  406e28:	55                   	push   %rbp
  406e29:	48 89 fd             	mov    %rdi,%rbp
  406e2c:	53                   	push   %rbx
    long height_left;
    long height_right;

    if (root == NULL) {
        return 1;
  406e2d:	bb 01 00 00 00       	mov    $0x1,%ebx
 * verifyRedBlack
 * =============================================================================
 */
static long
verifyRedBlack (node_t* root, long depth)
{
  406e32:	48 83 ec 28          	sub    $0x28,%rsp
    long height_left;
    long height_right;

    if (root == NULL) {
  406e36:	48 85 ff             	test   %rdi,%rdi
  406e39:	0f 84 bf 04 00 00    	je     4072fe <verifyRedBlack+0x4de>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  406e3f:	4c 8b 6f 18          	mov    0x18(%rdi),%r13
  406e43:	48 8d 46 01          	lea    0x1(%rsi),%rax
  406e47:	49 89 f4             	mov    %rsi,%r12
  406e4a:	48 89 04 24          	mov    %rax,(%rsp)
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  406e4e:	4d 85 ed             	test   %r13,%r13
  406e51:	0f 84 41 02 00 00    	je     407098 <verifyRedBlack+0x278>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  406e57:	4d 8b 7d 18          	mov    0x18(%r13),%r15
  406e5b:	48 8d 46 02          	lea    0x2(%rsi),%rax
  406e5f:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  406e64:	4d 85 ff             	test   %r15,%r15
  406e67:	0f 84 d3 00 00 00    	je     406f40 <verifyRedBlack+0x120>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  406e6d:	48 8d 5e 03          	lea    0x3(%rsi),%rbx
  406e71:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  406e75:	48 89 de             	mov    %rbx,%rsi
  406e78:	e8 a3 ff ff ff       	callq  406e20 <verifyRedBlack>
    height_right = verifyRedBlack(root->r, depth+1);
  406e7d:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  406e81:	48 89 de             	mov    %rbx,%rsi

    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  406e84:	49 89 c6             	mov    %rax,%r14
    height_right = verifyRedBlack(root->r, depth+1);
  406e87:	e8 94 ff ff ff       	callq  406e20 <verifyRedBlack>
    if (height_left == 0 || height_right == 0) {
  406e8c:	48 85 c0             	test   %rax,%rax
  406e8f:	0f 84 1b 06 00 00    	je     4074b0 <verifyRedBlack+0x690>
  406e95:	4d 85 f6             	test   %r14,%r14
  406e98:	0f 84 12 06 00 00    	je     4074b0 <verifyRedBlack+0x690>
        return 0;
    }
    if (height_left != height_right) {
  406e9e:	49 39 c6             	cmp    %rax,%r14
  406ea1:	74 17                	je     406eba <verifyRedBlack+0x9a>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  406ea3:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  406ea8:	48 89 c1             	mov    %rax,%rcx
  406eab:	4c 89 f2             	mov    %r14,%rdx
  406eae:	bf 88 94 40 00       	mov    $0x409488,%edi
  406eb3:	31 c0                	xor    %eax,%eax
  406eb5:	e8 46 9d ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  406eba:	49 8b 47 18          	mov    0x18(%r15),%rax
  406ebe:	48 85 c0             	test   %rax,%rax
  406ec1:	74 10                	je     406ed3 <verifyRedBlack+0xb3>
  406ec3:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  406ec7:	74 0a                	je     406ed3 <verifyRedBlack+0xb3>
       printf(" lineage\n");
  406ec9:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  406ece:	e8 4d 9d ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  406ed3:	49 8b 47 20          	mov    0x20(%r15),%rax
  406ed7:	48 85 c0             	test   %rax,%rax
  406eda:	74 10                	je     406eec <verifyRedBlack+0xcc>
  406edc:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  406ee0:	74 0a                	je     406eec <verifyRedBlack+0xcc>
       printf(" lineage\n");
  406ee2:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  406ee7:	e8 34 9d ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  406eec:	49 8b 5f 28          	mov    0x28(%r15),%rbx
  406ef0:	48 85 db             	test   %rbx,%rbx
  406ef3:	0f 85 47 05 00 00    	jne    407440 <verifyRedBlack+0x620>
        if (root->l != NULL && root->l->c != BLACK) {
  406ef9:	49 8b 47 18          	mov    0x18(%r15),%rax
  406efd:	48 85 c0             	test   %rax,%rax
  406f00:	74 0b                	je     406f0d <verifyRedBlack+0xed>
  406f02:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  406f07:	0f 85 83 07 00 00    	jne    407690 <verifyRedBlack+0x870>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  406f0d:	49 8b 47 20          	mov    0x20(%r15),%rax
  406f11:	48 85 c0             	test   %rax,%rax
  406f14:	0f 84 c6 05 00 00    	je     4074e0 <verifyRedBlack+0x6c0>
  406f1a:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  406f1f:	0f 84 bb 05 00 00    	je     4074e0 <verifyRedBlack+0x6c0>
          printf("VERIFY %d\n", __LINE__);
  406f25:	be 9f 04 00 00       	mov    $0x49f,%esi
  406f2a:	bf 28 95 40 00       	mov    $0x409528,%edi
  406f2f:	31 c0                	xor    %eax,%eax
  406f31:	e8 ca 9c ff ff       	callq  400c00 <printf@plt>
  406f36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  406f3d:	00 00 00 
    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
  406f40:	4d 8b 7d 20          	mov    0x20(%r13),%r15
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  406f44:	4d 85 ff             	test   %r15,%r15
  406f47:	0f 84 43 05 00 00    	je     407490 <verifyRedBlack+0x670>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  406f4d:	49 8d 54 24 03       	lea    0x3(%r12),%rdx
  406f52:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  406f56:	48 89 d6             	mov    %rdx,%rsi
  406f59:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  406f5e:	e8 bd fe ff ff       	callq  406e20 <verifyRedBlack>
    height_right = verifyRedBlack(root->r, depth+1);
  406f63:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  406f68:	49 8b 7f 20          	mov    0x20(%r15),%rdi

    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  406f6c:	49 89 c6             	mov    %rax,%r14
    height_right = verifyRedBlack(root->r, depth+1);
  406f6f:	48 89 d6             	mov    %rdx,%rsi
  406f72:	e8 a9 fe ff ff       	callq  406e20 <verifyRedBlack>
    if (height_left == 0 || height_right == 0) {
  406f77:	48 85 c0             	test   %rax,%rax
  406f7a:	0f 94 c1             	sete   %cl
  406f7d:	4d 85 f6             	test   %r14,%r14
  406f80:	0f 94 c2             	sete   %dl
  406f83:	08 d1                	or     %dl,%cl
  406f85:	0f 85 96 03 00 00    	jne    407321 <verifyRedBlack+0x501>
        return 0;
    }
    if (height_left != height_right) {
  406f8b:	49 39 c6             	cmp    %rax,%r14
  406f8e:	74 17                	je     406fa7 <verifyRedBlack+0x187>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  406f90:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  406f95:	48 89 c1             	mov    %rax,%rcx
  406f98:	4c 89 f2             	mov    %r14,%rdx
  406f9b:	bf 88 94 40 00       	mov    $0x409488,%edi
  406fa0:	31 c0                	xor    %eax,%eax
  406fa2:	e8 59 9c ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  406fa7:	49 8b 47 18          	mov    0x18(%r15),%rax
  406fab:	48 85 c0             	test   %rax,%rax
  406fae:	74 10                	je     406fc0 <verifyRedBlack+0x1a0>
  406fb0:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  406fb4:	74 0a                	je     406fc0 <verifyRedBlack+0x1a0>
       printf(" lineage\n");
  406fb6:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  406fbb:	e8 60 9c ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  406fc0:	49 8b 47 20          	mov    0x20(%r15),%rax
  406fc4:	48 85 c0             	test   %rax,%rax
  406fc7:	74 10                	je     406fd9 <verifyRedBlack+0x1b9>
  406fc9:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  406fcd:	74 0a                	je     406fd9 <verifyRedBlack+0x1b9>
       printf(" lineage\n");
  406fcf:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  406fd4:	e8 47 9c ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  406fd9:	49 8b 47 28          	mov    0x28(%r15),%rax
  406fdd:	48 85 c0             	test   %rax,%rax
  406fe0:	0f 84 fa 03 00 00    	je     4073e0 <verifyRedBlack+0x5c0>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  406fe6:	48 83 f8 01          	cmp    $0x1,%rax
  406fea:	0f 85 20 03 00 00    	jne    407310 <verifyRedBlack+0x4f0>
  406ff0:	4c 89 f1             	mov    %r14,%rcx
  406ff3:	48 83 c1 01          	add    $0x1,%rcx
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
  406ff7:	0f 84 24 03 00 00    	je     407321 <verifyRedBlack+0x501>
  406ffd:	48 85 db             	test   %rbx,%rbx
  407000:	0f 84 1b 03 00 00    	je     407321 <verifyRedBlack+0x501>
        return 0;
    }
    if (height_left != height_right) {
  407006:	48 39 cb             	cmp    %rcx,%rbx
  407009:	74 13                	je     40701e <verifyRedBlack+0x1fe>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  40700b:	48 8b 34 24          	mov    (%rsp),%rsi
  40700f:	48 89 da             	mov    %rbx,%rdx
  407012:	bf 88 94 40 00       	mov    $0x409488,%edi
  407017:	31 c0                	xor    %eax,%eax
  407019:	e8 e2 9b ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  40701e:	49 8b 45 18          	mov    0x18(%r13),%rax
  407022:	48 85 c0             	test   %rax,%rax
  407025:	74 10                	je     407037 <verifyRedBlack+0x217>
  407027:	4c 3b 68 10          	cmp    0x10(%rax),%r13
  40702b:	74 0a                	je     407037 <verifyRedBlack+0x217>
       printf(" lineage\n");
  40702d:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407032:	e8 e9 9b ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  407037:	49 8b 45 20          	mov    0x20(%r13),%rax
  40703b:	48 85 c0             	test   %rax,%rax
  40703e:	74 10                	je     407050 <verifyRedBlack+0x230>
  407040:	4c 3b 68 10          	cmp    0x10(%rax),%r13
  407044:	74 0a                	je     407050 <verifyRedBlack+0x230>
       printf(" lineage\n");
  407046:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  40704b:	e8 d0 9b ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  407050:	49 8b 45 28          	mov    0x28(%r13),%rax
  407054:	48 85 c0             	test   %rax,%rax
  407057:	0f 85 03 05 00 00    	jne    407560 <verifyRedBlack+0x740>
        if (root->l != NULL && root->l->c != BLACK) {
  40705d:	49 8b 45 18          	mov    0x18(%r13),%rax
  407061:	48 85 c0             	test   %rax,%rax
  407064:	74 0b                	je     407071 <verifyRedBlack+0x251>
  407066:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  40706b:	0f 85 7f 05 00 00    	jne    4075f0 <verifyRedBlack+0x7d0>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  407071:	49 8b 45 20          	mov    0x20(%r13),%rax
  407075:	48 85 c0             	test   %rax,%rax
  407078:	74 1e                	je     407098 <verifyRedBlack+0x278>
  40707a:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  40707f:	74 17                	je     407098 <verifyRedBlack+0x278>
          printf("VERIFY %d\n", __LINE__);
  407081:	be 9f 04 00 00       	mov    $0x49f,%esi
  407086:	bf 28 95 40 00       	mov    $0x409528,%edi
  40708b:	31 c0                	xor    %eax,%eax
          return 0;
  40708d:	31 db                	xor    %ebx,%ebx
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
  40708f:	e8 6c 9b ff ff       	callq  400c00 <printf@plt>
  407094:	0f 1f 40 00          	nopl   0x0(%rax)
    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
  407098:	4c 8b 6d 20          	mov    0x20(%rbp),%r13
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  40709c:	4d 85 ed             	test   %r13,%r13
  40709f:	0f 84 8b 02 00 00    	je     407330 <verifyRedBlack+0x510>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  4070a5:	4d 8b 7d 18          	mov    0x18(%r13),%r15
  4070a9:	49 8d 44 24 02       	lea    0x2(%r12),%rax
{
    long height_left;
    long height_right;

    if (root == NULL) {
        return 1;
  4070ae:	41 be 01 00 00 00    	mov    $0x1,%r14d
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  4070b4:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  4070b9:	4d 85 ff             	test   %r15,%r15
  4070bc:	0f 84 ce 00 00 00    	je     407190 <verifyRedBlack+0x370>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  4070c2:	4d 8d 74 24 03       	lea    0x3(%r12),%r14
  4070c7:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4070cb:	4c 89 f6             	mov    %r14,%rsi
  4070ce:	e8 4d fd ff ff       	callq  406e20 <verifyRedBlack>
    height_right = verifyRedBlack(root->r, depth+1);
  4070d3:	49 8b 7f 20          	mov    0x20(%r15),%rdi
  4070d7:	4c 89 f6             	mov    %r14,%rsi

    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  4070da:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    height_right = verifyRedBlack(root->r, depth+1);
  4070df:	e8 3c fd ff ff       	callq  406e20 <verifyRedBlack>
    if (height_left == 0 || height_right == 0) {
  4070e4:	48 85 c0             	test   %rax,%rax
  4070e7:	0f 84 db 03 00 00    	je     4074c8 <verifyRedBlack+0x6a8>
  4070ed:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  4070f2:	48 85 d2             	test   %rdx,%rdx
  4070f5:	0f 84 cd 03 00 00    	je     4074c8 <verifyRedBlack+0x6a8>
        return 0;
    }
    if (height_left != height_right) {
  4070fb:	48 39 c2             	cmp    %rax,%rdx
  4070fe:	74 14                	je     407114 <verifyRedBlack+0x2f4>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  407100:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  407105:	48 89 c1             	mov    %rax,%rcx
  407108:	bf 88 94 40 00       	mov    $0x409488,%edi
  40710d:	31 c0                	xor    %eax,%eax
  40710f:	e8 ec 9a ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  407114:	49 8b 47 18          	mov    0x18(%r15),%rax
  407118:	48 85 c0             	test   %rax,%rax
  40711b:	74 10                	je     40712d <verifyRedBlack+0x30d>
  40711d:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  407121:	74 0a                	je     40712d <verifyRedBlack+0x30d>
       printf(" lineage\n");
  407123:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407128:	e8 f3 9a ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  40712d:	49 8b 47 20          	mov    0x20(%r15),%rax
  407131:	48 85 c0             	test   %rax,%rax
  407134:	74 10                	je     407146 <verifyRedBlack+0x326>
  407136:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  40713a:	74 0a                	je     407146 <verifyRedBlack+0x326>
       printf(" lineage\n");
  40713c:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407141:	e8 da 9a ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  407146:	4d 8b 77 28          	mov    0x28(%r15),%r14
  40714a:	4d 85 f6             	test   %r14,%r14
  40714d:	0f 85 d5 02 00 00    	jne    407428 <verifyRedBlack+0x608>
        if (root->l != NULL && root->l->c != BLACK) {
  407153:	49 8b 47 18          	mov    0x18(%r15),%rax
  407157:	48 85 c0             	test   %rax,%rax
  40715a:	74 0b                	je     407167 <verifyRedBlack+0x347>
  40715c:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  407161:	0f 85 09 05 00 00    	jne    407670 <verifyRedBlack+0x850>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  407167:	49 8b 47 20          	mov    0x20(%r15),%rax
  40716b:	48 85 c0             	test   %rax,%rax
  40716e:	0f 84 8c 03 00 00    	je     407500 <verifyRedBlack+0x6e0>
  407174:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  407179:	0f 84 81 03 00 00    	je     407500 <verifyRedBlack+0x6e0>
          printf("VERIFY %d\n", __LINE__);
  40717f:	be 9f 04 00 00       	mov    $0x49f,%esi
  407184:	bf 28 95 40 00       	mov    $0x409528,%edi
  407189:	31 c0                	xor    %eax,%eax
  40718b:	e8 70 9a ff ff       	callq  400c00 <printf@plt>
    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
  407190:	4d 8b 7d 20          	mov    0x20(%r13),%r15
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  407194:	4d 85 ff             	test   %r15,%r15
  407197:	0f 84 03 03 00 00    	je     4074a0 <verifyRedBlack+0x680>
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  40719d:	49 8d 54 24 03       	lea    0x3(%r12),%rdx
  4071a2:	49 8b 7f 18          	mov    0x18(%r15),%rdi
  4071a6:	48 89 d6             	mov    %rdx,%rsi
  4071a9:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  4071ae:	e8 6d fc ff ff       	callq  406e20 <verifyRedBlack>
    height_right = verifyRedBlack(root->r, depth+1);
  4071b3:	48 8b 54 24 10       	mov    0x10(%rsp),%rdx
  4071b8:	49 8b 7f 20          	mov    0x20(%r15),%rdi

    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
  4071bc:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    height_right = verifyRedBlack(root->r, depth+1);
  4071c1:	48 89 d6             	mov    %rdx,%rsi
  4071c4:	e8 57 fc ff ff       	callq  406e20 <verifyRedBlack>
    if (height_left == 0 || height_right == 0) {
  4071c9:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  4071ce:	48 85 c0             	test   %rax,%rax
  4071d1:	40 0f 94 c6          	sete   %sil
  4071d5:	48 85 c9             	test   %rcx,%rcx
  4071d8:	0f 94 c2             	sete   %dl
  4071db:	40 08 d6             	or     %dl,%sil
  4071de:	40 88 74 24 10       	mov    %sil,0x10(%rsp)
  4071e3:	0f 85 13 01 00 00    	jne    4072fc <verifyRedBlack+0x4dc>
        return 0;
    }
    if (height_left != height_right) {
  4071e9:	48 39 c1             	cmp    %rax,%rcx
  4071ec:	48 89 ca             	mov    %rcx,%rdx
  4071ef:	74 14                	je     407205 <verifyRedBlack+0x3e5>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  4071f1:	48 8b 74 24 18       	mov    0x18(%rsp),%rsi
  4071f6:	48 89 c1             	mov    %rax,%rcx
  4071f9:	bf 88 94 40 00       	mov    $0x409488,%edi
  4071fe:	31 c0                	xor    %eax,%eax
  407200:	e8 fb 99 ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  407205:	49 8b 47 18          	mov    0x18(%r15),%rax
  407209:	48 85 c0             	test   %rax,%rax
  40720c:	74 10                	je     40721e <verifyRedBlack+0x3fe>
  40720e:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  407212:	74 0a                	je     40721e <verifyRedBlack+0x3fe>
       printf(" lineage\n");
  407214:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407219:	e8 02 9a ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  40721e:	49 8b 47 20          	mov    0x20(%r15),%rax
  407222:	48 85 c0             	test   %rax,%rax
  407225:	74 10                	je     407237 <verifyRedBlack+0x417>
  407227:	4c 3b 78 10          	cmp    0x10(%rax),%r15
  40722b:	74 0a                	je     407237 <verifyRedBlack+0x417>
       printf(" lineage\n");
  40722d:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407232:	e8 e9 99 ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  407237:	49 8b 47 28          	mov    0x28(%r15),%rax
  40723b:	48 85 c0             	test   %rax,%rax
  40723e:	0f 84 14 02 00 00    	je     407458 <verifyRedBlack+0x638>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  407244:	48 83 f8 01          	cmp    $0x1,%rax
  407248:	0f 85 42 03 00 00    	jne    407590 <verifyRedBlack+0x770>
  40724e:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  407253:	48 83 c1 01          	add    $0x1,%rcx
  407257:	0f 94 44 24 10       	sete   0x10(%rsp)
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
  40725c:	0f b6 74 24 10       	movzbl 0x10(%rsp),%esi
  407261:	4d 85 f6             	test   %r14,%r14
  407264:	0f 94 c0             	sete   %al
  407267:	40 08 c6             	or     %al,%sil
  40726a:	0f 85 8c 00 00 00    	jne    4072fc <verifyRedBlack+0x4dc>
        return 0;
    }
    if (height_left != height_right) {
  407270:	49 39 ce             	cmp    %rcx,%r14
  407273:	74 13                	je     407288 <verifyRedBlack+0x468>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  407275:	48 8b 34 24          	mov    (%rsp),%rsi
  407279:	4c 89 f2             	mov    %r14,%rdx
  40727c:	bf 88 94 40 00       	mov    $0x409488,%edi
  407281:	31 c0                	xor    %eax,%eax
  407283:	e8 78 99 ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  407288:	49 8b 45 18          	mov    0x18(%r13),%rax
  40728c:	48 85 c0             	test   %rax,%rax
  40728f:	74 10                	je     4072a1 <verifyRedBlack+0x481>
  407291:	4c 3b 68 10          	cmp    0x10(%rax),%r13
  407295:	74 0a                	je     4072a1 <verifyRedBlack+0x481>
       printf(" lineage\n");
  407297:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  40729c:	e8 7f 99 ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  4072a1:	49 8b 45 20          	mov    0x20(%r13),%rax
  4072a5:	48 85 c0             	test   %rax,%rax
  4072a8:	74 10                	je     4072ba <verifyRedBlack+0x49a>
  4072aa:	4c 3b 68 10          	cmp    0x10(%rax),%r13
  4072ae:	74 0a                	je     4072ba <verifyRedBlack+0x49a>
       printf(" lineage\n");
  4072b0:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  4072b5:	e8 66 99 ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  4072ba:	49 8b 45 28          	mov    0x28(%r13),%rax
  4072be:	48 85 c0             	test   %rax,%rax
  4072c1:	0f 85 79 02 00 00    	jne    407540 <verifyRedBlack+0x720>
        if (root->l != NULL && root->l->c != BLACK) {
  4072c7:	49 8b 45 18          	mov    0x18(%r13),%rax
  4072cb:	48 85 c0             	test   %rax,%rax
  4072ce:	74 0b                	je     4072db <verifyRedBlack+0x4bb>
  4072d0:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  4072d5:	0f 85 d5 02 00 00    	jne    4075b0 <verifyRedBlack+0x790>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  4072db:	49 8b 45 20          	mov    0x20(%r13),%rax
  4072df:	48 85 c0             	test   %rax,%rax
  4072e2:	74 52                	je     407336 <verifyRedBlack+0x516>
  4072e4:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  4072e9:	74 4b                	je     407336 <verifyRedBlack+0x516>
          printf("VERIFY %d\n", __LINE__);
  4072eb:	be 9f 04 00 00       	mov    $0x49f,%esi
  4072f0:	bf 28 95 40 00       	mov    $0x409528,%edi
  4072f5:	31 c0                	xor    %eax,%eax
  4072f7:	e8 04 99 ff ff       	callq  400c00 <printf@plt>
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
        return 0;
  4072fc:	31 db                	xor    %ebx,%ebx
        printf("VERIFY %d\n", __LINE__);
        return 0;
    }

    return (height_left + 1);
}
  4072fe:	48 83 c4 28          	add    $0x28,%rsp
  407302:	48 89 d8             	mov    %rbx,%rax
  407305:	5b                   	pop    %rbx
  407306:	5d                   	pop    %rbp
  407307:	41 5c                	pop    %r12
  407309:	41 5d                	pop    %r13
  40730b:	41 5e                	pop    %r14
  40730d:	41 5f                	pop    %r15
  40730f:	c3                   	retq   
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
        printf("VERIFY %d\n", __LINE__);
  407310:	be a5 04 00 00       	mov    $0x4a5,%esi
  407315:	bf 28 95 40 00       	mov    $0x409528,%edi
  40731a:	31 c0                	xor    %eax,%eax
  40731c:	e8 df 98 ff ff       	callq  400c00 <printf@plt>
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
        return 0;
  407321:	31 db                	xor    %ebx,%ebx
    if (root == NULL) {
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
  407323:	4c 8b 6d 20          	mov    0x20(%rbp),%r13
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  407327:	4d 85 ed             	test   %r13,%r13
  40732a:	0f 85 75 fd ff ff    	jne    4070a5 <verifyRedBlack+0x285>
        return 1;
  407330:	41 be 01 00 00 00    	mov    $0x1,%r14d
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
  407336:	48 85 db             	test   %rbx,%rbx
  407339:	74 c1                	je     4072fc <verifyRedBlack+0x4dc>
        return 0;
    }
    if (height_left != height_right) {
  40733b:	4c 39 f3             	cmp    %r14,%rbx
  40733e:	74 15                	je     407355 <verifyRedBlack+0x535>
        printf(" Imbalance @depth=%ld : %ld %ld\n", depth, height_left, height_right);
  407340:	4c 89 f1             	mov    %r14,%rcx
  407343:	48 89 da             	mov    %rbx,%rdx
  407346:	4c 89 e6             	mov    %r12,%rsi
  407349:	bf 88 94 40 00       	mov    $0x409488,%edi
  40734e:	31 c0                	xor    %eax,%eax
  407350:	e8 ab 98 ff ff       	callq  400c00 <printf@plt>
    }

    if (root->l != NULL && root->l->p != root) {
  407355:	48 8b 45 18          	mov    0x18(%rbp),%rax
  407359:	48 85 c0             	test   %rax,%rax
  40735c:	74 10                	je     40736e <verifyRedBlack+0x54e>
  40735e:	48 39 68 10          	cmp    %rbp,0x10(%rax)
  407362:	74 0a                	je     40736e <verifyRedBlack+0x54e>
       printf(" lineage\n");
  407364:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407369:	e8 b2 98 ff ff       	callq  400c20 <puts@plt>
    }
    if (root->r != NULL && root->r->p != root) {
  40736e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  407372:	48 85 c0             	test   %rax,%rax
  407375:	74 10                	je     407387 <verifyRedBlack+0x567>
  407377:	48 39 68 10          	cmp    %rbp,0x10(%rax)
  40737b:	74 0a                	je     407387 <verifyRedBlack+0x567>
       printf(" lineage\n");
  40737d:	bf 1f 95 40 00       	mov    $0x40951f,%edi
  407382:	e8 99 98 ff ff       	callq  400c20 <puts@plt>
    }

    /* Red-Black alternation */
    if (root->c == RED) {
  407387:	48 8b 45 28          	mov    0x28(%rbp),%rax
  40738b:	48 85 c0             	test   %rax,%rax
  40738e:	0f 85 7c 01 00 00    	jne    407510 <verifyRedBlack+0x6f0>
        if (root->l != NULL && root->l->c != BLACK) {
  407394:	48 8b 45 18          	mov    0x18(%rbp),%rax
  407398:	48 85 c0             	test   %rax,%rax
  40739b:	74 0b                	je     4073a8 <verifyRedBlack+0x588>
  40739d:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  4073a2:	0f 85 28 02 00 00    	jne    4075d0 <verifyRedBlack+0x7b0>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  4073a8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  4073ac:	48 85 c0             	test   %rax,%rax
  4073af:	0f 84 49 ff ff ff    	je     4072fe <verifyRedBlack+0x4de>
  4073b5:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  4073ba:	0f 84 3e ff ff ff    	je     4072fe <verifyRedBlack+0x4de>
          printf("VERIFY %d\n", __LINE__);
  4073c0:	be 9f 04 00 00       	mov    $0x49f,%esi
  4073c5:	bf 28 95 40 00       	mov    $0x409528,%edi
  4073ca:	31 c0                	xor    %eax,%eax
  4073cc:	e8 2f 98 ff ff       	callq  400c00 <printf@plt>
          return 0;
  4073d1:	31 db                	xor    %ebx,%ebx
  4073d3:	e9 26 ff ff ff       	jmpq   4072fe <verifyRedBlack+0x4de>
  4073d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4073df:	00 
       printf(" lineage\n");
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
  4073e0:	49 8b 47 18          	mov    0x18(%r15),%rax
  4073e4:	48 85 c0             	test   %rax,%rax
  4073e7:	74 0b                	je     4073f4 <verifyRedBlack+0x5d4>
  4073e9:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  4073ee:	0f 85 5c 02 00 00    	jne    407650 <verifyRedBlack+0x830>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  4073f4:	49 8b 47 20          	mov    0x20(%r15),%rax
  4073f8:	48 85 c0             	test   %rax,%rax
  4073fb:	0f 84 ef 00 00 00    	je     4074f0 <verifyRedBlack+0x6d0>
  407401:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  407406:	0f 84 e4 00 00 00    	je     4074f0 <verifyRedBlack+0x6d0>
          printf("VERIFY %d\n", __LINE__);
  40740c:	be 9f 04 00 00       	mov    $0x49f,%esi
  407411:	bf 28 95 40 00       	mov    $0x409528,%edi
  407416:	31 c0                	xor    %eax,%eax
  407418:	e8 e3 97 ff ff       	callq  400c00 <printf@plt>
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
        return 0;
  40741d:	31 db                	xor    %ebx,%ebx
  40741f:	e9 ff fe ff ff       	jmpq   407323 <verifyRedBlack+0x503>
  407424:	0f 1f 40 00          	nopl   0x0(%rax)
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  407428:	49 83 fe 01          	cmp    $0x1,%r14
  40742c:	0f 85 de 01 00 00    	jne    407610 <verifyRedBlack+0x7f0>
        printf("VERIFY %d\n", __LINE__);
        return 0;
    }

    return (height_left + 1);
  407432:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  407437:	49 83 c6 01          	add    $0x1,%r14
  40743b:	e9 50 fd ff ff       	jmpq   407190 <verifyRedBlack+0x370>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  407440:	48 83 fb 01          	cmp    $0x1,%rbx
  407444:	0f 85 e6 01 00 00    	jne    407630 <verifyRedBlack+0x810>
        printf("VERIFY %d\n", __LINE__);
        return 0;
    }

    return (height_left + 1);
  40744a:	49 8d 5e 01          	lea    0x1(%r14),%rbx
  40744e:	e9 ed fa ff ff       	jmpq   406f40 <verifyRedBlack+0x120>
  407453:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
       printf(" lineage\n");
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
  407458:	49 8b 47 18          	mov    0x18(%r15),%rax
  40745c:	48 85 c0             	test   %rax,%rax
  40745f:	74 0b                	je     40746c <verifyRedBlack+0x64c>
  407461:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  407466:	0f 85 44 01 00 00    	jne    4075b0 <verifyRedBlack+0x790>
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  40746c:	49 8b 47 20          	mov    0x20(%r15),%rax
  407470:	48 85 c0             	test   %rax,%rax
  407473:	74 0b                	je     407480 <verifyRedBlack+0x660>
  407475:	48 83 78 28 01       	cmpq   $0x1,0x28(%rax)
  40747a:	0f 85 6b fe ff ff    	jne    4072eb <verifyRedBlack+0x4cb>
  407480:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
  407485:	e9 d2 fd ff ff       	jmpq   40725c <verifyRedBlack+0x43c>
  40748a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    long height_left;
    long height_right;

    if (root == NULL) {
        return 1;
  407490:	b9 01 00 00 00       	mov    $0x1,%ecx
  407495:	e9 63 fb ff ff       	jmpq   406ffd <verifyRedBlack+0x1dd>
  40749a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  4074a0:	c6 44 24 10 00       	movb   $0x0,0x10(%rsp)
        return 1;
  4074a5:	b9 01 00 00 00       	mov    $0x1,%ecx
  4074aa:	e9 ad fd ff ff       	jmpq   40725c <verifyRedBlack+0x43c>
  4074af:	90                   	nop
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
  4074b0:	4d 8b 7d 20          	mov    0x20(%r13),%r15
    if (height_left == 0 || height_right == 0) {
        return 0;
  4074b4:	31 db                	xor    %ebx,%ebx
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  4074b6:	4d 85 ff             	test   %r15,%r15
  4074b9:	0f 85 8e fa ff ff    	jne    406f4d <verifyRedBlack+0x12d>
  4074bf:	eb cf                	jmp    407490 <verifyRedBlack+0x670>
  4074c1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
  4074c8:	4d 8b 7d 20          	mov    0x20(%r13),%r15
    if (height_left == 0 || height_right == 0) {
        return 0;
  4074cc:	45 31 f6             	xor    %r14d,%r14d
verifyRedBlack (node_t* root, long depth)
{
    long height_left;
    long height_right;

    if (root == NULL) {
  4074cf:	4d 85 ff             	test   %r15,%r15
  4074d2:	0f 85 c5 fc ff ff    	jne    40719d <verifyRedBlack+0x37d>
  4074d8:	eb c6                	jmp    4074a0 <verifyRedBlack+0x680>
  4074da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        if (root->r != NULL && root->r->c != BLACK) {
  4074e0:	4c 89 f3             	mov    %r14,%rbx
  4074e3:	e9 58 fa ff ff       	jmpq   406f40 <verifyRedBlack+0x120>
  4074e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4074ef:	00 
  4074f0:	4c 89 f1             	mov    %r14,%rcx
  4074f3:	e9 05 fb ff ff       	jmpq   406ffd <verifyRedBlack+0x1dd>
  4074f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4074ff:	00 
  407500:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  407505:	e9 86 fc ff ff       	jmpq   407190 <verifyRedBlack+0x370>
  40750a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (root->c != BLACK) {
        printf("VERIFY %d\n", __LINE__);
        return 0;
    }

    return (height_left + 1);
  407510:	48 83 c3 01          	add    $0x1,%rbx
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  407514:	48 83 f8 01          	cmp    $0x1,%rax
  407518:	0f 84 e0 fd ff ff    	je     4072fe <verifyRedBlack+0x4de>
        printf("VERIFY %d\n", __LINE__);
  40751e:	be a5 04 00 00       	mov    $0x4a5,%esi
  407523:	bf 28 95 40 00       	mov    $0x409528,%edi
  407528:	31 c0                	xor    %eax,%eax
  40752a:	e8 d1 96 ff ff       	callq  400c00 <printf@plt>
        return 0;
  40752f:	31 db                	xor    %ebx,%ebx
  407531:	e9 c8 fd ff ff       	jmpq   4072fe <verifyRedBlack+0x4de>
  407536:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40753d:	00 00 00 
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  407540:	48 83 f8 01          	cmp    $0x1,%rax
  407544:	75 4a                	jne    407590 <verifyRedBlack+0x770>
  407546:	49 83 c6 01          	add    $0x1,%r14
        return 1;
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
  40754a:	0f 85 e6 fd ff ff    	jne    407336 <verifyRedBlack+0x516>
        return 0;
  407550:	31 db                	xor    %ebx,%ebx
  407552:	e9 a7 fd ff ff       	jmpq   4072fe <verifyRedBlack+0x4de>
  407557:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40755e:	00 00 
    if (root->c != BLACK) {
        printf("VERIFY %d\n", __LINE__);
        return 0;
    }

    return (height_left + 1);
  407560:	48 83 c3 01          	add    $0x1,%rbx
          printf("VERIFY %d\n", __LINE__);
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
  407564:	48 83 f8 01          	cmp    $0x1,%rax
  407568:	0f 84 2a fb ff ff    	je     407098 <verifyRedBlack+0x278>
        printf("VERIFY %d\n", __LINE__);
  40756e:	be a5 04 00 00       	mov    $0x4a5,%esi
  407573:	bf 28 95 40 00       	mov    $0x409528,%edi
  407578:	31 c0                	xor    %eax,%eax
  40757a:	e8 81 96 ff ff       	callq  400c00 <printf@plt>
        return 0;
  40757f:	31 db                	xor    %ebx,%ebx
  407581:	e9 12 fb ff ff       	jmpq   407098 <verifyRedBlack+0x278>
  407586:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40758d:	00 00 00 
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
        printf("VERIFY %d\n", __LINE__);
  407590:	be a5 04 00 00       	mov    $0x4a5,%esi
  407595:	bf 28 95 40 00       	mov    $0x409528,%edi
  40759a:	31 c0                	xor    %eax,%eax
  40759c:	e8 5f 96 ff ff       	callq  400c00 <printf@plt>
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
        return 0;
  4075a1:	31 db                	xor    %ebx,%ebx
  4075a3:	e9 56 fd ff ff       	jmpq   4072fe <verifyRedBlack+0x4de>
  4075a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4075af:	00 
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
  4075b0:	be 9b 04 00 00       	mov    $0x49b,%esi
  4075b5:	bf 28 95 40 00       	mov    $0x409528,%edi
  4075ba:	31 c0                	xor    %eax,%eax
  4075bc:	e8 3f 96 ff ff       	callq  400c00 <printf@plt>
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
        return 0;
  4075c1:	31 db                	xor    %ebx,%ebx
  4075c3:	e9 36 fd ff ff       	jmpq   4072fe <verifyRedBlack+0x4de>
  4075c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4075cf:	00 
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
  4075d0:	be 9b 04 00 00       	mov    $0x49b,%esi
  4075d5:	bf 28 95 40 00       	mov    $0x409528,%edi
  4075da:	31 c0                	xor    %eax,%eax
  4075dc:	e8 1f 96 ff ff       	callq  400c00 <printf@plt>
          return 0;
  4075e1:	31 db                	xor    %ebx,%ebx
  4075e3:	e9 16 fd ff ff       	jmpq   4072fe <verifyRedBlack+0x4de>
  4075e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4075ef:	00 
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
  4075f0:	be 9b 04 00 00       	mov    $0x49b,%esi
  4075f5:	bf 28 95 40 00       	mov    $0x409528,%edi
  4075fa:	31 c0                	xor    %eax,%eax
  4075fc:	e8 ff 95 ff ff       	callq  400c00 <printf@plt>
          return 0;
  407601:	31 db                	xor    %ebx,%ebx
  407603:	e9 90 fa ff ff       	jmpq   407098 <verifyRedBlack+0x278>
  407608:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40760f:	00 
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
        printf("VERIFY %d\n", __LINE__);
  407610:	be a5 04 00 00       	mov    $0x4a5,%esi
  407615:	bf 28 95 40 00       	mov    $0x409528,%edi
  40761a:	31 c0                	xor    %eax,%eax
  40761c:	e8 df 95 ff ff       	callq  400c00 <printf@plt>
        return 0;
  407621:	45 31 f6             	xor    %r14d,%r14d
  407624:	e9 67 fb ff ff       	jmpq   407190 <verifyRedBlack+0x370>
  407629:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
          return 0;
        }
        return height_left;
    }
    if (root->c != BLACK) {
        printf("VERIFY %d\n", __LINE__);
  407630:	be a5 04 00 00       	mov    $0x4a5,%esi
  407635:	bf 28 95 40 00       	mov    $0x409528,%edi
  40763a:	31 c0                	xor    %eax,%eax
  40763c:	e8 bf 95 ff ff       	callq  400c00 <printf@plt>
        return 0;
  407641:	31 db                	xor    %ebx,%ebx
  407643:	e9 f8 f8 ff ff       	jmpq   406f40 <verifyRedBlack+0x120>
  407648:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40764f:	00 
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
  407650:	be 9b 04 00 00       	mov    $0x49b,%esi
  407655:	bf 28 95 40 00       	mov    $0x409528,%edi
  40765a:	31 c0                	xor    %eax,%eax
  40765c:	e8 9f 95 ff ff       	callq  400c00 <printf@plt>
    }

    height_left  = verifyRedBlack(root->l, depth+1);
    height_right = verifyRedBlack(root->r, depth+1);
    if (height_left == 0 || height_right == 0) {
        return 0;
  407661:	31 db                	xor    %ebx,%ebx
  407663:	e9 bb fc ff ff       	jmpq   407323 <verifyRedBlack+0x503>
  407668:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40766f:	00 
    }

    /* Red-Black alternation */
    if (root->c == RED) {
        if (root->l != NULL && root->l->c != BLACK) {
          printf("VERIFY %d\n", __LINE__);
  407670:	be 9b 04 00 00       	mov    $0x49b,%esi
  407675:	bf 28 95 40 00       	mov    $0x409528,%edi
  40767a:	31 c0                	xor    %eax,%eax
  40767c:	e8 7f 95 ff ff       	callq  400c00 <printf@plt>
  407681:	e9 0a fb ff ff       	jmpq   407190 <verifyRedBlack+0x370>
  407686:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40768d:	00 00 00 
  407690:	be 9b 04 00 00       	mov    $0x49b,%esi
  407695:	bf 28 95 40 00       	mov    $0x409528,%edi
  40769a:	31 c0                	xor    %eax,%eax
  40769c:	e8 5f 95 ff ff       	callq  400c00 <printf@plt>
  4076a1:	e9 9a f8 ff ff       	jmpq   406f40 <verifyRedBlack+0x120>
  4076a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4076ad:	00 00 00 

00000000004076b0 <rbtree_verify>:
 * rbtree_verify
 * =============================================================================
 */
long
rbtree_verify (rbtree_t* s, long verbose)
{
  4076b0:	41 57                	push   %r15
  4076b2:	41 56                	push   %r14
  4076b4:	41 55                	push   %r13
  4076b6:	41 54                	push   %r12
  4076b8:	49 89 fc             	mov    %rdi,%r12
  4076bb:	55                   	push   %rbp
  4076bc:	53                   	push   %rbx
  4076bd:	48 83 ec 18          	sub    $0x18,%rsp
    node_t* root = s->root;
  4076c1:	48 8b 2f             	mov    (%rdi),%rbp
    if (root == NULL) {
  4076c4:	48 85 ed             	test   %rbp,%rbp
  4076c7:	0f 84 26 01 00 00    	je     4077f3 <rbtree_verify+0x143>
        return 1;
    }
    if (verbose) {
  4076cd:	48 85 f6             	test   %rsi,%rsi
  4076d0:	49 89 f5             	mov    %rsi,%r13
  4076d3:	0f 85 f1 00 00 00    	jne    4077ca <rbtree_verify+0x11a>
       printf("Integrity check: ");
    }

    if (root->p != NULL) {
  4076d9:	4c 8b 7d 10          	mov    0x10(%rbp),%r15
  4076dd:	4d 85 ff             	test   %r15,%r15
  4076e0:	0f 85 14 01 00 00    	jne    4077fa <rbtree_verify+0x14a>
        printf("  (WARNING) root %lX parent=%lX\n",
               (unsigned long)root, (unsigned long)root->p);
        return -1;
    }
    if (root->c != BLACK) {
  4076e6:	48 8b 55 28          	mov    0x28(%rbp),%rdx
  4076ea:	48 83 fa 01          	cmp    $0x1,%rdx
  4076ee:	74 0f                	je     4076ff <rbtree_verify+0x4f>
        printf("  (WARNING) root %lX color=%lX\n",
  4076f0:	48 89 ee             	mov    %rbp,%rsi
  4076f3:	bf d8 94 40 00       	mov    $0x4094d8,%edi
  4076f8:	31 c0                	xor    %eax,%eax
  4076fa:	e8 01 95 ff ff       	callq  400c00 <printf@plt>
/* =============================================================================
 * rbtree_verify
 * =============================================================================
 */
long
rbtree_verify (rbtree_t* s, long verbose)
  4076ff:	4d 8b 34 24          	mov    (%r12),%r14
 */
static node_t*
firstEntry (rbtree_t* s)
{
    node_t* p = s->root;
    if (p != NULL) {
  407703:	4d 85 f6             	test   %r14,%r14
  407706:	75 0b                	jne    407713 <rbtree_verify+0x63>
  407708:	e9 e2 00 00 00       	jmpq   4077ef <rbtree_verify+0x13f>
  40770d:	0f 1f 00             	nopl   (%rax)
        while (p->l != NULL) {
  407710:	49 89 c6             	mov    %rax,%r14
  407713:	49 8b 46 18          	mov    0x18(%r14),%rax
  407717:	48 85 c0             	test   %rax,%rax
  40771a:	75 f4                	jne    407710 <rbtree_verify+0x60>
  40771c:	31 db                	xor    %ebx,%ebx
  40771e:	66 90                	xchg   %ax,%ax

    /* Weak check of binary-tree property */
    long ctr = 0;
    node_t* its = firstEntry(s);
    while (its != NULL) {
        ctr++;
  407720:	48 83 c3 01          	add    $0x1,%rbx
        node_t* child = its->l;
        if (child != NULL && child->p != its) {
  407724:	4d 85 ff             	test   %r15,%r15
  407727:	74 10                	je     407739 <rbtree_verify+0x89>
  407729:	4d 39 77 10          	cmp    %r14,0x10(%r15)
  40772d:	74 0a                	je     407739 <rbtree_verify+0x89>
            printf("Bad parent\n");
  40772f:	bf 45 95 40 00       	mov    $0x409545,%edi
  407734:	e8 e7 94 ff ff       	callq  400c20 <puts@plt>
        }
        child = its->r;
  407739:	4d 8b 46 20          	mov    0x20(%r14),%r8
        if (child != NULL && child->p != its) {
  40773d:	4d 85 c0             	test   %r8,%r8
  407740:	74 36                	je     407778 <rbtree_verify+0xc8>
  407742:	4d 39 70 10          	cmp    %r14,0x10(%r8)
  407746:	74 1b                	je     407763 <rbtree_verify+0xb3>
            printf("Bad parent\n");
  407748:	bf 45 95 40 00       	mov    $0x409545,%edi
  40774d:	e8 ce 94 ff ff       	callq  400c20 <puts@plt>
static node_t*
successor (node_t* t)
{
    if (t == NULL) {
        return NULL;
    } else if (LDNODE(t, r) != NULL) {
  407752:	4d 8b 46 20          	mov    0x20(%r14),%r8
  407756:	4d 85 c0             	test   %r8,%r8
  407759:	75 08                	jne    407763 <rbtree_verify+0xb3>
  40775b:	eb 1b                	jmp    407778 <rbtree_verify+0xc8>
  40775d:	0f 1f 00             	nopl   (%rax)
        node_t* p = LDNODE(t, r);
        while (LDNODE(p, l) != NULL) {
            p = LDNODE(p, l);
  407760:	49 89 c0             	mov    %rax,%r8
{
    if (t == NULL) {
        return NULL;
    } else if (LDNODE(t, r) != NULL) {
        node_t* p = LDNODE(t, r);
        while (LDNODE(p, l) != NULL) {
  407763:	49 8b 40 18          	mov    0x18(%r8),%rax
  407767:	48 85 c0             	test   %rax,%rax
  40776a:	75 f4                	jne    407760 <rbtree_verify+0xb0>
  40776c:	e9 af 00 00 00       	jmpq   407820 <rbtree_verify+0x170>
  407771:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            p = LDNODE(p, l);
        }
        return p;
    } else {
        node_t* p = LDNODE(t, p);
  407778:	49 8b 46 10          	mov    0x10(%r14),%rax
        node_t* ch = t;
        while (p != NULL && ch == LDNODE(p, r)) {
  40777c:	48 85 c0             	test   %rax,%rax
  40777f:	74 25                	je     4077a6 <rbtree_verify+0xf6>
  407781:	4c 39 70 20          	cmp    %r14,0x20(%rax)
  407785:	74 16                	je     40779d <rbtree_verify+0xed>
  407787:	e9 89 00 00 00       	jmpq   407815 <rbtree_verify+0x165>
  40778c:	0f 1f 40 00          	nopl   0x0(%rax)
  407790:	49 39 40 20          	cmp    %rax,0x20(%r8)
  407794:	0f 85 86 00 00 00    	jne    407820 <rbtree_verify+0x170>
  40779a:	4c 89 c0             	mov    %r8,%rax
            ch = p;
            p = LDNODE(p, p);
  40779d:	4c 8b 40 10          	mov    0x10(%rax),%r8
        }
        return p;
    } else {
        node_t* p = LDNODE(t, p);
        node_t* ch = t;
        while (p != NULL && ch == LDNODE(p, r)) {
  4077a1:	4d 85 c0             	test   %r8,%r8
  4077a4:	75 ea                	jne    407790 <rbtree_verify+0xe0>
            return -3;
        }
        its = nxt;
    }

    long vfy = verifyRedBlack(root, 0);
  4077a6:	31 f6                	xor    %esi,%esi
  4077a8:	48 89 ef             	mov    %rbp,%rdi
  4077ab:	e8 70 f6 ff ff       	callq  406e20 <verifyRedBlack>
    if (verbose) {
  4077b0:	4d 85 ed             	test   %r13,%r13
            return -3;
        }
        its = nxt;
    }

    long vfy = verifyRedBlack(root, 0);
  4077b3:	48 89 c5             	mov    %rax,%rbp
    if (verbose) {
  4077b6:	75 23                	jne    4077db <rbtree_verify+0x12b>
        printf(" Nodes=%ld Depth=%ld\n", ctr, vfy);
    }

    return vfy;
}
  4077b8:	48 83 c4 18          	add    $0x18,%rsp
  4077bc:	48 89 e8             	mov    %rbp,%rax
  4077bf:	5b                   	pop    %rbx
  4077c0:	5d                   	pop    %rbp
  4077c1:	41 5c                	pop    %r12
  4077c3:	41 5d                	pop    %r13
  4077c5:	41 5e                	pop    %r14
  4077c7:	41 5f                	pop    %r15
  4077c9:	c3                   	retq   
    node_t* root = s->root;
    if (root == NULL) {
        return 1;
    }
    if (verbose) {
       printf("Integrity check: ");
  4077ca:	bf 33 95 40 00       	mov    $0x409533,%edi
  4077cf:	31 c0                	xor    %eax,%eax
  4077d1:	e8 2a 94 ff ff       	callq  400c00 <printf@plt>
  4077d6:	e9 fe fe ff ff       	jmpq   4076d9 <rbtree_verify+0x29>
        its = nxt;
    }

    long vfy = verifyRedBlack(root, 0);
    if (verbose) {
        printf(" Nodes=%ld Depth=%ld\n", ctr, vfy);
  4077db:	48 89 c2             	mov    %rax,%rdx
  4077de:	48 89 de             	mov    %rbx,%rsi
  4077e1:	bf 50 95 40 00       	mov    $0x409550,%edi
  4077e6:	31 c0                	xor    %eax,%eax
  4077e8:	e8 13 94 ff ff       	callq  400c00 <printf@plt>
  4077ed:	eb c9                	jmp    4077b8 <rbtree_verify+0x108>
 */
static node_t*
firstEntry (rbtree_t* s)
{
    node_t* p = s->root;
    if (p != NULL) {
  4077ef:	31 db                	xor    %ebx,%ebx
  4077f1:	eb b3                	jmp    4077a6 <rbtree_verify+0xf6>
long
rbtree_verify (rbtree_t* s, long verbose)
{
    node_t* root = s->root;
    if (root == NULL) {
        return 1;
  4077f3:	bd 01 00 00 00       	mov    $0x1,%ebp
  4077f8:	eb be                	jmp    4077b8 <rbtree_verify+0x108>
    if (verbose) {
       printf("Integrity check: ");
    }

    if (root->p != NULL) {
        printf("  (WARNING) root %lX parent=%lX\n",
  4077fa:	48 89 ee             	mov    %rbp,%rsi
  4077fd:	4c 89 fa             	mov    %r15,%rdx
  407800:	bf b0 94 40 00       	mov    $0x4094b0,%edi
  407805:	31 c0                	xor    %eax,%eax
               (unsigned long)root, (unsigned long)root->p);
        return -1;
  407807:	48 c7 c5 ff ff ff ff 	mov    $0xffffffffffffffff,%rbp
    if (verbose) {
       printf("Integrity check: ");
    }

    if (root->p != NULL) {
        printf("  (WARNING) root %lX parent=%lX\n",
  40780e:	e8 ed 93 ff ff       	callq  400c00 <printf@plt>
               (unsigned long)root, (unsigned long)root->p);
        return -1;
  407813:	eb a3                	jmp    4077b8 <rbtree_verify+0x108>
        }
        return p;
    } else {
        node_t* p = LDNODE(t, p);
        node_t* ch = t;
        while (p != NULL && ch == LDNODE(p, r)) {
  407815:	49 89 c0             	mov    %rax,%r8
  407818:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40781f:	00 
        }
        node_t* nxt = successor(its);
        if (nxt == NULL) {
            break;
        }
        if (s->compare(its->k, nxt->k) >= 0) {
  407820:	49 8b 30             	mov    (%r8),%rsi
  407823:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  407828:	49 8b 3e             	mov    (%r14),%rdi
  40782b:	41 ff 54 24 08       	callq  *0x8(%r12)
  407830:	48 85 c0             	test   %rax,%rax
  407833:	4c 8b 44 24 08       	mov    0x8(%rsp),%r8
  407838:	79 0c                	jns    407846 <rbtree_verify+0x196>
  40783a:	4d 8b 78 18          	mov    0x18(%r8),%r15
  40783e:	4d 89 c6             	mov    %r8,%r14
  407841:	e9 da fe ff ff       	jmpq   407720 <rbtree_verify+0x70>
            printf("Key order %lX (%ld %ld) %lX (%ld %ld)\n",
  407846:	49 8b 40 08          	mov    0x8(%r8),%rax
  40784a:	49 8b 4e 08          	mov    0x8(%r14),%rcx
  40784e:	4c 89 f6             	mov    %r14,%rsi
  407851:	bf f8 94 40 00       	mov    $0x4094f8,%edi
                   (unsigned long)its, (long)its->k, (long)its->v,
                   (unsigned long)nxt, (long)nxt->k, (long)nxt->v);
            return -3;
  407856:	48 c7 c5 fd ff ff ff 	mov    $0xfffffffffffffffd,%rbp
        node_t* nxt = successor(its);
        if (nxt == NULL) {
            break;
        }
        if (s->compare(its->k, nxt->k) >= 0) {
            printf("Key order %lX (%ld %ld) %lX (%ld %ld)\n",
  40785d:	48 89 04 24          	mov    %rax,(%rsp)
  407861:	4d 8b 08             	mov    (%r8),%r9
  407864:	31 c0                	xor    %eax,%eax
  407866:	49 8b 16             	mov    (%r14),%rdx
  407869:	e8 92 93 ff ff       	callq  400c00 <printf@plt>
                   (unsigned long)its, (long)its->k, (long)its->v,
                   (unsigned long)nxt, (long)nxt->k, (long)nxt->v);
            return -3;
  40786e:	e9 45 ff ff ff       	jmpq   4077b8 <rbtree_verify+0x108>
  407873:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40787a:	84 00 00 00 00 00 

0000000000407880 <rbtree_alloc>:
 * rbtree_alloc
 * =============================================================================
 */
rbtree_t*
rbtree_alloc (long (*compare)(const void*, const void*))
{
  407880:	53                   	push   %rbx
  407881:	48 89 fb             	mov    %rdi,%rbx
    rbtree_t* n = (rbtree_t* )malloc(sizeof(*n));
  407884:	bf 10 00 00 00       	mov    $0x10,%edi
  407889:	e8 f2 93 ff ff       	callq  400c80 <malloc@plt>
    if (n) {
  40788e:	48 85 c0             	test   %rax,%rax
  407891:	74 17                	je     4078aa <rbtree_alloc+0x2a>
        n->compare = (compare ? compare : &compareKeysDefault);
  407893:	ba d0 51 40 00       	mov    $0x4051d0,%edx
  407898:	48 85 db             	test   %rbx,%rbx
        n->root = NULL;
  40789b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
rbtree_t*
rbtree_alloc (long (*compare)(const void*, const void*))
{
    rbtree_t* n = (rbtree_t* )malloc(sizeof(*n));
    if (n) {
        n->compare = (compare ? compare : &compareKeysDefault);
  4078a2:	48 0f 45 d3          	cmovne %rbx,%rdx
  4078a6:	48 89 50 08          	mov    %rdx,0x8(%rax)
        n->root = NULL;
    }
    return n;
}
  4078aa:	5b                   	pop    %rbx
  4078ab:	c3                   	retq   
  4078ac:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004078b0 <TMrbtree_alloc>:
 * TMrbtree_alloc
 * =============================================================================
 */
rbtree_t*
TMrbtree_alloc (TM_ARGDECL  long (*compare)(const void*, const void*))
{
  4078b0:	53                   	push   %rbx
  4078b1:	48 89 fb             	mov    %rdi,%rbx
    rbtree_t* n = (rbtree_t* )TM_MALLOC(sizeof(*n));
  4078b4:	bf 10 00 00 00       	mov    $0x10,%edi
  4078b9:	e8 c2 93 ff ff       	callq  400c80 <malloc@plt>
    if (n){
  4078be:	48 85 c0             	test   %rax,%rax
  4078c1:	74 17                	je     4078da <TMrbtree_alloc+0x2a>
        n->compare = (compare ? compare : &compareKeysDefault);
  4078c3:	ba d0 51 40 00       	mov    $0x4051d0,%edx
  4078c8:	48 85 db             	test   %rbx,%rbx
        n->root = NULL;
  4078cb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
rbtree_t*
TMrbtree_alloc (TM_ARGDECL  long (*compare)(const void*, const void*))
{
    rbtree_t* n = (rbtree_t* )TM_MALLOC(sizeof(*n));
    if (n){
        n->compare = (compare ? compare : &compareKeysDefault);
  4078d2:	48 0f 45 d3          	cmovne %rbx,%rdx
  4078d6:	48 89 50 08          	mov    %rdx,0x8(%rax)
        n->root = NULL;
    }
    return n;
}
  4078da:	5b                   	pop    %rbx
  4078db:	c3                   	retq   
  4078dc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004078e0 <rbtree_free>:
 * rbtree_free
 * =============================================================================
 */
void
rbtree_free (rbtree_t* r)
{
  4078e0:	55                   	push   %rbp
  4078e1:	48 89 fd             	mov    %rdi,%rbp
  4078e4:	53                   	push   %rbx
  4078e5:	48 83 ec 08          	sub    $0x8,%rsp
    freeNode(r->root);
  4078e9:	48 8b 1f             	mov    (%rdi),%rbx
 * =============================================================================
 */
static void
freeNode (node_t* n)
{
    if (n) {
  4078ec:	48 85 db             	test   %rbx,%rbx
  4078ef:	74 1a                	je     40790b <rbtree_free+0x2b>
        freeNode(n->l);
  4078f1:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  4078f5:	e8 c6 df ff ff       	callq  4058c0 <freeNode>
        freeNode(n->r);
  4078fa:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  4078fe:	e8 bd df ff ff       	callq  4058c0 <freeNode>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  407903:	48 89 df             	mov    %rbx,%rdi
  407906:	e8 a5 93 ff ff       	callq  400cb0 <free@plt>
void
rbtree_free (rbtree_t* r)
{
    freeNode(r->root);
    free(r);
}
  40790b:	48 83 c4 08          	add    $0x8,%rsp
 */
void
rbtree_free (rbtree_t* r)
{
    freeNode(r->root);
    free(r);
  40790f:	48 89 ef             	mov    %rbp,%rdi
}
  407912:	5b                   	pop    %rbx
  407913:	5d                   	pop    %rbp
 */
void
rbtree_free (rbtree_t* r)
{
    freeNode(r->root);
    free(r);
  407914:	e9 97 93 ff ff       	jmpq   400cb0 <free@plt>
  407919:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000407920 <TMrbtree_free>:
 * TMrbtree_free
 * =============================================================================
 */
void
TMrbtree_free (TM_ARGDECL  rbtree_t* r)
{
  407920:	55                   	push   %rbp
  407921:	48 89 fd             	mov    %rdi,%rbp
  407924:	53                   	push   %rbx
  407925:	48 83 ec 08          	sub    $0x8,%rsp
    TMfreeNode(TM_ARG  r->root);
  407929:	48 8b 1f             	mov    (%rdi),%rbx
 * =============================================================================
 */
static void
TMfreeNode (TM_ARGDECL  node_t* n)
{
    if (n) {
  40792c:	48 85 db             	test   %rbx,%rbx
  40792f:	74 1a                	je     40794b <TMrbtree_free+0x2b>
        TMfreeNode(TM_ARG  n->l);
  407931:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
  407935:	e8 a6 d8 ff ff       	callq  4051e0 <TMfreeNode>
        TMfreeNode(TM_ARG  n->r);
  40793a:	48 8b 7b 20          	mov    0x20(%rbx),%rdi
  40793e:	e8 9d d8 ff ff       	callq  4051e0 <TMfreeNode>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  407943:	48 89 df             	mov    %rbx,%rdi
  407946:	e8 65 93 ff ff       	callq  400cb0 <free@plt>
void
TMrbtree_free (TM_ARGDECL  rbtree_t* r)
{
    TMfreeNode(TM_ARG  r->root);
    TM_FREE(r);
}
  40794b:	48 83 c4 08          	add    $0x8,%rsp
 */
void
TMrbtree_free (TM_ARGDECL  rbtree_t* r)
{
    TMfreeNode(TM_ARG  r->root);
    TM_FREE(r);
  40794f:	48 89 ef             	mov    %rbp,%rdi
}
  407952:	5b                   	pop    %rbx
  407953:	5d                   	pop    %rbp
 */
void
TMrbtree_free (TM_ARGDECL  rbtree_t* r)
{
    TMfreeNode(TM_ARG  r->root);
    TM_FREE(r);
  407954:	e9 57 93 ff ff       	jmpq   400cb0 <free@plt>
  407959:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000407960 <rbtree_insert>:
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
rbtree_insert (rbtree_t* r, void* key, void* val)
{
  407960:	41 56                	push   %r14
  407962:	49 89 d6             	mov    %rdx,%r14
  407965:	41 55                	push   %r13
  407967:	41 54                	push   %r12
  407969:	49 89 f4             	mov    %rsi,%r12
  40796c:	55                   	push   %rbp
  40796d:	48 89 fd             	mov    %rdi,%rbp
 * =============================================================================
 */
static node_t*
getNode ()
{
    node_t* n = (node_t*)malloc(sizeof(*n));
  407970:	bf 30 00 00 00       	mov    $0x30,%edi
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
rbtree_insert (rbtree_t* r, void* key, void* val)
{
  407975:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
getNode ()
{
    node_t* n = (node_t*)malloc(sizeof(*n));
  407976:	e8 05 93 ff ff       	callq  400c80 <malloc@plt>
 * =============================================================================
 */
static node_t*
insert (rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = LDNODE(s, root);
  40797b:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
 * =============================================================================
 */
static node_t*
getNode ()
{
    node_t* n = (node_t*)malloc(sizeof(*n));
  40797f:	49 89 c5             	mov    %rax,%r13
 */
static node_t*
insert (rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = LDNODE(s, root);
    if (t == NULL) {
  407982:	48 85 db             	test   %rbx,%rbx
  407985:	75 15                	jne    40799c <rbtree_insert+0x3c>
  407987:	e9 ad 00 00 00       	jmpq   407a39 <rbtree_insert+0xd9>
  40798c:	0f 1f 40 00          	nopl   0x0(%rax)
                STF(t, l, n);
                FIX_AFTER_INSERTION(s, n);
                return NULL;
            }
        } else { /* cmp > 0 */
            node_t* tr = LDNODE(t, r);
  407990:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
            if (tr != NULL) {
  407994:	48 85 c9             	test   %rcx,%rcx
  407997:	74 67                	je     407a00 <rbtree_insert+0xa0>
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
rbtree_insert (rbtree_t* r, void* key, void* val)
{
  407999:	48 89 cb             	mov    %rcx,%rbx
        STF(s, root, n);
        return NULL;
    }

    for (;;) {
        long cmp = s->compare(k, LDF(t, k));
  40799c:	48 8b 33             	mov    (%rbx),%rsi
  40799f:	4c 89 e7             	mov    %r12,%rdi
  4079a2:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  4079a5:	48 85 c0             	test   %rax,%rax
  4079a8:	74 3e                	je     4079e8 <rbtree_insert+0x88>
            return t;
        } else if (cmp < 0) {
  4079aa:	79 e4                	jns    407990 <rbtree_insert+0x30>
            node_t* tl = LDNODE(t, l);
  4079ac:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
            if (tl != NULL) {
  4079b0:	48 85 c9             	test   %rcx,%rcx
  4079b3:	75 e4                	jne    407999 <rbtree_insert+0x39>
                t = tl;
            } else {
                STF(n, l, NULL);
  4079b5:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  4079bc:	00 
                STF(n, r, NULL);
  4079bd:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  4079c4:	00 
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
                STF(t, l, n);
                FIX_AFTER_INSERTION(s, n);
  4079c5:	4c 89 ee             	mov    %r13,%rsi
            if (tl != NULL) {
                t = tl;
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
  4079c8:	4d 89 65 00          	mov    %r12,0x0(%r13)
                STF(n, v, v);
  4079cc:	4d 89 75 08          	mov    %r14,0x8(%r13)
                STF(n, p, t);
                STF(t, l, n);
                FIX_AFTER_INSERTION(s, n);
  4079d0:	48 89 ef             	mov    %rbp,%rdi
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
  4079d3:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                STF(t, l, n);
  4079d7:	4c 89 6b 18          	mov    %r13,0x18(%rbx)
                FIX_AFTER_INSERTION(s, n);
  4079db:	e8 c0 e5 ff ff       	callq  405fa0 <fixAfterInsertion>
  4079e0:	eb 49                	jmp    407a2b <rbtree_insert+0xcb>
  4079e2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  4079e8:	4c 89 ef             	mov    %r13,%rdi
  4079eb:	e8 c0 92 ff ff       	callq  400cb0 <free@plt>
    node_t* ex = INSERT(r, key, val, node);
    if (ex != NULL) {
        releaseNode(node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  4079f0:	5b                   	pop    %rbx
  4079f1:	5d                   	pop    %rbp
  4079f2:	41 5c                	pop    %r12
  4079f4:	41 5d                	pop    %r13
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  4079f6:	31 c0                	xor    %eax,%eax
    node_t* ex = INSERT(r, key, val, node);
    if (ex != NULL) {
        releaseNode(node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  4079f8:	41 5e                	pop    %r14
  4079fa:	c3                   	retq   
  4079fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        } else { /* cmp > 0 */
            node_t* tr = LDNODE(t, r);
            if (tr != NULL) {
                t = tr;
            } else {
                STF(n, l, NULL);
  407a00:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  407a07:	00 
                STF(n, r, NULL);
  407a08:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  407a0f:	00 
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
                STF(t, r, n);
                FIX_AFTER_INSERTION(s, n);
  407a10:	4c 89 ee             	mov    %r13,%rsi
            if (tr != NULL) {
                t = tr;
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
  407a13:	4d 89 65 00          	mov    %r12,0x0(%r13)
                STF(n, v, v);
  407a17:	4d 89 75 08          	mov    %r14,0x8(%r13)
                STF(n, p, t);
                STF(t, r, n);
                FIX_AFTER_INSERTION(s, n);
  407a1b:	48 89 ef             	mov    %rbp,%rdi
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
  407a1e:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                STF(t, r, n);
  407a22:	4c 89 6b 20          	mov    %r13,0x20(%rbx)
                FIX_AFTER_INSERTION(s, n);
  407a26:	e8 75 e5 ff ff       	callq  405fa0 <fixAfterInsertion>
    node_t* ex = INSERT(r, key, val, node);
    if (ex != NULL) {
        releaseNode(node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  407a2b:	5b                   	pop    %rbx
  407a2c:	5d                   	pop    %rbp
  407a2d:	41 5c                	pop    %r12
  407a2f:	41 5d                	pop    %r13
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
rbtree_insert (rbtree_t* r, void* key, void* val)
{
  407a31:	b8 01 00 00 00       	mov    $0x1,%eax
    node_t* ex = INSERT(r, key, val, node);
    if (ex != NULL) {
        releaseNode(node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  407a36:	41 5e                	pop    %r14
  407a38:	c3                   	retq   
static node_t*
insert (rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = LDNODE(s, root);
    if (t == NULL) {
        if (n == NULL) {
  407a39:	48 85 c0             	test   %rax,%rax
  407a3c:	74 ed                	je     407a2b <rbtree_insert+0xcb>
            return NULL;
        }
        /* Note: the following STs don't really need to be transactional */
        STF(n, l, NULL);
  407a3e:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  407a45:	00 
        STF(n, r, NULL);
  407a46:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  407a4d:	00 
        STF(n, p, NULL);
  407a4e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  407a55:	00 
        STF(n, k, k);
  407a56:	4c 89 20             	mov    %r12,(%rax)
        STF(n, v, v);
  407a59:	4c 89 70 08          	mov    %r14,0x8(%rax)
        STF(n, c, BLACK);
  407a5d:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  407a64:	00 
        STF(s, root, n);
  407a65:	48 89 45 00          	mov    %rax,0x0(%rbp)
  407a69:	eb c0                	jmp    407a2b <rbtree_insert+0xcb>
  407a6b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000407a70 <TMrbtree_insert>:
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
TMrbtree_insert (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407a70:	41 56                	push   %r14
  407a72:	49 89 d6             	mov    %rdx,%r14
  407a75:	41 55                	push   %r13
  407a77:	41 54                	push   %r12
  407a79:	49 89 f4             	mov    %rsi,%r12
  407a7c:	55                   	push   %rbp
  407a7d:	48 89 fd             	mov    %rdi,%rbp
 * =============================================================================
 */
static node_t*
TMgetNode (TM_ARGDECL_ALONE)
{
    node_t* n = (node_t*)TM_MALLOC(sizeof(*n));
  407a80:	bf 30 00 00 00       	mov    $0x30,%edi
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
TMrbtree_insert (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407a85:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
TMgetNode (TM_ARGDECL_ALONE)
{
    node_t* n = (node_t*)TM_MALLOC(sizeof(*n));
  407a86:	e8 f5 91 ff ff       	callq  400c80 <malloc@plt>
 * =============================================================================
 */
static node_t*
TMinsert (TM_ARGDECL  rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = TX_LDNODE(s, root);
  407a8b:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
 * =============================================================================
 */
static node_t*
TMgetNode (TM_ARGDECL_ALONE)
{
    node_t* n = (node_t*)TM_MALLOC(sizeof(*n));
  407a8f:	49 89 c5             	mov    %rax,%r13
 */
static node_t*
TMinsert (TM_ARGDECL  rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = TX_LDNODE(s, root);
    if (t == NULL) {
  407a92:	48 85 db             	test   %rbx,%rbx
  407a95:	75 15                	jne    407aac <TMrbtree_insert+0x3c>
  407a97:	e9 ad 00 00 00       	jmpq   407b49 <TMrbtree_insert+0xd9>
  407a9c:	0f 1f 40 00          	nopl   0x0(%rax)
                TX_STF_P(t, l, n);
                TX_FIX_AFTER_INSERTION(s, n);
                return NULL;
            }
        } else { /* cmp > 0 */
            node_t* tr = TX_LDNODE(t, r);
  407aa0:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
            if (tr != NULL) {
  407aa4:	48 85 c9             	test   %rcx,%rcx
  407aa7:	74 67                	je     407b10 <TMrbtree_insert+0xa0>
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
TMrbtree_insert (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407aa9:	48 89 cb             	mov    %rcx,%rbx
        TX_STF_P(s, root, n);
        return NULL;
    }

    for (;;) {
        long cmp = s->compare(k, TX_LDF_P(t, k));
  407aac:	48 8b 33             	mov    (%rbx),%rsi
  407aaf:	4c 89 e7             	mov    %r12,%rdi
  407ab2:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  407ab5:	48 85 c0             	test   %rax,%rax
  407ab8:	74 3e                	je     407af8 <TMrbtree_insert+0x88>
            return t;
        } else if (cmp < 0) {
  407aba:	79 e4                	jns    407aa0 <TMrbtree_insert+0x30>
            node_t* tl = TX_LDNODE(t, l);
  407abc:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
            if (tl != NULL) {
  407ac0:	48 85 c9             	test   %rcx,%rcx
  407ac3:	75 e4                	jne    407aa9 <TMrbtree_insert+0x39>
                t = tl;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
  407ac5:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  407acc:	00 
                TX_STF_P(n, r, (node_t*)NULL);
  407acd:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  407ad4:	00 
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
                TX_STF_P(t, l, n);
                TX_FIX_AFTER_INSERTION(s, n);
  407ad5:	4c 89 ee             	mov    %r13,%rsi
            if (tl != NULL) {
                t = tl;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
  407ad8:	4d 89 65 00          	mov    %r12,0x0(%r13)
                TX_STF(n, v, v);
  407adc:	4d 89 75 08          	mov    %r14,0x8(%r13)
                TX_STF_P(n, p, t);
                TX_STF_P(t, l, n);
                TX_FIX_AFTER_INSERTION(s, n);
  407ae0:	48 89 ef             	mov    %rbp,%rdi
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
  407ae3:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                TX_STF_P(t, l, n);
  407ae7:	4c 89 6b 18          	mov    %r13,0x18(%rbx)
                TX_FIX_AFTER_INSERTION(s, n);
  407aeb:	e8 70 e7 ff ff       	callq  406260 <TMfixAfterInsertion>
  407af0:	eb 49                	jmp    407b3b <TMrbtree_insert+0xcb>
  407af2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  407af8:	4c 89 ef             	mov    %r13,%rdi
  407afb:	e8 b0 91 ff ff       	callq  400cb0 <free@plt>
    node_t* ex = TX_INSERT(r, key, val, node);
    if (ex != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  407b00:	5b                   	pop    %rbx
  407b01:	5d                   	pop    %rbp
  407b02:	41 5c                	pop    %r12
  407b04:	41 5d                	pop    %r13
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  407b06:	31 c0                	xor    %eax,%eax
    node_t* ex = TX_INSERT(r, key, val, node);
    if (ex != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  407b08:	41 5e                	pop    %r14
  407b0a:	c3                   	retq   
  407b0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        } else { /* cmp > 0 */
            node_t* tr = TX_LDNODE(t, r);
            if (tr != NULL) {
                t = tr;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
  407b10:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  407b17:	00 
                TX_STF_P(n, r, (node_t*)NULL);
  407b18:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  407b1f:	00 
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
                TX_STF_P(t, r, n);
                TX_FIX_AFTER_INSERTION(s, n);
  407b20:	4c 89 ee             	mov    %r13,%rsi
            if (tr != NULL) {
                t = tr;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
  407b23:	4d 89 65 00          	mov    %r12,0x0(%r13)
                TX_STF(n, v, v);
  407b27:	4d 89 75 08          	mov    %r14,0x8(%r13)
                TX_STF_P(n, p, t);
                TX_STF_P(t, r, n);
                TX_FIX_AFTER_INSERTION(s, n);
  407b2b:	48 89 ef             	mov    %rbp,%rdi
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
  407b2e:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                TX_STF_P(t, r, n);
  407b32:	4c 89 6b 20          	mov    %r13,0x20(%rbx)
                TX_FIX_AFTER_INSERTION(s, n);
  407b36:	e8 25 e7 ff ff       	callq  406260 <TMfixAfterInsertion>
    node_t* ex = TX_INSERT(r, key, val, node);
    if (ex != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  407b3b:	5b                   	pop    %rbx
  407b3c:	5d                   	pop    %rbp
  407b3d:	41 5c                	pop    %r12
  407b3f:	41 5d                	pop    %r13
 * -- Returns TRUE on success
 * =============================================================================
 */
bool_t
TMrbtree_insert (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407b41:	b8 01 00 00 00       	mov    $0x1,%eax
    node_t* ex = TX_INSERT(r, key, val, node);
    if (ex != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((ex == NULL) ? TRUE : FALSE);
}
  407b46:	41 5e                	pop    %r14
  407b48:	c3                   	retq   
static node_t*
TMinsert (TM_ARGDECL  rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = TX_LDNODE(s, root);
    if (t == NULL) {
        if (n == NULL) {
  407b49:	48 85 c0             	test   %rax,%rax
  407b4c:	74 ed                	je     407b3b <TMrbtree_insert+0xcb>
            return NULL;
        }
        /* Note: the following STs don't really need to be transactional */
        TX_STF_P(n, l, (node_t*)NULL);
  407b4e:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  407b55:	00 
        TX_STF_P(n, r, (node_t*)NULL);
  407b56:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  407b5d:	00 
        TX_STF_P(n, p, (node_t*)NULL);
  407b5e:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  407b65:	00 
        TX_STF(n, k, k);
  407b66:	4c 89 20             	mov    %r12,(%rax)
        TX_STF(n, v, v);
  407b69:	4c 89 70 08          	mov    %r14,0x8(%rax)
        TX_STF(n, c, BLACK);
  407b6d:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  407b74:	00 
        TX_STF_P(s, root, n);
  407b75:	48 89 45 00          	mov    %rax,0x0(%rbp)
  407b79:	eb c0                	jmp    407b3b <TMrbtree_insert+0xcb>
  407b7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000407b80 <rbtree_delete>:
 * -- Returns TRUE if key exists
 * =============================================================================
 */
bool_t
rbtree_delete (rbtree_t* r, void* key)
{
  407b80:	41 54                	push   %r12
  407b82:	49 89 f4             	mov    %rsi,%r12
  407b85:	55                   	push   %rbp
  407b86:	48 89 fd             	mov    %rdi,%rbp
  407b89:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);
  407b8a:	48 8b 1f             	mov    (%rdi),%rbx

    while (p != NULL) {
  407b8d:	48 85 db             	test   %rbx,%rbx
  407b90:	75 23                	jne    407bb5 <rbtree_delete+0x35>
  407b92:	e9 b1 00 00 00       	jmpq   407c48 <rbtree_delete+0xc8>
  407b97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  407b9e:	00 00 
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? LDNODE(p, l) : LDNODE(p, r));
  407ba0:	48 8b 43 18          	mov    0x18(%rbx),%rax
  407ba4:	48 0f 49 43 20       	cmovns 0x20(%rbx),%rax
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
  407ba9:	48 85 c0             	test   %rax,%rax
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? LDNODE(p, l) : LDNODE(p, r));
  407bac:	48 89 c3             	mov    %rax,%rbx
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
  407baf:	0f 84 93 00 00 00    	je     407c48 <rbtree_delete+0xc8>
        long cmp = s->compare(k, LDF(p, k));
  407bb5:	48 8b 33             	mov    (%rbx),%rsi
  407bb8:	4c 89 e7             	mov    %r12,%rdi
  407bbb:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  407bbe:	48 85 c0             	test   %rax,%rax
  407bc1:	75 dd                	jne    407ba0 <rbtree_delete+0x20>
{
    /*
     * If strictly internal, copy successor's element to p and then make p
     * point to successor
     */
    if (LDNODE(p, l) != NULL && LDNODE(p, r) != NULL) {
  407bc3:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  407bc7:	49 89 dc             	mov    %rbx,%r12
  407bca:	48 85 f6             	test   %rsi,%rsi
  407bcd:	74 2e                	je     407bfd <rbtree_delete+0x7d>
  407bcf:	4c 8b 63 20          	mov    0x20(%rbx),%r12
  407bd3:	4d 85 e4             	test   %r12,%r12
  407bd6:	75 0b                	jne    407be3 <rbtree_delete+0x63>
  407bd8:	eb 7e                	jmp    407c58 <rbtree_delete+0xd8>
  407bda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    if (t == NULL) {
        return NULL;
    } else if (LDNODE(t, r) != NULL) {
        node_t* p = LDNODE(t, r);
        while (LDNODE(p, l) != NULL) {
  407be0:	49 89 c4             	mov    %rax,%r12
  407be3:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  407be8:	48 85 c0             	test   %rax,%rax
  407beb:	75 f3                	jne    407be0 <rbtree_delete+0x60>
     * If strictly internal, copy successor's element to p and then make p
     * point to successor
     */
    if (LDNODE(p, l) != NULL && LDNODE(p, r) != NULL) {
        node_t* s = SUCCESSOR(p);
        STF(p, k, LDNODE(s, k));
  407bed:	49 8b 04 24          	mov    (%r12),%rax
  407bf1:	48 89 03             	mov    %rax,(%rbx)
        STF(p, v, LDNODE(s, v));
  407bf4:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  407bf9:	48 89 43 08          	mov    %rax,0x8(%rbx)
        p = s;
    } /* p has 2 children */

    /* Start fixup at replacement node, if it exists */
    node_t* replacement =
        ((LDNODE(p, l) != NULL) ? LDNODE(p, l) : LDNODE(p, r));
  407bfd:	49 8b 74 24 20       	mov    0x20(%r12),%rsi

    if (replacement != NULL) {
  407c02:	48 85 f6             	test   %rsi,%rsi
  407c05:	75 48                	jne    407c4f <rbtree_delete+0xcf>

        /* Fix replacement */
        if (LDF(p,c) == BLACK) {
            FIX_AFTER_DELETION(s, replacement);
        }
    } else if (LDNODE(p, p) == NULL) { /* return if we are the only node */
  407c07:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  407c0c:	48 85 c0             	test   %rax,%rax
  407c0f:	0f 84 a5 00 00 00    	je     407cba <rbtree_delete+0x13a>
        STF(s, root, NULL);
    } else { /* No children. Use self as phantom replacement and unlink */
        if (LDF(p, c) == BLACK) {
  407c15:	49 83 7c 24 28 01    	cmpq   $0x1,0x28(%r12)
  407c1b:	0f 84 b3 00 00 00    	je     407cd4 <rbtree_delete+0x154>
            FIX_AFTER_DELETION(s, p);
        }
        node_t* pp = LDNODE(p, p);
        if (pp != NULL) {
            if (p == LDNODE(pp, l)) {
  407c21:	4c 3b 60 18          	cmp    0x18(%rax),%r12
  407c25:	0f 84 9c 00 00 00    	je     407cc7 <rbtree_delete+0x147>
                STF(pp,l, NULL);
            } else if (p == LDNODE(pp, r)) {
  407c2b:	4c 3b 60 20          	cmp    0x20(%rax),%r12
  407c2f:	0f 84 bc 00 00 00    	je     407cf1 <rbtree_delete+0x171>
                STF(pp, r, NULL);
            }
            STF(p, p, NULL);
  407c35:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
  407c3c:	00 00 
  407c3e:	4c 89 e3             	mov    %r12,%rbx
  407c41:	eb 4f                	jmp    407c92 <rbtree_delete+0x112>
  407c43:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    }
    if (node != NULL) {
        releaseNode(node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407c48:	5b                   	pop    %rbx
  407c49:	5d                   	pop    %rbp
            if (p == LDNODE(pp, l)) {
                STF(pp,l, NULL);
            } else if (p == LDNODE(pp, r)) {
                STF(pp, r, NULL);
            }
            STF(p, p, NULL);
  407c4a:	31 c0                	xor    %eax,%eax
    }
    if (node != NULL) {
        releaseNode(node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407c4c:	41 5c                	pop    %r12
  407c4e:	c3                   	retq   

    /* Start fixup at replacement node, if it exists */
    node_t* replacement =
        ((LDNODE(p, l) != NULL) ? LDNODE(p, l) : LDNODE(p, r));

    if (replacement != NULL) {
  407c4f:	4c 89 e3             	mov    %r12,%rbx
  407c52:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        /* Link replacement to parent */
        /* TODO: precompute pp = p->p and substitute below ... */
        STF (replacement, p, LDNODE(p, p));
  407c58:	48 8b 43 10          	mov    0x10(%rbx),%rax
  407c5c:	48 89 46 10          	mov    %rax,0x10(%rsi)
        node_t* pp = LDNODE(p, p);
  407c60:	48 8b 43 10          	mov    0x10(%rbx),%rax
        if (pp == NULL) {
  407c64:	48 85 c0             	test   %rax,%rax
  407c67:	74 3b                	je     407ca4 <rbtree_delete+0x124>
            STF(s, root, replacement);
        } else if (p == LDNODE(pp, l)) {
  407c69:	48 3b 58 18          	cmp    0x18(%rax),%rbx
  407c6d:	74 45                	je     407cb4 <rbtree_delete+0x134>
            STF(pp, l, replacement);
        } else {
            STF(pp, r, replacement);
  407c6f:	48 89 70 20          	mov    %rsi,0x20(%rax)
        STF(p, l, NULL);
        STF(p, r, NULL);
        STF(p, p, NULL);

        /* Fix replacement */
        if (LDF(p,c) == BLACK) {
  407c73:	48 83 7b 28 01       	cmpq   $0x1,0x28(%rbx)
        } else {
            STF(pp, r, replacement);
        }

        /* Null out links so they are OK to use by fixAfterDeletion */
        STF(p, l, NULL);
  407c78:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  407c7f:	00 
        STF(p, r, NULL);
  407c80:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  407c87:	00 
        STF(p, p, NULL);
  407c88:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  407c8f:	00 

        /* Fix replacement */
        if (LDF(p,c) == BLACK) {
  407c90:	74 18                	je     407caa <rbtree_delete+0x12a>
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  407c92:	48 89 df             	mov    %rbx,%rdi
  407c95:	e8 16 90 ff ff       	callq  400cb0 <free@plt>
    }
    if (node != NULL) {
        releaseNode(node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407c9a:	5b                   	pop    %rbx
  407c9b:	5d                   	pop    %rbp
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  407c9c:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    if (node != NULL) {
        releaseNode(node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407ca1:	41 5c                	pop    %r12
  407ca3:	c3                   	retq   
        /* Link replacement to parent */
        /* TODO: precompute pp = p->p and substitute below ... */
        STF (replacement, p, LDNODE(p, p));
        node_t* pp = LDNODE(p, p);
        if (pp == NULL) {
            STF(s, root, replacement);
  407ca4:	48 89 75 00          	mov    %rsi,0x0(%rbp)
  407ca8:	eb c9                	jmp    407c73 <rbtree_delete+0xf3>
        STF(p, r, NULL);
        STF(p, p, NULL);

        /* Fix replacement */
        if (LDF(p,c) == BLACK) {
            FIX_AFTER_DELETION(s, replacement);
  407caa:	48 89 ef             	mov    %rbp,%rdi
  407cad:	e8 ee ec ff ff       	callq  4069a0 <fixAfterDeletion>
  407cb2:	eb de                	jmp    407c92 <rbtree_delete+0x112>
        STF (replacement, p, LDNODE(p, p));
        node_t* pp = LDNODE(p, p);
        if (pp == NULL) {
            STF(s, root, replacement);
        } else if (p == LDNODE(pp, l)) {
            STF(pp, l, replacement);
  407cb4:	48 89 70 18          	mov    %rsi,0x18(%rax)
  407cb8:	eb b9                	jmp    407c73 <rbtree_delete+0xf3>
        /* Fix replacement */
        if (LDF(p,c) == BLACK) {
            FIX_AFTER_DELETION(s, replacement);
        }
    } else if (LDNODE(p, p) == NULL) { /* return if we are the only node */
        STF(s, root, NULL);
  407cba:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
  407cc1:	00 
  407cc2:	4c 89 e3             	mov    %r12,%rbx
  407cc5:	eb cb                	jmp    407c92 <rbtree_delete+0x112>
            FIX_AFTER_DELETION(s, p);
        }
        node_t* pp = LDNODE(p, p);
        if (pp != NULL) {
            if (p == LDNODE(pp, l)) {
                STF(pp,l, NULL);
  407cc7:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  407cce:	00 
  407ccf:	e9 61 ff ff ff       	jmpq   407c35 <rbtree_delete+0xb5>
        }
    } else if (LDNODE(p, p) == NULL) { /* return if we are the only node */
        STF(s, root, NULL);
    } else { /* No children. Use self as phantom replacement and unlink */
        if (LDF(p, c) == BLACK) {
            FIX_AFTER_DELETION(s, p);
  407cd4:	4c 89 e6             	mov    %r12,%rsi
  407cd7:	48 89 ef             	mov    %rbp,%rdi
        }
        node_t* pp = LDNODE(p, p);
        if (pp != NULL) {
  407cda:	4c 89 e3             	mov    %r12,%rbx
        }
    } else if (LDNODE(p, p) == NULL) { /* return if we are the only node */
        STF(s, root, NULL);
    } else { /* No children. Use self as phantom replacement and unlink */
        if (LDF(p, c) == BLACK) {
            FIX_AFTER_DELETION(s, p);
  407cdd:	e8 be ec ff ff       	callq  4069a0 <fixAfterDeletion>
        }
        node_t* pp = LDNODE(p, p);
  407ce2:	49 8b 44 24 10       	mov    0x10(%r12),%rax
        if (pp != NULL) {
  407ce7:	48 85 c0             	test   %rax,%rax
  407cea:	74 a6                	je     407c92 <rbtree_delete+0x112>
  407cec:	e9 30 ff ff ff       	jmpq   407c21 <rbtree_delete+0xa1>
            if (p == LDNODE(pp, l)) {
                STF(pp,l, NULL);
            } else if (p == LDNODE(pp, r)) {
                STF(pp, r, NULL);
  407cf1:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  407cf8:	00 
  407cf9:	e9 37 ff ff ff       	jmpq   407c35 <rbtree_delete+0xb5>
  407cfe:	66 90                	xchg   %ax,%ax

0000000000407d00 <TMrbtree_delete>:
 * -- Returns TRUE if key exists
 * =============================================================================
 */
bool_t
TMrbtree_delete (TM_ARGDECL  rbtree_t* r, void* key)
{
  407d00:	41 54                	push   %r12
  407d02:	49 89 f4             	mov    %rsi,%r12
  407d05:	55                   	push   %rbp
  407d06:	48 89 fd             	mov    %rdi,%rbp
  407d09:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);
  407d0a:	48 8b 1f             	mov    (%rdi),%rbx

    while (p != NULL) {
  407d0d:	48 85 db             	test   %rbx,%rbx
  407d10:	75 23                	jne    407d35 <TMrbtree_delete+0x35>
  407d12:	e9 b1 00 00 00       	jmpq   407dc8 <TMrbtree_delete+0xc8>
  407d17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  407d1e:	00 00 
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  407d20:	48 8b 43 18          	mov    0x18(%rbx),%rax
  407d24:	48 0f 49 43 20       	cmovns 0x20(%rbx),%rax
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
  407d29:	48 85 c0             	test   %rax,%rax
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  407d2c:	48 89 c3             	mov    %rax,%rbx
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
  407d2f:	0f 84 93 00 00 00    	je     407dc8 <TMrbtree_delete+0xc8>
        long cmp = s->compare(k, TX_LDF_P(p, k));
  407d35:	48 8b 33             	mov    (%rbx),%rsi
  407d38:	4c 89 e7             	mov    %r12,%rdi
  407d3b:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  407d3e:	48 85 c0             	test   %rax,%rax
  407d41:	75 dd                	jne    407d20 <TMrbtree_delete+0x20>
{
    /*
     * If strictly internal, copy successor's element to p and then make p
     * point to successor
     */
    if (TX_LDNODE(p, l) != NULL && TX_LDNODE(p, r) != NULL) {
  407d43:	48 8b 73 18          	mov    0x18(%rbx),%rsi
  407d47:	49 89 dc             	mov    %rbx,%r12
  407d4a:	48 85 f6             	test   %rsi,%rsi
  407d4d:	74 2e                	je     407d7d <TMrbtree_delete+0x7d>
  407d4f:	4c 8b 63 20          	mov    0x20(%rbx),%r12
  407d53:	4d 85 e4             	test   %r12,%r12
  407d56:	75 0b                	jne    407d63 <TMrbtree_delete+0x63>
  407d58:	eb 78                	jmp    407dd2 <TMrbtree_delete+0xd2>
  407d5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    if (t == NULL) {
        return NULL;
    } else if (TX_LDNODE(t, r) != NULL) {
        node_t* p = TX_LDNODE(t,r);
        while (TX_LDNODE(p, l) != NULL) {
  407d60:	49 89 c4             	mov    %rax,%r12
  407d63:	49 8b 44 24 18       	mov    0x18(%r12),%rax
  407d68:	48 85 c0             	test   %rax,%rax
  407d6b:	75 f3                	jne    407d60 <TMrbtree_delete+0x60>
     * If strictly internal, copy successor's element to p and then make p
     * point to successor
     */
    if (TX_LDNODE(p, l) != NULL && TX_LDNODE(p, r) != NULL) {
        node_t* s = TX_SUCCESSOR(p);
        TX_STF(p,k, TX_LDF_P(s, k));
  407d6d:	49 8b 04 24          	mov    (%r12),%rax
  407d71:	48 89 03             	mov    %rax,(%rbx)
        TX_STF(p,v, TX_LDF_P(s, v));
  407d74:	49 8b 44 24 08       	mov    0x8(%r12),%rax
  407d79:	48 89 43 08          	mov    %rax,0x8(%rbx)
        p = s;
    } /* p has 2 children */

    /* Start fixup at replacement node, if it exists */
    node_t* replacement =
        ((TX_LDNODE(p, l) != NULL) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  407d7d:	49 8b 74 24 20       	mov    0x20(%r12),%rsi

    if (replacement != NULL) {
  407d82:	48 85 f6             	test   %rsi,%rsi
  407d85:	75 48                	jne    407dcf <TMrbtree_delete+0xcf>

        /* Fix replacement */
        if (TX_LDF(p,c) == BLACK) {
            TX_FIX_AFTER_DELETION(s, replacement);
        }
    } else if (TX_LDNODE(p,p) == NULL) { /* return if we are the only node */
  407d87:	49 8b 44 24 10       	mov    0x10(%r12),%rax
  407d8c:	48 85 c0             	test   %rax,%rax
  407d8f:	0f 84 9f 00 00 00    	je     407e34 <TMrbtree_delete+0x134>
        TX_STF_P(s, root, (node_t*)NULL);
    } else { /* No children. Use self as phantom replacement and unlink */
        if (TX_LDF(p,c) == BLACK) {
  407d95:	49 83 7c 24 28 01    	cmpq   $0x1,0x28(%r12)
  407d9b:	0f 84 ad 00 00 00    	je     407e4e <TMrbtree_delete+0x14e>
            TX_FIX_AFTER_DELETION(s, p);
        }
        node_t* pp = TX_LDNODE(p, p);
        if (pp != NULL) {
            if (p == TX_LDNODE(pp, l)) {
  407da1:	4c 3b 60 18          	cmp    0x18(%rax),%r12
  407da5:	0f 84 96 00 00 00    	je     407e41 <TMrbtree_delete+0x141>
                TX_STF_P(pp,l, (node_t*)NULL);
            } else if (p == TX_LDNODE(pp, r)) {
  407dab:	4c 3b 60 20          	cmp    0x20(%rax),%r12
  407daf:	0f 84 b6 00 00 00    	je     407e6b <TMrbtree_delete+0x16b>
                TX_STF_P(pp, r, (node_t*)NULL);
            }
            TX_STF_P(p, p, (node_t*)NULL);
  407db5:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
  407dbc:	00 00 
  407dbe:	4c 89 e3             	mov    %r12,%rbx
  407dc1:	eb 49                	jmp    407e0c <TMrbtree_delete+0x10c>
  407dc3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    }
    if (node != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407dc8:	5b                   	pop    %rbx
  407dc9:	5d                   	pop    %rbp
            if (p == TX_LDNODE(pp, l)) {
                TX_STF_P(pp,l, (node_t*)NULL);
            } else if (p == TX_LDNODE(pp, r)) {
                TX_STF_P(pp, r, (node_t*)NULL);
            }
            TX_STF_P(p, p, (node_t*)NULL);
  407dca:	31 c0                	xor    %eax,%eax
    }
    if (node != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407dcc:	41 5c                	pop    %r12
  407dce:	c3                   	retq   

    /* Start fixup at replacement node, if it exists */
    node_t* replacement =
        ((TX_LDNODE(p, l) != NULL) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));

    if (replacement != NULL) {
  407dcf:	4c 89 e3             	mov    %r12,%rbx
        /* Link replacement to parent */
        /* TODO: precompute pp = p->p and substitute below ... */
        TX_STF_P(replacement, p, TX_LDNODE(p, p));
  407dd2:	48 8b 43 10          	mov    0x10(%rbx),%rax
  407dd6:	48 89 46 10          	mov    %rax,0x10(%rsi)
        node_t* pp = TX_LDNODE(p, p);
  407dda:	48 8b 43 10          	mov    0x10(%rbx),%rax
        if (pp == NULL) {
  407dde:	48 85 c0             	test   %rax,%rax
  407de1:	74 3b                	je     407e1e <TMrbtree_delete+0x11e>
            TX_STF_P(s, root, replacement);
        } else if (p == TX_LDNODE(pp, l)) {
  407de3:	48 3b 58 18          	cmp    0x18(%rax),%rbx
  407de7:	74 45                	je     407e2e <TMrbtree_delete+0x12e>
            TX_STF_P(pp, l, replacement);
        } else {
            TX_STF_P(pp, r, replacement);
  407de9:	48 89 70 20          	mov    %rsi,0x20(%rax)
        TX_STF_P(p, l, (node_t*)NULL);
        TX_STF_P(p, r, (node_t*)NULL);
        TX_STF_P(p, p, (node_t*)NULL);

        /* Fix replacement */
        if (TX_LDF(p,c) == BLACK) {
  407ded:	48 83 7b 28 01       	cmpq   $0x1,0x28(%rbx)
        } else {
            TX_STF_P(pp, r, replacement);
        }

        /* Null out links so they are OK to use by fixAfterDeletion */
        TX_STF_P(p, l, (node_t*)NULL);
  407df2:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
  407df9:	00 
        TX_STF_P(p, r, (node_t*)NULL);
  407dfa:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
  407e01:	00 
        TX_STF_P(p, p, (node_t*)NULL);
  407e02:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
  407e09:	00 

        /* Fix replacement */
        if (TX_LDF(p,c) == BLACK) {
  407e0a:	74 18                	je     407e24 <TMrbtree_delete+0x124>
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  407e0c:	48 89 df             	mov    %rbx,%rdi
  407e0f:	e8 9c 8e ff ff       	callq  400cb0 <free@plt>
    }
    if (node != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407e14:	5b                   	pop    %rbx
  407e15:	5d                   	pop    %rbp
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  407e16:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    if (node != NULL) {
        TMreleaseNode(TM_ARG  node);
    }
    return ((node != NULL) ? TRUE : FALSE);
}
  407e1b:	41 5c                	pop    %r12
  407e1d:	c3                   	retq   
        /* Link replacement to parent */
        /* TODO: precompute pp = p->p and substitute below ... */
        TX_STF_P(replacement, p, TX_LDNODE(p, p));
        node_t* pp = TX_LDNODE(p, p);
        if (pp == NULL) {
            TX_STF_P(s, root, replacement);
  407e1e:	48 89 75 00          	mov    %rsi,0x0(%rbp)
  407e22:	eb c9                	jmp    407ded <TMrbtree_delete+0xed>
        TX_STF_P(p, r, (node_t*)NULL);
        TX_STF_P(p, p, (node_t*)NULL);

        /* Fix replacement */
        if (TX_LDF(p,c) == BLACK) {
            TX_FIX_AFTER_DELETION(s, replacement);
  407e24:	48 89 ef             	mov    %rbp,%rdi
  407e27:	e8 f4 e6 ff ff       	callq  406520 <TMfixAfterDeletion>
  407e2c:	eb de                	jmp    407e0c <TMrbtree_delete+0x10c>
        TX_STF_P(replacement, p, TX_LDNODE(p, p));
        node_t* pp = TX_LDNODE(p, p);
        if (pp == NULL) {
            TX_STF_P(s, root, replacement);
        } else if (p == TX_LDNODE(pp, l)) {
            TX_STF_P(pp, l, replacement);
  407e2e:	48 89 70 18          	mov    %rsi,0x18(%rax)
  407e32:	eb b9                	jmp    407ded <TMrbtree_delete+0xed>
        /* Fix replacement */
        if (TX_LDF(p,c) == BLACK) {
            TX_FIX_AFTER_DELETION(s, replacement);
        }
    } else if (TX_LDNODE(p,p) == NULL) { /* return if we are the only node */
        TX_STF_P(s, root, (node_t*)NULL);
  407e34:	48 c7 45 00 00 00 00 	movq   $0x0,0x0(%rbp)
  407e3b:	00 
  407e3c:	4c 89 e3             	mov    %r12,%rbx
  407e3f:	eb cb                	jmp    407e0c <TMrbtree_delete+0x10c>
            TX_FIX_AFTER_DELETION(s, p);
        }
        node_t* pp = TX_LDNODE(p, p);
        if (pp != NULL) {
            if (p == TX_LDNODE(pp, l)) {
                TX_STF_P(pp,l, (node_t*)NULL);
  407e41:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  407e48:	00 
  407e49:	e9 67 ff ff ff       	jmpq   407db5 <TMrbtree_delete+0xb5>
        }
    } else if (TX_LDNODE(p,p) == NULL) { /* return if we are the only node */
        TX_STF_P(s, root, (node_t*)NULL);
    } else { /* No children. Use self as phantom replacement and unlink */
        if (TX_LDF(p,c) == BLACK) {
            TX_FIX_AFTER_DELETION(s, p);
  407e4e:	4c 89 e6             	mov    %r12,%rsi
  407e51:	48 89 ef             	mov    %rbp,%rdi
        }
        node_t* pp = TX_LDNODE(p, p);
        if (pp != NULL) {
  407e54:	4c 89 e3             	mov    %r12,%rbx
        }
    } else if (TX_LDNODE(p,p) == NULL) { /* return if we are the only node */
        TX_STF_P(s, root, (node_t*)NULL);
    } else { /* No children. Use self as phantom replacement and unlink */
        if (TX_LDF(p,c) == BLACK) {
            TX_FIX_AFTER_DELETION(s, p);
  407e57:	e8 c4 e6 ff ff       	callq  406520 <TMfixAfterDeletion>
        }
        node_t* pp = TX_LDNODE(p, p);
  407e5c:	49 8b 44 24 10       	mov    0x10(%r12),%rax
        if (pp != NULL) {
  407e61:	48 85 c0             	test   %rax,%rax
  407e64:	74 a6                	je     407e0c <TMrbtree_delete+0x10c>
  407e66:	e9 36 ff ff ff       	jmpq   407da1 <TMrbtree_delete+0xa1>
            if (p == TX_LDNODE(pp, l)) {
                TX_STF_P(pp,l, (node_t*)NULL);
            } else if (p == TX_LDNODE(pp, r)) {
                TX_STF_P(pp, r, (node_t*)NULL);
  407e6b:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  407e72:	00 
  407e73:	e9 3d ff ff ff       	jmpq   407db5 <TMrbtree_delete+0xb5>
  407e78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  407e7f:	00 

0000000000407e80 <rbtree_update>:
 * -- Return FALSE if had to insert node first
 * =============================================================================
 */
bool_t
rbtree_update (rbtree_t* r, void* key, void* val)
{
  407e80:	41 56                	push   %r14
  407e82:	49 89 d6             	mov    %rdx,%r14
  407e85:	41 55                	push   %r13
  407e87:	41 54                	push   %r12
  407e89:	49 89 f4             	mov    %rsi,%r12
  407e8c:	55                   	push   %rbp
  407e8d:	48 89 fd             	mov    %rdi,%rbp
 * =============================================================================
 */
static node_t*
getNode ()
{
    node_t* n = (node_t*)malloc(sizeof(*n));
  407e90:	bf 30 00 00 00       	mov    $0x30,%edi
 * -- Return FALSE if had to insert node first
 * =============================================================================
 */
bool_t
rbtree_update (rbtree_t* r, void* key, void* val)
{
  407e95:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
getNode ()
{
    node_t* n = (node_t*)malloc(sizeof(*n));
  407e96:	e8 e5 8d ff ff       	callq  400c80 <malloc@plt>
 * =============================================================================
 */
static node_t*
insert (rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = LDNODE(s, root);
  407e9b:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
 * =============================================================================
 */
static node_t*
getNode ()
{
    node_t* n = (node_t*)malloc(sizeof(*n));
  407e9f:	49 89 c5             	mov    %rax,%r13
 */
static node_t*
insert (rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = LDNODE(s, root);
    if (t == NULL) {
  407ea2:	48 85 db             	test   %rbx,%rbx
  407ea5:	75 15                	jne    407ebc <rbtree_update+0x3c>
  407ea7:	e9 b3 00 00 00       	jmpq   407f5f <rbtree_update+0xdf>
  407eac:	0f 1f 40 00          	nopl   0x0(%rax)
                STF(t, l, n);
                FIX_AFTER_INSERTION(s, n);
                return NULL;
            }
        } else { /* cmp > 0 */
            node_t* tr = LDNODE(t, r);
  407eb0:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
            if (tr != NULL) {
  407eb4:	48 85 c9             	test   %rcx,%rcx
  407eb7:	74 77                	je     407f30 <rbtree_update+0xb0>
 * -- Return FALSE if had to insert node first
 * =============================================================================
 */
bool_t
rbtree_update (rbtree_t* r, void* key, void* val)
{
  407eb9:	48 89 cb             	mov    %rcx,%rbx
        STF(s, root, n);
        return NULL;
    }

    for (;;) {
        long cmp = s->compare(k, LDF(t, k));
  407ebc:	48 8b 33             	mov    (%rbx),%rsi
  407ebf:	4c 89 e7             	mov    %r12,%rdi
  407ec2:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  407ec5:	48 85 c0             	test   %rax,%rax
  407ec8:	74 46                	je     407f10 <rbtree_update+0x90>
            return t;
        } else if (cmp < 0) {
  407eca:	79 e4                	jns    407eb0 <rbtree_update+0x30>
            node_t* tl = LDNODE(t, l);
  407ecc:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
            if (tl != NULL) {
  407ed0:	48 85 c9             	test   %rcx,%rcx
  407ed3:	75 e4                	jne    407eb9 <rbtree_update+0x39>
                t = tl;
            } else {
                STF(n, l, NULL);
  407ed5:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  407edc:	00 
                STF(n, r, NULL);
  407edd:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  407ee4:	00 
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
                STF(t, l, n);
                FIX_AFTER_INSERTION(s, n);
  407ee5:	4c 89 ee             	mov    %r13,%rsi
            if (tl != NULL) {
                t = tl;
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
  407ee8:	4d 89 65 00          	mov    %r12,0x0(%r13)
                STF(n, v, v);
  407eec:	4d 89 75 08          	mov    %r14,0x8(%r13)
                STF(n, p, t);
                STF(t, l, n);
                FIX_AFTER_INSERTION(s, n);
  407ef0:	48 89 ef             	mov    %rbp,%rdi
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
  407ef3:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                STF(t, l, n);
  407ef7:	4c 89 6b 18          	mov    %r13,0x18(%rbx)
                FIX_AFTER_INSERTION(s, n);
  407efb:	e8 a0 e0 ff ff       	callq  405fa0 <fixAfterInsertion>
    if (ex != NULL) {
        STF(ex, v, val);
        releaseNode(nn);
        return TRUE;
    }
    return FALSE;
  407f00:	31 c0                	xor    %eax,%eax
}
  407f02:	5b                   	pop    %rbx
  407f03:	5d                   	pop    %rbp
  407f04:	41 5c                	pop    %r12
  407f06:	41 5d                	pop    %r13
  407f08:	41 5e                	pop    %r14
  407f0a:	c3                   	retq   
  407f0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
rbtree_update (rbtree_t* r, void* key, void* val)
{
    node_t* nn = getNode();
    node_t* ex = INSERT(r, key, val, nn);
    if (ex != NULL) {
        STF(ex, v, val);
  407f10:	4c 89 73 08          	mov    %r14,0x8(%rbx)
 */
static void
releaseNode (node_t* n)
{
#ifndef SIMULATOR
    free(n);
  407f14:	4c 89 ef             	mov    %r13,%rdi
  407f17:	e8 94 8d ff ff       	callq  400cb0 <free@plt>
        STF(ex, v, val);
        releaseNode(nn);
        return TRUE;
    }
    return FALSE;
}
  407f1c:	5b                   	pop    %rbx
  407f1d:	5d                   	pop    %rbp
  407f1e:	41 5c                	pop    %r12
  407f20:	41 5d                	pop    %r13
    node_t* nn = getNode();
    node_t* ex = INSERT(r, key, val, nn);
    if (ex != NULL) {
        STF(ex, v, val);
        releaseNode(nn);
        return TRUE;
  407f22:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    return FALSE;
}
  407f27:	41 5e                	pop    %r14
  407f29:	c3                   	retq   
  407f2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        } else { /* cmp > 0 */
            node_t* tr = LDNODE(t, r);
            if (tr != NULL) {
                t = tr;
            } else {
                STF(n, l, NULL);
  407f30:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  407f37:	00 
                STF(n, r, NULL);
  407f38:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  407f3f:	00 
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
                STF(t, r, n);
                FIX_AFTER_INSERTION(s, n);
  407f40:	4c 89 ee             	mov    %r13,%rsi
            if (tr != NULL) {
                t = tr;
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
  407f43:	4d 89 65 00          	mov    %r12,0x0(%r13)
                STF(n, v, v);
  407f47:	4d 89 75 08          	mov    %r14,0x8(%r13)
                STF(n, p, t);
                STF(t, r, n);
                FIX_AFTER_INSERTION(s, n);
  407f4b:	48 89 ef             	mov    %rbp,%rdi
            } else {
                STF(n, l, NULL);
                STF(n, r, NULL);
                STF(n, k, k);
                STF(n, v, v);
                STF(n, p, t);
  407f4e:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                STF(t, r, n);
  407f52:	4c 89 6b 20          	mov    %r13,0x20(%rbx)
                FIX_AFTER_INSERTION(s, n);
  407f56:	e8 45 e0 ff ff       	callq  405fa0 <fixAfterInsertion>
    if (ex != NULL) {
        STF(ex, v, val);
        releaseNode(nn);
        return TRUE;
    }
    return FALSE;
  407f5b:	31 c0                	xor    %eax,%eax
  407f5d:	eb a3                	jmp    407f02 <rbtree_update+0x82>
static node_t*
insert (rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = LDNODE(s, root);
    if (t == NULL) {
        if (n == NULL) {
  407f5f:	48 85 c0             	test   %rax,%rax
  407f62:	74 9c                	je     407f00 <rbtree_update+0x80>
            return NULL;
        }
        /* Note: the following STs don't really need to be transactional */
        STF(n, l, NULL);
  407f64:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  407f6b:	00 
        STF(n, r, NULL);
  407f6c:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  407f73:	00 
        STF(n, p, NULL);
  407f74:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  407f7b:	00 
        STF(n, k, k);
  407f7c:	4c 89 20             	mov    %r12,(%rax)
        STF(n, v, v);
  407f7f:	4c 89 70 08          	mov    %r14,0x8(%rax)
        STF(n, c, BLACK);
  407f83:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  407f8a:	00 
        STF(s, root, n);
  407f8b:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (ex != NULL) {
        STF(ex, v, val);
        releaseNode(nn);
        return TRUE;
    }
    return FALSE;
  407f8f:	31 c0                	xor    %eax,%eax
  407f91:	e9 6c ff ff ff       	jmpq   407f02 <rbtree_update+0x82>
  407f96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  407f9d:	00 00 00 

0000000000407fa0 <TMrbtree_update>:
 * -- Return FALSE if had to insert node first
 * =============================================================================
 */
bool_t
TMrbtree_update (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407fa0:	41 56                	push   %r14
  407fa2:	49 89 d6             	mov    %rdx,%r14
  407fa5:	41 55                	push   %r13
  407fa7:	41 54                	push   %r12
  407fa9:	49 89 f4             	mov    %rsi,%r12
  407fac:	55                   	push   %rbp
  407fad:	48 89 fd             	mov    %rdi,%rbp
 * =============================================================================
 */
static node_t*
TMgetNode (TM_ARGDECL_ALONE)
{
    node_t* n = (node_t*)TM_MALLOC(sizeof(*n));
  407fb0:	bf 30 00 00 00       	mov    $0x30,%edi
 * -- Return FALSE if had to insert node first
 * =============================================================================
 */
bool_t
TMrbtree_update (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407fb5:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
TMgetNode (TM_ARGDECL_ALONE)
{
    node_t* n = (node_t*)TM_MALLOC(sizeof(*n));
  407fb6:	e8 c5 8c ff ff       	callq  400c80 <malloc@plt>
 * =============================================================================
 */
static node_t*
TMinsert (TM_ARGDECL  rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = TX_LDNODE(s, root);
  407fbb:	48 8b 5d 00          	mov    0x0(%rbp),%rbx
 * =============================================================================
 */
static node_t*
TMgetNode (TM_ARGDECL_ALONE)
{
    node_t* n = (node_t*)TM_MALLOC(sizeof(*n));
  407fbf:	49 89 c5             	mov    %rax,%r13
 */
static node_t*
TMinsert (TM_ARGDECL  rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = TX_LDNODE(s, root);
    if (t == NULL) {
  407fc2:	48 85 db             	test   %rbx,%rbx
  407fc5:	75 15                	jne    407fdc <TMrbtree_update+0x3c>
  407fc7:	e9 b3 00 00 00       	jmpq   40807f <TMrbtree_update+0xdf>
  407fcc:	0f 1f 40 00          	nopl   0x0(%rax)
                TX_STF_P(t, l, n);
                TX_FIX_AFTER_INSERTION(s, n);
                return NULL;
            }
        } else { /* cmp > 0 */
            node_t* tr = TX_LDNODE(t, r);
  407fd0:	48 8b 4b 20          	mov    0x20(%rbx),%rcx
            if (tr != NULL) {
  407fd4:	48 85 c9             	test   %rcx,%rcx
  407fd7:	74 77                	je     408050 <TMrbtree_update+0xb0>
 * -- Return FALSE if had to insert node first
 * =============================================================================
 */
bool_t
TMrbtree_update (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
  407fd9:	48 89 cb             	mov    %rcx,%rbx
        TX_STF_P(s, root, n);
        return NULL;
    }

    for (;;) {
        long cmp = s->compare(k, TX_LDF_P(t, k));
  407fdc:	48 8b 33             	mov    (%rbx),%rsi
  407fdf:	4c 89 e7             	mov    %r12,%rdi
  407fe2:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  407fe5:	48 85 c0             	test   %rax,%rax
  407fe8:	74 46                	je     408030 <TMrbtree_update+0x90>
            return t;
        } else if (cmp < 0) {
  407fea:	79 e4                	jns    407fd0 <TMrbtree_update+0x30>
            node_t* tl = TX_LDNODE(t, l);
  407fec:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
            if (tl != NULL) {
  407ff0:	48 85 c9             	test   %rcx,%rcx
  407ff3:	75 e4                	jne    407fd9 <TMrbtree_update+0x39>
                t = tl;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
  407ff5:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  407ffc:	00 
                TX_STF_P(n, r, (node_t*)NULL);
  407ffd:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  408004:	00 
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
                TX_STF_P(t, l, n);
                TX_FIX_AFTER_INSERTION(s, n);
  408005:	4c 89 ee             	mov    %r13,%rsi
            if (tl != NULL) {
                t = tl;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
  408008:	4d 89 65 00          	mov    %r12,0x0(%r13)
                TX_STF(n, v, v);
  40800c:	4d 89 75 08          	mov    %r14,0x8(%r13)
                TX_STF_P(n, p, t);
                TX_STF_P(t, l, n);
                TX_FIX_AFTER_INSERTION(s, n);
  408010:	48 89 ef             	mov    %rbp,%rdi
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
  408013:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                TX_STF_P(t, l, n);
  408017:	4c 89 6b 18          	mov    %r13,0x18(%rbx)
                TX_FIX_AFTER_INSERTION(s, n);
  40801b:	e8 40 e2 ff ff       	callq  406260 <TMfixAfterInsertion>
    if (ex != NULL) {
        TX_STF(ex, v, val);
        TMreleaseNode(TM_ARG  nn);
        return TRUE;
    }
    return FALSE;
  408020:	31 c0                	xor    %eax,%eax
}
  408022:	5b                   	pop    %rbx
  408023:	5d                   	pop    %rbp
  408024:	41 5c                	pop    %r12
  408026:	41 5d                	pop    %r13
  408028:	41 5e                	pop    %r14
  40802a:	c3                   	retq   
  40802b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
TMrbtree_update (TM_ARGDECL  rbtree_t* r, void* key, void* val)
{
    node_t* nn = TMgetNode(TM_ARG_ALONE);
    node_t* ex = TX_INSERT(r, key, val, nn);
    if (ex != NULL) {
        TX_STF(ex, v, val);
  408030:	4c 89 73 08          	mov    %r14,0x8(%rbx)
 * =============================================================================
 */
static void
TMreleaseNode  (TM_ARGDECL  node_t* n)
{
    TM_FREE(n);
  408034:	4c 89 ef             	mov    %r13,%rdi
  408037:	e8 74 8c ff ff       	callq  400cb0 <free@plt>
        TX_STF(ex, v, val);
        TMreleaseNode(TM_ARG  nn);
        return TRUE;
    }
    return FALSE;
}
  40803c:	5b                   	pop    %rbx
  40803d:	5d                   	pop    %rbp
  40803e:	41 5c                	pop    %r12
  408040:	41 5d                	pop    %r13
    node_t* nn = TMgetNode(TM_ARG_ALONE);
    node_t* ex = TX_INSERT(r, key, val, nn);
    if (ex != NULL) {
        TX_STF(ex, v, val);
        TMreleaseNode(TM_ARG  nn);
        return TRUE;
  408042:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    return FALSE;
}
  408047:	41 5e                	pop    %r14
  408049:	c3                   	retq   
  40804a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        } else { /* cmp > 0 */
            node_t* tr = TX_LDNODE(t, r);
            if (tr != NULL) {
                t = tr;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
  408050:	49 c7 45 18 00 00 00 	movq   $0x0,0x18(%r13)
  408057:	00 
                TX_STF_P(n, r, (node_t*)NULL);
  408058:	49 c7 45 20 00 00 00 	movq   $0x0,0x20(%r13)
  40805f:	00 
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
                TX_STF_P(t, r, n);
                TX_FIX_AFTER_INSERTION(s, n);
  408060:	4c 89 ee             	mov    %r13,%rsi
            if (tr != NULL) {
                t = tr;
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
  408063:	4d 89 65 00          	mov    %r12,0x0(%r13)
                TX_STF(n, v, v);
  408067:	4d 89 75 08          	mov    %r14,0x8(%r13)
                TX_STF_P(n, p, t);
                TX_STF_P(t, r, n);
                TX_FIX_AFTER_INSERTION(s, n);
  40806b:	48 89 ef             	mov    %rbp,%rdi
            } else {
                TX_STF_P(n, l, (node_t*)NULL);
                TX_STF_P(n, r, (node_t*)NULL);
                TX_STF(n, k, k);
                TX_STF(n, v, v);
                TX_STF_P(n, p, t);
  40806e:	49 89 5d 10          	mov    %rbx,0x10(%r13)
                TX_STF_P(t, r, n);
  408072:	4c 89 6b 20          	mov    %r13,0x20(%rbx)
                TX_FIX_AFTER_INSERTION(s, n);
  408076:	e8 e5 e1 ff ff       	callq  406260 <TMfixAfterInsertion>
    if (ex != NULL) {
        TX_STF(ex, v, val);
        TMreleaseNode(TM_ARG  nn);
        return TRUE;
    }
    return FALSE;
  40807b:	31 c0                	xor    %eax,%eax
  40807d:	eb a3                	jmp    408022 <TMrbtree_update+0x82>
static node_t*
TMinsert (TM_ARGDECL  rbtree_t* s, void* k, void* v, node_t* n)
{
    node_t* t  = TX_LDNODE(s, root);
    if (t == NULL) {
        if (n == NULL) {
  40807f:	48 85 c0             	test   %rax,%rax
  408082:	74 9c                	je     408020 <TMrbtree_update+0x80>
            return NULL;
        }
        /* Note: the following STs don't really need to be transactional */
        TX_STF_P(n, l, (node_t*)NULL);
  408084:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  40808b:	00 
        TX_STF_P(n, r, (node_t*)NULL);
  40808c:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  408093:	00 
        TX_STF_P(n, p, (node_t*)NULL);
  408094:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  40809b:	00 
        TX_STF(n, k, k);
  40809c:	4c 89 20             	mov    %r12,(%rax)
        TX_STF(n, v, v);
  40809f:	4c 89 70 08          	mov    %r14,0x8(%rax)
        TX_STF(n, c, BLACK);
  4080a3:	48 c7 40 28 01 00 00 	movq   $0x1,0x28(%rax)
  4080aa:	00 
        TX_STF_P(s, root, n);
  4080ab:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (ex != NULL) {
        TX_STF(ex, v, val);
        TMreleaseNode(TM_ARG  nn);
        return TRUE;
    }
    return FALSE;
  4080af:	31 c0                	xor    %eax,%eax
  4080b1:	e9 6c ff ff ff       	jmpq   408022 <TMrbtree_update+0x82>
  4080b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  4080bd:	00 00 00 

00000000004080c0 <rbtree_get>:
/* =============================================================================
 * rbtree_get
 * =============================================================================
 */
void*
rbtree_get (rbtree_t* r, void* key) {
  4080c0:	41 54                	push   %r12
  4080c2:	49 89 f4             	mov    %rsi,%r12
  4080c5:	55                   	push   %rbp
  4080c6:	48 89 fd             	mov    %rdi,%rbp
  4080c9:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);
  4080ca:	48 8b 1f             	mov    (%rdi),%rbx

    while (p != NULL) {
  4080cd:	48 85 db             	test   %rbx,%rbx
  4080d0:	75 17                	jne    4080e9 <rbtree_get+0x29>
  4080d2:	eb 2c                	jmp    408100 <rbtree_get+0x40>
  4080d4:	0f 1f 40 00          	nopl   0x0(%rax)
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? LDNODE(p, l) : LDNODE(p, r));
  4080d8:	48 8b 43 18          	mov    0x18(%rbx),%rax
  4080dc:	48 0f 49 43 20       	cmovns 0x20(%rbx),%rax
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
  4080e1:	48 85 c0             	test   %rax,%rax
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? LDNODE(p, l) : LDNODE(p, r));
  4080e4:	48 89 c3             	mov    %rax,%rbx
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
  4080e7:	74 17                	je     408100 <rbtree_get+0x40>
        long cmp = s->compare(k, LDF(p, k));
  4080e9:	48 8b 33             	mov    (%rbx),%rsi
  4080ec:	4c 89 e7             	mov    %r12,%rdi
  4080ef:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  4080f2:	48 85 c0             	test   %rax,%rax
  4080f5:	75 e1                	jne    4080d8 <rbtree_get+0x18>
 */
void*
rbtree_get (rbtree_t* r, void* key) {
    node_t* n = LOOKUP(r, key);
    if (n != NULL) {
        void* val = LDF(n, v);
  4080f7:	48 8b 43 08          	mov    0x8(%rbx),%rax
        return val;
    }
    return NULL;
}
  4080fb:	5b                   	pop    %rbx
  4080fc:	5d                   	pop    %rbp
  4080fd:	41 5c                	pop    %r12
  4080ff:	c3                   	retq   
  408100:	5b                   	pop    %rbx
  408101:	5d                   	pop    %rbp
    node_t* n = LOOKUP(r, key);
    if (n != NULL) {
        void* val = LDF(n, v);
        return val;
    }
    return NULL;
  408102:	31 c0                	xor    %eax,%eax
}
  408104:	41 5c                	pop    %r12
  408106:	c3                   	retq   
  408107:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40810e:	00 00 

0000000000408110 <TMrbtree_get>:
/* =============================================================================
 * TMrbtree_get
 * =============================================================================
 */
void*
TMrbtree_get (TM_ARGDECL  rbtree_t* r, void* key) {
  408110:	41 54                	push   %r12
  408112:	49 89 f4             	mov    %rsi,%r12
  408115:	55                   	push   %rbp
  408116:	48 89 fd             	mov    %rdi,%rbp
  408119:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);
  40811a:	48 8b 1f             	mov    (%rdi),%rbx

    while (p != NULL) {
  40811d:	48 85 db             	test   %rbx,%rbx
  408120:	75 17                	jne    408139 <TMrbtree_get+0x29>
  408122:	eb 2c                	jmp    408150 <TMrbtree_get+0x40>
  408124:	0f 1f 40 00          	nopl   0x0(%rax)
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  408128:	48 8b 43 18          	mov    0x18(%rbx),%rax
  40812c:	48 0f 49 43 20       	cmovns 0x20(%rbx),%rax
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
  408131:	48 85 c0             	test   %rax,%rax
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  408134:	48 89 c3             	mov    %rax,%rbx
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
  408137:	74 17                	je     408150 <TMrbtree_get+0x40>
        long cmp = s->compare(k, TX_LDF_P(p, k));
  408139:	48 8b 33             	mov    (%rbx),%rsi
  40813c:	4c 89 e7             	mov    %r12,%rdi
  40813f:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  408142:	48 85 c0             	test   %rax,%rax
  408145:	75 e1                	jne    408128 <TMrbtree_get+0x18>
 */
void*
TMrbtree_get (TM_ARGDECL  rbtree_t* r, void* key) {
    node_t* n = TX_LOOKUP(r, key);
    if (n != NULL) {
        void* val = TX_LDF_P(n, v);
  408147:	48 8b 43 08          	mov    0x8(%rbx),%rax
        return val;
    }
    return NULL;
}
  40814b:	5b                   	pop    %rbx
  40814c:	5d                   	pop    %rbp
  40814d:	41 5c                	pop    %r12
  40814f:	c3                   	retq   
  408150:	5b                   	pop    %rbx
  408151:	5d                   	pop    %rbp
    node_t* n = TX_LOOKUP(r, key);
    if (n != NULL) {
        void* val = TX_LDF_P(n, v);
        return val;
    }
    return NULL;
  408152:	31 c0                	xor    %eax,%eax
}
  408154:	41 5c                	pop    %r12
  408156:	c3                   	retq   
  408157:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40815e:	00 00 

0000000000408160 <rbtree_contains>:
 * rbtree_contains
 * =============================================================================
 */
long
rbtree_contains (rbtree_t* r, void* key)
{
  408160:	41 54                	push   %r12
  408162:	49 89 f4             	mov    %rsi,%r12
  408165:	55                   	push   %rbp
  408166:	48 89 fd             	mov    %rdi,%rbp
  408169:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);
  40816a:	48 8b 1f             	mov    (%rdi),%rbx

    while (p != NULL) {
  40816d:	48 85 db             	test   %rbx,%rbx
  408170:	75 17                	jne    408189 <rbtree_contains+0x29>
  408172:	eb 34                	jmp    4081a8 <rbtree_contains+0x48>
  408174:	0f 1f 40 00          	nopl   0x0(%rax)
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? LDNODE(p, l) : LDNODE(p, r));
  408178:	48 8b 43 18          	mov    0x18(%rbx),%rax
  40817c:	48 0f 49 43 20       	cmovns 0x20(%rbx),%rax
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
  408181:	48 85 c0             	test   %rax,%rax
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? LDNODE(p, l) : LDNODE(p, r));
  408184:	48 89 c3             	mov    %rax,%rbx
static node_t*
lookup (rbtree_t* s, void* k)
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
  408187:	74 1f                	je     4081a8 <rbtree_contains+0x48>
        long cmp = s->compare(k, LDF(p, k));
  408189:	48 8b 33             	mov    (%rbx),%rsi
  40818c:	4c 89 e7             	mov    %r12,%rdi
  40818f:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  408192:	48 85 c0             	test   %rax,%rax
  408195:	75 e1                	jne    408178 <rbtree_contains+0x18>
long
rbtree_contains (rbtree_t* r, void* key)
{
    node_t* n = LOOKUP(r, key);
    return (n != NULL);
}
  408197:	5b                   	pop    %rbx
  408198:	5d                   	pop    %rbp
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
  408199:	b8 01 00 00 00       	mov    $0x1,%eax
long
rbtree_contains (rbtree_t* r, void* key)
{
    node_t* n = LOOKUP(r, key);
    return (n != NULL);
}
  40819e:	41 5c                	pop    %r12
  4081a0:	c3                   	retq   
  4081a1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  4081a8:	5b                   	pop    %rbx
  4081a9:	5d                   	pop    %rbp
{
    node_t* p = LDNODE(s, root);

    while (p != NULL) {
        long cmp = s->compare(k, LDF(p, k));
        if (cmp == 0) {
  4081aa:	31 c0                	xor    %eax,%eax
long
rbtree_contains (rbtree_t* r, void* key)
{
    node_t* n = LOOKUP(r, key);
    return (n != NULL);
}
  4081ac:	41 5c                	pop    %r12
  4081ae:	c3                   	retq   
  4081af:	90                   	nop

00000000004081b0 <TMrbtree_contains>:
 * TMrbtree_contains
 * =============================================================================
 */
long
TMrbtree_contains (TM_ARGDECL  rbtree_t* r, void* key)
{
  4081b0:	41 54                	push   %r12
  4081b2:	49 89 f4             	mov    %rsi,%r12
  4081b5:	55                   	push   %rbp
  4081b6:	48 89 fd             	mov    %rdi,%rbp
  4081b9:	53                   	push   %rbx
 * =============================================================================
 */
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);
  4081ba:	48 8b 1f             	mov    (%rdi),%rbx

    while (p != NULL) {
  4081bd:	48 85 db             	test   %rbx,%rbx
  4081c0:	75 17                	jne    4081d9 <TMrbtree_contains+0x29>
  4081c2:	eb 34                	jmp    4081f8 <TMrbtree_contains+0x48>
  4081c4:	0f 1f 40 00          	nopl   0x0(%rax)
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  4081c8:	48 8b 43 18          	mov    0x18(%rbx),%rax
  4081cc:	48 0f 49 43 20       	cmovns 0x20(%rbx),%rax
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
  4081d1:	48 85 c0             	test   %rax,%rax
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
            return p;
        }
        p = ((cmp < 0) ? TX_LDNODE(p, l) : TX_LDNODE(p, r));
  4081d4:	48 89 c3             	mov    %rax,%rbx
static node_t*
TMlookup (TM_ARGDECL  rbtree_t* s, void* k)
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
  4081d7:	74 1f                	je     4081f8 <TMrbtree_contains+0x48>
        long cmp = s->compare(k, TX_LDF_P(p, k));
  4081d9:	48 8b 33             	mov    (%rbx),%rsi
  4081dc:	4c 89 e7             	mov    %r12,%rdi
  4081df:	ff 55 08             	callq  *0x8(%rbp)
        if (cmp == 0) {
  4081e2:	48 85 c0             	test   %rax,%rax
  4081e5:	75 e1                	jne    4081c8 <TMrbtree_contains+0x18>
long
TMrbtree_contains (TM_ARGDECL  rbtree_t* r, void* key)
{
    node_t* n = TX_LOOKUP(r, key);
    return (n != NULL);
}
  4081e7:	5b                   	pop    %rbx
  4081e8:	5d                   	pop    %rbp
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
  4081e9:	b8 01 00 00 00       	mov    $0x1,%eax
long
TMrbtree_contains (TM_ARGDECL  rbtree_t* r, void* key)
{
    node_t* n = TX_LOOKUP(r, key);
    return (n != NULL);
}
  4081ee:	41 5c                	pop    %r12
  4081f0:	c3                   	retq   
  4081f1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  4081f8:	5b                   	pop    %rbx
  4081f9:	5d                   	pop    %rbp
{
    node_t* p = TX_LDNODE(s, root);

    while (p != NULL) {
        long cmp = s->compare(k, TX_LDF_P(p, k));
        if (cmp == 0) {
  4081fa:	31 c0                	xor    %eax,%eax
long
TMrbtree_contains (TM_ARGDECL  rbtree_t* r, void* key)
{
    node_t* n = TX_LOOKUP(r, key);
    return (n != NULL);
}
  4081fc:	41 5c                	pop    %r12
  4081fe:	c3                   	retq   
  4081ff:	90                   	nop

0000000000408200 <thread_startup>:
 * -- numThread is total number of threads (primary + secondaries)
 * =============================================================================
 */
void
thread_startup (long numThread)
{
  408200:	41 54                	push   %r12
  408202:	55                   	push   %rbp
  408203:	48 89 fd             	mov    %rdi,%rbp
  408206:	53                   	push   %rbx
  408207:	48 83 ec 10          	sub    $0x10,%rsp

    global_numThread = numThread;
    global_doShutdown = FALSE;

    /* Set up barrier */
    assert(global_barrierPtr == NULL);
  40820b:	48 83 3d dd 41 20 00 	cmpq   $0x0,0x2041dd(%rip)        # 60c3f0 <global_barrierPtr>
  408212:	00 
void
thread_startup (long numThread)
{
    long i;

    global_numThread = numThread;
  408213:	48 89 3d d6 40 20 00 	mov    %rdi,0x2040d6(%rip)        # 60c2f0 <global_numThread>
    global_doShutdown = FALSE;
  40821a:	48 c7 05 3b 41 20 00 	movq   $0x0,0x20413b(%rip)        # 60c360 <global_doShutdown>
  408221:	00 00 00 00 

    /* Set up barrier */
    assert(global_barrierPtr == NULL);
  408225:	0f 85 7b 03 00 00    	jne    4085a6 <thread_startup+0x3a6>
thread_barrier_t*
thread_barrier_alloc (long numThread)
{
    thread_barrier_t* barrierPtr;

    assert(numThread > 0);
  40822b:	48 85 ff             	test   %rdi,%rdi
  40822e:	0f 8e 59 03 00 00    	jle    40858d <thread_startup+0x38d>
    assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
  408234:	48 8d 47 ff          	lea    -0x1(%rdi),%rax
  408238:	48 85 f8             	test   %rdi,%rax
  40823b:	0f 85 33 03 00 00    	jne    408574 <thread_startup+0x374>
    barrierPtr = (thread_barrier_t*)malloc(numThread * sizeof(thread_barrier_t));
  408241:	48 8d 04 ff          	lea    (%rdi,%rdi,8),%rax
  408245:	48 8d 3c 47          	lea    (%rdi,%rax,2),%rdi
  408249:	48 c1 e7 03          	shl    $0x3,%rdi
  40824d:	e8 2e 8a ff ff       	callq  400c80 <malloc@plt>
    if (barrierPtr != NULL) {
  408252:	48 85 c0             	test   %rax,%rax
  408255:	0f 84 58 02 00 00    	je     4084b3 <thread_startup+0x2b3>
        barrierPtr->numThread = numThread;
  40825b:	48 89 a8 90 00 00 00 	mov    %rbp,0x90(%rax)
    global_numThread = numThread;
    global_doShutdown = FALSE;

    /* Set up barrier */
    assert(global_barrierPtr == NULL);
    global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
  408262:	48 89 05 87 41 20 00 	mov    %rax,0x204187(%rip)        # 60c3f0 <global_barrierPtr>
  408269:	48 89 c3             	mov    %rax,%rbx
thread_barrier_init (thread_barrier_t* barrierPtr)
{
    long i;
    long numThread = barrierPtr->numThread;

    for (i = 0; i < numThread; i++) {
  40826c:	45 31 e4             	xor    %r12d,%r12d
  40826f:	90                   	nop
        barrierPtr[i].count = 0;
  408270:	48 c7 83 88 00 00 00 	movq   $0x0,0x88(%rbx)
  408277:	00 00 00 00 
        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
  40827b:	31 f6                	xor    %esi,%esi
  40827d:	48 89 df             	mov    %rbx,%rdi
  408280:	e8 1b 8a ff ff       	callq  400ca0 <pthread_mutex_init@plt>
  408285:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
        THREAD_COND_INIT(barrierPtr[i].proceedCond);
  408289:	31 f6                	xor    %esi,%esi
thread_barrier_init (thread_barrier_t* barrierPtr)
{
    long i;
    long numThread = barrierPtr->numThread;

    for (i = 0; i < numThread; i++) {
  40828b:	49 83 c4 01          	add    $0x1,%r12
        barrierPtr[i].count = 0;
        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
        THREAD_COND_INIT(barrierPtr[i].proceedCond);
  40828f:	e8 3c 8a ff ff       	callq  400cd0 <pthread_cond_init@plt>
  408294:	48 8d 7b 58          	lea    0x58(%rbx),%rdi
        THREAD_COND_INIT(barrierPtr[i].proceedAllCond);
  408298:	31 f6                	xor    %esi,%esi
  40829a:	48 81 c3 98 00 00 00 	add    $0x98,%rbx
  4082a1:	e8 2a 8a ff ff       	callq  400cd0 <pthread_cond_init@plt>
thread_barrier_init (thread_barrier_t* barrierPtr)
{
    long i;
    long numThread = barrierPtr->numThread;

    for (i = 0; i < numThread; i++) {
  4082a6:	49 39 ec             	cmp    %rbp,%r12
  4082a9:	75 c5                	jne    408270 <thread_startup+0x70>
    global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
    assert(global_barrierPtr);
    THREAD_BARRIER_INIT(global_barrierPtr, numThread);

    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
  4082ab:	31 f6                	xor    %esi,%esi
  4082ad:	bf 00 c4 60 00       	mov    $0x60c400,%edi
  4082b2:	e8 79 8a ff ff       	callq  400d30 <pthread_key_create@plt>
    assert(global_threadIds == NULL);
  4082b7:	48 83 3d 21 41 20 00 	cmpq   $0x0,0x204121(%rip)        # 60c3e0 <global_threadIds>
  4082be:	00 
  4082bf:	0f 85 96 02 00 00    	jne    40855b <thread_startup+0x35b>
    global_threadIds = (long*)malloc(numThread * sizeof(long));
  4082c5:	49 c1 e4 03          	shl    $0x3,%r12
  4082c9:	4c 89 e7             	mov    %r12,%rdi
  4082cc:	e8 af 89 ff ff       	callq  400c80 <malloc@plt>
    assert(global_threadIds);
  4082d1:	48 85 c0             	test   %rax,%rax
    THREAD_BARRIER_INIT(global_barrierPtr, numThread);

    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
    global_threadIds = (long*)malloc(numThread * sizeof(long));
  4082d4:	48 89 05 05 41 20 00 	mov    %rax,0x204105(%rip)        # 60c3e0 <global_threadIds>
    assert(global_threadIds);
  4082db:	0f 84 61 02 00 00    	je     408542 <thread_startup+0x342>
  4082e1:	48 89 c2             	mov    %rax,%rdx
  4082e4:	48 c1 e2 3c          	shl    $0x3c,%rdx
  4082e8:	48 c1 ea 3f          	shr    $0x3f,%rdx
  4082ec:	48 39 d5             	cmp    %rdx,%rbp
  4082ef:	48 0f 46 d5          	cmovbe %rbp,%rdx
  4082f3:	48 83 fd 0a          	cmp    $0xa,%rbp
  4082f7:	48 89 d1             	mov    %rdx,%rcx
  4082fa:	48 89 ea             	mov    %rbp,%rdx
  4082fd:	0f 87 9d 01 00 00    	ja     4084a0 <thread_startup+0x2a0>
  408303:	48 83 fa 01          	cmp    $0x1,%rdx
    for (i = 0; i < numThread; i++) {
        global_threadIds[i] = i;
  408307:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  40830e:	0f 86 c3 01 00 00    	jbe    4084d7 <thread_startup+0x2d7>
  408314:	48 83 fa 02          	cmp    $0x2,%rdx
  408318:	48 c7 40 08 01 00 00 	movq   $0x1,0x8(%rax)
  40831f:	00 
  408320:	0f 86 bc 01 00 00    	jbe    4084e2 <thread_startup+0x2e2>
  408326:	48 83 fa 03          	cmp    $0x3,%rdx
  40832a:	48 c7 40 10 02 00 00 	movq   $0x2,0x10(%rax)
  408331:	00 
  408332:	0f 86 b5 01 00 00    	jbe    4084ed <thread_startup+0x2ed>
  408338:	48 83 fa 04          	cmp    $0x4,%rdx
  40833c:	48 c7 40 18 03 00 00 	movq   $0x3,0x18(%rax)
  408343:	00 
  408344:	0f 86 ae 01 00 00    	jbe    4084f8 <thread_startup+0x2f8>
  40834a:	48 83 fa 05          	cmp    $0x5,%rdx
  40834e:	48 c7 40 20 04 00 00 	movq   $0x4,0x20(%rax)
  408355:	00 
  408356:	0f 86 a7 01 00 00    	jbe    408503 <thread_startup+0x303>
  40835c:	48 83 fa 06          	cmp    $0x6,%rdx
  408360:	48 c7 40 28 05 00 00 	movq   $0x5,0x28(%rax)
  408367:	00 
  408368:	0f 86 a0 01 00 00    	jbe    40850e <thread_startup+0x30e>
  40836e:	48 83 fa 07          	cmp    $0x7,%rdx
  408372:	48 c7 40 30 06 00 00 	movq   $0x6,0x30(%rax)
  408379:	00 
  40837a:	0f 86 99 01 00 00    	jbe    408519 <thread_startup+0x319>
  408380:	48 83 fa 08          	cmp    $0x8,%rdx
  408384:	48 c7 40 38 07 00 00 	movq   $0x7,0x38(%rax)
  40838b:	00 
  40838c:	0f 86 92 01 00 00    	jbe    408524 <thread_startup+0x324>
  408392:	48 83 fa 09          	cmp    $0x9,%rdx
  408396:	48 c7 40 40 08 00 00 	movq   $0x8,0x40(%rax)
  40839d:	00 
  40839e:	0f 86 8b 01 00 00    	jbe    40852f <thread_startup+0x32f>
  4083a4:	48 c7 40 48 09 00 00 	movq   $0x9,0x48(%rax)
  4083ab:	00 
    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
    global_threadIds = (long*)malloc(numThread * sizeof(long));
    assert(global_threadIds);
    for (i = 0; i < numThread; i++) {
  4083ac:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
  4083b2:	48 39 d5             	cmp    %rdx,%rbp
  4083b5:	74 6a                	je     408421 <thread_startup+0x221>
  4083b7:	48 89 ef             	mov    %rbp,%rdi
  4083ba:	48 29 d7             	sub    %rdx,%rdi
  4083bd:	48 89 fe             	mov    %rdi,%rsi
  4083c0:	48 d1 ee             	shr    %rsi
  4083c3:	49 89 f1             	mov    %rsi,%r9
  4083c6:	4d 01 c9             	add    %r9,%r9
  4083c9:	74 52                	je     40841d <thread_startup+0x21d>
  4083cb:	49 8d 48 01          	lea    0x1(%r8),%rcx

    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
    global_threadIds = (long*)malloc(numThread * sizeof(long));
    assert(global_threadIds);
  4083cf:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  4083d4:	f3 0f 7e 44 24 08    	movq   0x8(%rsp),%xmm0
  4083da:	48 89 0c 24          	mov    %rcx,(%rsp)
  4083de:	48 8d 0c d0          	lea    (%rax,%rdx,8),%rcx
  4083e2:	31 d2                	xor    %edx,%edx
  4083e4:	66 0f 6f 15 04 10 00 	movdqa 0x1004(%rip),%xmm2        # 4093f0 <__PRETTY_FUNCTION__.3923+0x5e>
  4083eb:	00 
  4083ec:	0f 16 04 24          	movhps (%rsp),%xmm0
  4083f0:	eb 0a                	jmp    4083fc <thread_startup+0x1fc>
  4083f2:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4083f8:	66 0f 6f c1          	movdqa %xmm1,%xmm0
  4083fc:	66 0f 6f c8          	movdqa %xmm0,%xmm1
  408400:	48 83 c2 01          	add    $0x1,%rdx
    for (i = 0; i < numThread; i++) {
        global_threadIds[i] = i;
  408404:	66 0f 7f 01          	movdqa %xmm0,(%rcx)
  408408:	48 83 c1 10          	add    $0x10,%rcx
  40840c:	48 39 d6             	cmp    %rdx,%rsi
  40840f:	66 0f d4 ca          	paddq  %xmm2,%xmm1
  408413:	77 e3                	ja     4083f8 <thread_startup+0x1f8>
  408415:	4d 01 c8             	add    %r9,%r8
  408418:	4c 39 cf             	cmp    %r9,%rdi
  40841b:	74 04                	je     408421 <thread_startup+0x221>
  40841d:	4e 89 04 c0          	mov    %r8,(%rax,%r8,8)
    }

    /* Set up thread list */
    assert(global_threads == NULL);
  408421:	48 83 3d 67 3f 20 00 	cmpq   $0x0,0x203f67(%rip)        # 60c390 <global_threads>
  408428:	00 
  408429:	0f 85 a9 01 00 00    	jne    4085d8 <thread_startup+0x3d8>
    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
  40842f:	4c 89 e7             	mov    %r12,%rdi
  408432:	e8 49 88 ff ff       	callq  400c80 <malloc@plt>
    assert(global_threads);
  408437:	48 85 c0             	test   %rax,%rax
        global_threadIds[i] = i;
    }

    /* Set up thread list */
    assert(global_threads == NULL);
    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
  40843a:	48 89 05 4f 3f 20 00 	mov    %rax,0x203f4f(%rip)        # 60c390 <global_threads>
    assert(global_threads);
  408441:	0f 84 78 01 00 00    	je     4085bf <thread_startup+0x3bf>

    /* Set up pool */
    THREAD_ATTR_INIT(global_threadAttr);
  408447:	bf a0 c3 60 00       	mov    $0x60c3a0,%edi
    for (i = 1; i < numThread; i++) {
  40844c:	bb 01 00 00 00       	mov    $0x1,%ebx
    assert(global_threads == NULL);
    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
    assert(global_threads);

    /* Set up pool */
    THREAD_ATTR_INIT(global_threadAttr);
  408451:	e8 ba 88 ff ff       	callq  400d10 <pthread_attr_init@plt>
    for (i = 1; i < numThread; i++) {
  408456:	48 83 fd 01          	cmp    $0x1,%rbp
  40845a:	74 35                	je     408491 <thread_startup+0x291>
  40845c:	0f 1f 40 00          	nopl   0x0(%rax)
  408460:	48 8d 3c dd 00 00 00 	lea    0x0(,%rbx,8),%rdi
  408467:	00 
        THREAD_CREATE(global_threads[i],
  408468:	ba 50 88 40 00       	mov    $0x408850,%edx
  40846d:	be a0 c3 60 00       	mov    $0x60c3a0,%esi
    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
    assert(global_threads);

    /* Set up pool */
    THREAD_ATTR_INIT(global_threadAttr);
    for (i = 1; i < numThread; i++) {
  408472:	48 83 c3 01          	add    $0x1,%rbx
        THREAD_CREATE(global_threads[i],
  408476:	48 89 f9             	mov    %rdi,%rcx
  408479:	48 03 3d 10 3f 20 00 	add    0x203f10(%rip),%rdi        # 60c390 <global_threads>
  408480:	48 03 0d 59 3f 20 00 	add    0x203f59(%rip),%rcx        # 60c3e0 <global_threadIds>
  408487:	e8 34 88 ff ff       	callq  400cc0 <pthread_create@plt>
    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
    assert(global_threads);

    /* Set up pool */
    THREAD_ATTR_INIT(global_threadAttr);
    for (i = 1; i < numThread; i++) {
  40848c:	48 39 eb             	cmp    %rbp,%rbx
  40848f:	75 cf                	jne    408460 <thread_startup+0x260>
    }

    /*
     * Wait for primary thread to call thread_start
     */
}
  408491:	48 83 c4 10          	add    $0x10,%rsp
  408495:	5b                   	pop    %rbx
  408496:	5d                   	pop    %rbp
  408497:	41 5c                	pop    %r12
  408499:	c3                   	retq   
  40849a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  4084a0:	48 85 c9             	test   %rcx,%rcx
  4084a3:	0f 85 91 00 00 00    	jne    40853a <thread_startup+0x33a>

    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
    global_threadIds = (long*)malloc(numThread * sizeof(long));
    assert(global_threadIds);
  4084a9:	31 d2                	xor    %edx,%edx
  4084ab:	45 31 c0             	xor    %r8d,%r8d
  4084ae:	e9 04 ff ff ff       	jmpq   4083b7 <thread_startup+0x1b7>
    global_doShutdown = FALSE;

    /* Set up barrier */
    assert(global_barrierPtr == NULL);
    global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
    assert(global_barrierPtr);
  4084b3:	b9 65 96 40 00       	mov    $0x409665,%ecx
  4084b8:	ba 84 00 00 00       	mov    $0x84,%edx
  4084bd:	be 66 95 40 00       	mov    $0x409566,%esi
  4084c2:	bf c2 95 40 00       	mov    $0x4095c2,%edi
    global_numThread = numThread;
    global_doShutdown = FALSE;

    /* Set up barrier */
    assert(global_barrierPtr == NULL);
    global_barrierPtr = THREAD_BARRIER_ALLOC(numThread);
  4084c7:	48 c7 05 1e 3f 20 00 	movq   $0x0,0x203f1e(%rip)        # 60c3f0 <global_barrierPtr>
  4084ce:	00 00 00 00 
    assert(global_barrierPtr);
  4084d2:	e8 79 87 ff ff       	callq  400c50 <__assert_fail@plt>
    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
    global_threadIds = (long*)malloc(numThread * sizeof(long));
    assert(global_threadIds);
    for (i = 0; i < numThread; i++) {
  4084d7:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  4084dd:	e9 d0 fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  4084e2:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  4084e8:	e9 c5 fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  4084ed:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  4084f3:	e9 ba fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  4084f8:	41 b8 04 00 00 00    	mov    $0x4,%r8d
  4084fe:	e9 af fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  408503:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  408509:	e9 a4 fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  40850e:	41 b8 06 00 00 00    	mov    $0x6,%r8d
  408514:	e9 99 fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  408519:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  40851f:	e9 8e fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  408524:	41 b8 08 00 00 00    	mov    $0x8,%r8d
  40852a:	e9 83 fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>
  40852f:	41 b8 09 00 00 00    	mov    $0x9,%r8d
  408535:	e9 78 fe ff ff       	jmpq   4083b2 <thread_startup+0x1b2>

    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
    global_threadIds = (long*)malloc(numThread * sizeof(long));
    assert(global_threadIds);
  40853a:	48 89 ca             	mov    %rcx,%rdx
  40853d:	e9 c1 fd ff ff       	jmpq   408303 <thread_startup+0x103>
  408542:	b9 65 96 40 00       	mov    $0x409665,%ecx
  408547:	ba 8b 00 00 00       	mov    $0x8b,%edx
  40854c:	be 66 95 40 00       	mov    $0x409566,%esi
  408551:	bf 84 95 40 00       	mov    $0x409584,%edi
  408556:	e8 f5 86 ff ff       	callq  400c50 <__assert_fail@plt>
    assert(global_barrierPtr);
    THREAD_BARRIER_INIT(global_barrierPtr, numThread);

    /* Set up ids */
    THREAD_LOCAL_INIT(global_threadId);
    assert(global_threadIds == NULL);
  40855b:	b9 65 96 40 00       	mov    $0x409665,%ecx
  408560:	ba 89 00 00 00       	mov    $0x89,%edx
  408565:	be 66 95 40 00       	mov    $0x409566,%esi
  40856a:	bf 28 96 40 00       	mov    $0x409628,%edi
  40856f:	e8 dc 86 ff ff       	callq  400c50 <__assert_fail@plt>
thread_barrier_alloc (long numThread)
{
    thread_barrier_t* barrierPtr;

    assert(numThread > 0);
    assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
  408574:	b9 50 96 40 00       	mov    $0x409650,%ecx
  408579:	ba e0 00 00 00       	mov    $0xe0,%edx
  40857e:	be 66 95 40 00       	mov    $0x409566,%esi
  408583:	bf 00 96 40 00       	mov    $0x409600,%edi
  408588:	e8 c3 86 ff ff       	callq  400c50 <__assert_fail@plt>
thread_barrier_t*
thread_barrier_alloc (long numThread)
{
    thread_barrier_t* barrierPtr;

    assert(numThread > 0);
  40858d:	b9 50 96 40 00       	mov    $0x409650,%ecx
  408592:	ba df 00 00 00       	mov    $0xdf,%edx
  408597:	be 66 95 40 00       	mov    $0x409566,%esi
  40859c:	bf 76 95 40 00       	mov    $0x409576,%edi
  4085a1:	e8 aa 86 ff ff       	callq  400c50 <__assert_fail@plt>

    global_numThread = numThread;
    global_doShutdown = FALSE;

    /* Set up barrier */
    assert(global_barrierPtr == NULL);
  4085a6:	b9 65 96 40 00       	mov    $0x409665,%ecx
  4085ab:	ba 82 00 00 00       	mov    $0x82,%edx
  4085b0:	be 66 95 40 00       	mov    $0x409566,%esi
  4085b5:	bf d8 95 40 00       	mov    $0x4095d8,%edi
  4085ba:	e8 91 86 ff ff       	callq  400c50 <__assert_fail@plt>
    }

    /* Set up thread list */
    assert(global_threads == NULL);
    global_threads = (THREAD_T*)malloc(numThread * sizeof(THREAD_T));
    assert(global_threads);
  4085bf:	b9 65 96 40 00       	mov    $0x409665,%ecx
  4085c4:	ba 93 00 00 00       	mov    $0x93,%edx
  4085c9:	be 66 95 40 00       	mov    $0x409566,%esi
  4085ce:	bf b3 95 40 00       	mov    $0x4095b3,%edi
  4085d3:	e8 78 86 ff ff       	callq  400c50 <__assert_fail@plt>
    for (i = 0; i < numThread; i++) {
        global_threadIds[i] = i;
    }

    /* Set up thread list */
    assert(global_threads == NULL);
  4085d8:	b9 65 96 40 00       	mov    $0x409665,%ecx
  4085dd:	ba 91 00 00 00       	mov    $0x91,%edx
  4085e2:	be 66 95 40 00       	mov    $0x409566,%esi
  4085e7:	bf 95 95 40 00       	mov    $0x409595,%edi
  4085ec:	e8 5f 86 ff ff       	callq  400c50 <__assert_fail@plt>
  4085f1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  4085f8:	0f 1f 84 00 00 00 00 
  4085ff:	00 

0000000000408600 <thread_barrier_alloc>:
thread_barrier_t*
thread_barrier_alloc (long numThread)
{
    thread_barrier_t* barrierPtr;

    assert(numThread > 0);
  408600:	48 85 ff             	test   %rdi,%rdi
 * thread_barrier_alloc
 * =============================================================================
 */
thread_barrier_t*
thread_barrier_alloc (long numThread)
{
  408603:	53                   	push   %rbx
  408604:	48 89 fb             	mov    %rdi,%rbx
    thread_barrier_t* barrierPtr;

    assert(numThread > 0);
  408607:	7e 28                	jle    408631 <thread_barrier_alloc+0x31>
    assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
  408609:	48 8d 47 ff          	lea    -0x1(%rdi),%rax
  40860d:	48 85 f8             	test   %rdi,%rax
  408610:	75 38                	jne    40864a <thread_barrier_alloc+0x4a>
    barrierPtr = (thread_barrier_t*)malloc(numThread * sizeof(thread_barrier_t));
  408612:	48 8d 04 ff          	lea    (%rdi,%rdi,8),%rax
  408616:	48 8d 3c 47          	lea    (%rdi,%rax,2),%rdi
  40861a:	48 c1 e7 03          	shl    $0x3,%rdi
  40861e:	e8 5d 86 ff ff       	callq  400c80 <malloc@plt>
    if (barrierPtr != NULL) {
  408623:	48 85 c0             	test   %rax,%rax
  408626:	74 07                	je     40862f <thread_barrier_alloc+0x2f>
        barrierPtr->numThread = numThread;
  408628:	48 89 98 90 00 00 00 	mov    %rbx,0x90(%rax)
    }

    return barrierPtr;
}
  40862f:	5b                   	pop    %rbx
  408630:	c3                   	retq   
thread_barrier_t*
thread_barrier_alloc (long numThread)
{
    thread_barrier_t* barrierPtr;

    assert(numThread > 0);
  408631:	b9 50 96 40 00       	mov    $0x409650,%ecx
  408636:	ba df 00 00 00       	mov    $0xdf,%edx
  40863b:	be 66 95 40 00       	mov    $0x409566,%esi
  408640:	bf 76 95 40 00       	mov    $0x409576,%edi
  408645:	e8 06 86 ff ff       	callq  400c50 <__assert_fail@plt>
    assert((numThread & (numThread - 1)) == 0); /* must be power of 2 */
  40864a:	b9 50 96 40 00       	mov    $0x409650,%ecx
  40864f:	ba e0 00 00 00       	mov    $0xe0,%edx
  408654:	be 66 95 40 00       	mov    $0x409566,%esi
  408659:	bf 00 96 40 00       	mov    $0x409600,%edi
  40865e:	e8 ed 85 ff ff       	callq  400c50 <__assert_fail@plt>
  408663:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  40866a:	84 00 00 00 00 00 

0000000000408670 <thread_barrier_free>:
 * =============================================================================
 */
void
thread_barrier_free (thread_barrier_t* barrierPtr)
{
    free(barrierPtr);
  408670:	e9 3b 86 ff ff       	jmpq   400cb0 <free@plt>
  408675:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
  40867c:	00 00 00 00 

0000000000408680 <thread_barrier_init>:
 * thread_barrier_init
 * =============================================================================
 */
void
thread_barrier_init (thread_barrier_t* barrierPtr)
{
  408680:	41 54                	push   %r12
  408682:	55                   	push   %rbp
    long i;
    long numThread = barrierPtr->numThread;

    for (i = 0; i < numThread; i++) {
  408683:	31 ed                	xor    %ebp,%ebp
 * thread_barrier_init
 * =============================================================================
 */
void
thread_barrier_init (thread_barrier_t* barrierPtr)
{
  408685:	53                   	push   %rbx
    long i;
    long numThread = barrierPtr->numThread;
  408686:	4c 8b a7 90 00 00 00 	mov    0x90(%rdi),%r12
  40868d:	48 89 fb             	mov    %rdi,%rbx

    for (i = 0; i < numThread; i++) {
  408690:	4d 85 e4             	test   %r12,%r12
  408693:	7e 3e                	jle    4086d3 <thread_barrier_init+0x53>
  408695:	0f 1f 00             	nopl   (%rax)
        barrierPtr[i].count = 0;
  408698:	48 c7 83 88 00 00 00 	movq   $0x0,0x88(%rbx)
  40869f:	00 00 00 00 
        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
  4086a3:	31 f6                	xor    %esi,%esi
  4086a5:	48 89 df             	mov    %rbx,%rdi
  4086a8:	e8 f3 85 ff ff       	callq  400ca0 <pthread_mutex_init@plt>
  4086ad:	48 8d 7b 28          	lea    0x28(%rbx),%rdi
        THREAD_COND_INIT(barrierPtr[i].proceedCond);
  4086b1:	31 f6                	xor    %esi,%esi
thread_barrier_init (thread_barrier_t* barrierPtr)
{
    long i;
    long numThread = barrierPtr->numThread;

    for (i = 0; i < numThread; i++) {
  4086b3:	48 83 c5 01          	add    $0x1,%rbp
        barrierPtr[i].count = 0;
        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
        THREAD_COND_INIT(barrierPtr[i].proceedCond);
  4086b7:	e8 14 86 ff ff       	callq  400cd0 <pthread_cond_init@plt>
  4086bc:	48 8d 7b 58          	lea    0x58(%rbx),%rdi
        THREAD_COND_INIT(barrierPtr[i].proceedAllCond);
  4086c0:	31 f6                	xor    %esi,%esi
  4086c2:	48 81 c3 98 00 00 00 	add    $0x98,%rbx
  4086c9:	e8 02 86 ff ff       	callq  400cd0 <pthread_cond_init@plt>
thread_barrier_init (thread_barrier_t* barrierPtr)
{
    long i;
    long numThread = barrierPtr->numThread;

    for (i = 0; i < numThread; i++) {
  4086ce:	4c 39 e5             	cmp    %r12,%rbp
  4086d1:	75 c5                	jne    408698 <thread_barrier_init+0x18>
        barrierPtr[i].count = 0;
        THREAD_MUTEX_INIT(barrierPtr[i].countLock);
        THREAD_COND_INIT(barrierPtr[i].proceedCond);
        THREAD_COND_INIT(barrierPtr[i].proceedAllCond);
    }
}
  4086d3:	5b                   	pop    %rbx
  4086d4:	5d                   	pop    %rbp
  4086d5:	41 5c                	pop    %r12
  4086d7:	c3                   	retq   
  4086d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  4086df:	00 

00000000004086e0 <thread_barrier>:
 * -- Simple logarithmic barrier
 * =============================================================================
 */
void
thread_barrier (thread_barrier_t* barrierPtr, long threadId)
{
  4086e0:	41 57                	push   %r15
  4086e2:	41 56                	push   %r14
  4086e4:	49 89 fe             	mov    %rdi,%r14
  4086e7:	41 55                	push   %r13
  4086e9:	41 54                	push   %r12
  4086eb:	55                   	push   %rbp
    long i = 2;
    long base = 0;
    long index;
    long numThread = barrierPtr->numThread;

    if (numThread < 2) {
  4086ec:	31 ed                	xor    %ebp,%ebp
 * -- Simple logarithmic barrier
 * =============================================================================
 */
void
thread_barrier (thread_barrier_t* barrierPtr, long threadId)
{
  4086ee:	53                   	push   %rbx
    long i = 2;
    long base = 0;
    long index;
    long numThread = barrierPtr->numThread;

    if (numThread < 2) {
  4086ef:	bb 02 00 00 00       	mov    $0x2,%ebx
 * -- Simple logarithmic barrier
 * =============================================================================
 */
void
thread_barrier (thread_barrier_t* barrierPtr, long threadId)
{
  4086f4:	48 83 ec 18          	sub    $0x18,%rsp
    long i = 2;
    long base = 0;
    long index;
    long numThread = barrierPtr->numThread;
  4086f8:	4c 8b a7 90 00 00 00 	mov    0x90(%rdi),%r12
 * -- Simple logarithmic barrier
 * =============================================================================
 */
void
thread_barrier (thread_barrier_t* barrierPtr, long threadId)
{
  4086ff:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
    long i = 2;
    long base = 0;
    long index;
    long numThread = barrierPtr->numThread;

    if (numThread < 2) {
  408704:	49 83 fc 01          	cmp    $0x1,%r12
  408708:	0f 8e db 00 00 00    	jle    4087e9 <thread_barrier+0x109>
  40870e:	66 90                	xchg   %ax,%ax
        return;
    }

    do {
        index = base + threadId / i;
  408710:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  408715:	48 99                	cqto   
  408717:	48 f7 fb             	idiv   %rbx
  40871a:	48 01 e8             	add    %rbp,%rax
        if ((threadId % i) == 0) {
  40871d:	48 85 d2             	test   %rdx,%rdx
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
  408720:	48 8d 14 c0          	lea    (%rax,%rax,8),%rdx
  408724:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
        return;
    }

    do {
        index = base + threadId / i;
        if ((threadId % i) == 0) {
  408728:	0f 85 ca 00 00 00    	jne    4087f8 <thread_barrier+0x118>
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
  40872e:	4d 8d 2c c6          	lea    (%r14,%rax,8),%r13
  408732:	4c 89 ef             	mov    %r13,%rdi
  408735:	4d 8d 7d 28          	lea    0x28(%r13),%r15
  408739:	e8 e2 85 ff ff       	callq  400d20 <pthread_mutex_lock@plt>
            barrierPtr[index].count++;
  40873e:	49 8b 85 88 00 00 00 	mov    0x88(%r13),%rax
  408745:	48 83 c0 01          	add    $0x1,%rax
            while (barrierPtr[index].count < 2) {
  408749:	48 83 f8 01          	cmp    $0x1,%rax

    do {
        index = base + threadId / i;
        if ((threadId % i) == 0) {
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
            barrierPtr[index].count++;
  40874d:	49 89 85 88 00 00 00 	mov    %rax,0x88(%r13)
            while (barrierPtr[index].count < 2) {
  408754:	7f 1f                	jg     408775 <thread_barrier+0x95>
  408756:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  40875d:	00 00 00 
                THREAD_COND_WAIT(barrierPtr[index].proceedCond,
  408760:	4c 89 ee             	mov    %r13,%rsi
  408763:	4c 89 ff             	mov    %r15,%rdi
  408766:	e8 95 85 ff ff       	callq  400d00 <pthread_cond_wait@plt>
    do {
        index = base + threadId / i;
        if ((threadId % i) == 0) {
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
            barrierPtr[index].count++;
            while (barrierPtr[index].count < 2) {
  40876b:	49 83 bd 88 00 00 00 	cmpq   $0x1,0x88(%r13)
  408772:	01 
  408773:	7e eb                	jle    408760 <thread_barrier+0x80>
                THREAD_COND_WAIT(barrierPtr[index].proceedCond,
                                 barrierPtr[index].countLock);
            }
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
  408775:	4c 89 ef             	mov    %r13,%rdi
  408778:	e8 d3 85 ff ff       	callq  400d50 <pthread_mutex_unlock@plt>
                /* wait */
            }
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
            break;
        }
        base = base + numThread / i;
  40877d:	4c 89 e0             	mov    %r12,%rax
  408780:	48 99                	cqto   
  408782:	48 f7 fb             	idiv   %rbx
        i *= 2;
  408785:	48 01 db             	add    %rbx,%rbx
                /* wait */
            }
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
            break;
        }
        base = base + numThread / i;
  408788:	48 01 c5             	add    %rax,%rbp
        i *= 2;
    } while (i <= numThread);
  40878b:	49 39 dc             	cmp    %rbx,%r12
  40878e:	7d 80                	jge    408710 <thread_barrier+0x30>
  408790:	eb 4e                	jmp    4087e0 <thread_barrier+0x100>
  408792:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    for (i /= 2; i > 1; i /= 2) {
        base = base - numThread / i;
  408798:	4c 89 e0             	mov    %r12,%rax
  40879b:	48 99                	cqto   
  40879d:	48 f7 fb             	idiv   %rbx
  4087a0:	48 29 c5             	sub    %rax,%rbp
        index = base + threadId / i;
  4087a3:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
  4087a8:	48 99                	cqto   
  4087aa:	48 f7 fb             	idiv   %rbx
  4087ad:	48 01 e8             	add    %rbp,%rax
        THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
  4087b0:	48 8d 14 c0          	lea    (%rax,%rax,8),%rdx
  4087b4:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
  4087b8:	4d 8d 3c c6          	lea    (%r14,%rax,8),%r15
  4087bc:	4c 89 ff             	mov    %r15,%rdi
  4087bf:	e8 5c 85 ff ff       	callq  400d20 <pthread_mutex_lock@plt>
        barrierPtr[index].count = 0;
        THREAD_COND_SIGNAL(barrierPtr[index].proceedAllCond);
  4087c4:	49 8d 7f 58          	lea    0x58(%r15),%rdi

    for (i /= 2; i > 1; i /= 2) {
        base = base - numThread / i;
        index = base + threadId / i;
        THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
        barrierPtr[index].count = 0;
  4087c8:	49 c7 87 88 00 00 00 	movq   $0x0,0x88(%r15)
  4087cf:	00 00 00 00 
        THREAD_COND_SIGNAL(barrierPtr[index].proceedAllCond);
  4087d3:	e8 58 84 ff ff       	callq  400c30 <pthread_cond_signal@plt>
            while (THREAD_COND_WAIT(barrierPtr[index].proceedAllCond,
                                    barrierPtr[index].countLock) != 0)
            {
                /* wait */
            }
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
  4087d8:	4c 89 ff             	mov    %r15,%rdi
  4087db:	e8 70 85 ff ff       	callq  400d50 <pthread_mutex_unlock@plt>
        }
        base = base + numThread / i;
        i *= 2;
    } while (i <= numThread);

    for (i /= 2; i > 1; i /= 2) {
  4087e0:	48 d1 fb             	sar    %rbx
  4087e3:	48 83 fb 01          	cmp    $0x1,%rbx
  4087e7:	7f af                	jg     408798 <thread_barrier+0xb8>
        THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
        barrierPtr[index].count = 0;
        THREAD_COND_SIGNAL(barrierPtr[index].proceedAllCond);
        THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
    }
}
  4087e9:	48 83 c4 18          	add    $0x18,%rsp
  4087ed:	5b                   	pop    %rbx
  4087ee:	5d                   	pop    %rbp
  4087ef:	41 5c                	pop    %r12
  4087f1:	41 5d                	pop    %r13
  4087f3:	41 5e                	pop    %r14
  4087f5:	41 5f                	pop    %r15
  4087f7:	c3                   	retq   
                THREAD_COND_WAIT(barrierPtr[index].proceedCond,
                                 barrierPtr[index].countLock);
            }
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
        } else {
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
  4087f8:	4d 8d 3c c6          	lea    (%r14,%rax,8),%r15
  4087fc:	4c 89 ff             	mov    %r15,%rdi
  4087ff:	e8 1c 85 ff ff       	callq  400d20 <pthread_mutex_lock@plt>
            barrierPtr[index].count++;
  408804:	49 8b 87 88 00 00 00 	mov    0x88(%r15),%rax
  40880b:	48 83 c0 01          	add    $0x1,%rax
            if (barrierPtr[index].count == 2) {
  40880f:	48 83 f8 02          	cmp    $0x2,%rax
                                 barrierPtr[index].countLock);
            }
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
        } else {
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
            barrierPtr[index].count++;
  408813:	49 89 87 88 00 00 00 	mov    %rax,0x88(%r15)
            if (barrierPtr[index].count == 2) {
  40881a:	74 1d                	je     408839 <thread_barrier+0x159>
  40881c:	49 8d 47 58          	lea    0x58(%r15),%rax
  408820:	49 89 c5             	mov    %rax,%r13
  408823:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                THREAD_COND_SIGNAL(barrierPtr[index].proceedCond);
            }
            while (THREAD_COND_WAIT(barrierPtr[index].proceedAllCond,
  408828:	4c 89 fe             	mov    %r15,%rsi
  40882b:	4c 89 ef             	mov    %r13,%rdi
  40882e:	e8 cd 84 ff ff       	callq  400d00 <pthread_cond_wait@plt>
  408833:	85 c0                	test   %eax,%eax
  408835:	75 f1                	jne    408828 <thread_barrier+0x148>
  408837:	eb 9f                	jmp    4087d8 <thread_barrier+0xf8>
            THREAD_MUTEX_UNLOCK(barrierPtr[index].countLock);
        } else {
            THREAD_MUTEX_LOCK(barrierPtr[index].countLock);
            barrierPtr[index].count++;
            if (barrierPtr[index].count == 2) {
                THREAD_COND_SIGNAL(barrierPtr[index].proceedCond);
  408839:	49 8d 7f 28          	lea    0x28(%r15),%rdi
  40883d:	0f 1f 00             	nopl   (%rax)
  408840:	e8 eb 83 ff ff       	callq  400c30 <pthread_cond_signal@plt>
  408845:	eb d5                	jmp    40881c <thread_barrier+0x13c>
  408847:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40884e:	00 00 

0000000000408850 <threadWait>:
 * -- Synchronizes all threads to start/stop parallel section
 * =============================================================================
 */
static void
threadWait (void* argPtr)
{
  408850:	53                   	push   %rbx
    long threadId = *(long*)argPtr;
  408851:	48 8b 1f             	mov    (%rdi),%rbx

    THREAD_LOCAL_SET(global_threadId, (long)threadId);
  408854:	8b 3d a6 3b 20 00    	mov    0x203ba6(%rip),%edi        # 60c400 <global_threadId>
  40885a:	48 89 de             	mov    %rbx,%rsi
  40885d:	e8 ae 83 ff ff       	callq  400c10 <pthread_setspecific@plt>
  408862:	48 85 db             	test   %rbx,%rbx
  408865:	75 25                	jne    40888c <threadWait+0x3c>
  408867:	eb 40                	jmp    4088a9 <threadWait+0x59>
  408869:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    while (1) {
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
        if (global_doShutdown) {
            break;
        }
        global_funcPtr(global_argPtr);
  408870:	48 8b 3d f9 3a 20 00 	mov    0x203af9(%rip),%rdi        # 60c370 <global_argPtr>
  408877:	ff 15 03 3b 20 00    	callq  *0x203b03(%rip)        # 60c380 <global_funcPtr>
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
  40887d:	48 8b 3d 6c 3b 20 00 	mov    0x203b6c(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  408884:	48 89 de             	mov    %rbx,%rsi
  408887:	e8 54 fe ff ff       	callq  4086e0 <thread_barrier>
    long threadId = *(long*)argPtr;

    THREAD_LOCAL_SET(global_threadId, (long)threadId);

    while (1) {
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
  40888c:	48 8b 3d 5d 3b 20 00 	mov    0x203b5d(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  408893:	48 89 de             	mov    %rbx,%rsi
  408896:	e8 45 fe ff ff       	callq  4086e0 <thread_barrier>
        if (global_doShutdown) {
  40889b:	48 8b 05 be 3a 20 00 	mov    0x203abe(%rip),%rax        # 60c360 <global_doShutdown>
  4088a2:	48 85 c0             	test   %rax,%rax
  4088a5:	74 c9                	je     408870 <threadWait+0x20>
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
        if (threadId == 0) {
            break;
        }
    }
}
  4088a7:	5b                   	pop    %rbx
  4088a8:	c3                   	retq   
    long threadId = *(long*)argPtr;

    THREAD_LOCAL_SET(global_threadId, (long)threadId);

    while (1) {
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
  4088a9:	48 8b 3d 40 3b 20 00 	mov    0x203b40(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  4088b0:	31 f6                	xor    %esi,%esi
  4088b2:	e8 29 fe ff ff       	callq  4086e0 <thread_barrier>
        if (global_doShutdown) {
  4088b7:	48 8b 05 a2 3a 20 00 	mov    0x203aa2(%rip),%rax        # 60c360 <global_doShutdown>
  4088be:	48 85 c0             	test   %rax,%rax
  4088c1:	75 e4                	jne    4088a7 <threadWait+0x57>
            break;
        }
        global_funcPtr(global_argPtr);
  4088c3:	48 8b 3d a6 3a 20 00 	mov    0x203aa6(%rip),%rdi        # 60c370 <global_argPtr>
  4088ca:	ff 15 b0 3a 20 00    	callq  *0x203ab0(%rip)        # 60c380 <global_funcPtr>
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
        if (threadId == 0) {
            break;
        }
    }
}
  4088d0:	5b                   	pop    %rbx
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
        if (global_doShutdown) {
            break;
        }
        global_funcPtr(global_argPtr);
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
  4088d1:	48 8b 3d 18 3b 20 00 	mov    0x203b18(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  4088d8:	31 f6                	xor    %esi,%esi
  4088da:	e9 01 fe ff ff       	jmpq   4086e0 <thread_barrier>
  4088df:	90                   	nop

00000000004088e0 <thread_shutdown>:
 * -- Primary thread kills pool of secondary threads
 * =============================================================================
 */
void
thread_shutdown ()
{
  4088e0:	55                   	push   %rbp
    /* Make secondary threads exit wait() */
    global_doShutdown = TRUE;
    THREAD_BARRIER(global_barrierPtr, 0);
  4088e1:	31 f6                	xor    %esi,%esi
 * -- Primary thread kills pool of secondary threads
 * =============================================================================
 */
void
thread_shutdown ()
{
  4088e3:	53                   	push   %rbx
    THREAD_BARRIER(global_barrierPtr, 0);

    long numThread = global_numThread;

    long i;
    for (i = 1; i < numThread; i++) {
  4088e4:	bb 01 00 00 00       	mov    $0x1,%ebx
 * -- Primary thread kills pool of secondary threads
 * =============================================================================
 */
void
thread_shutdown ()
{
  4088e9:	48 83 ec 08          	sub    $0x8,%rsp
    /* Make secondary threads exit wait() */
    global_doShutdown = TRUE;
    THREAD_BARRIER(global_barrierPtr, 0);
  4088ed:	48 8b 3d fc 3a 20 00 	mov    0x203afc(%rip),%rdi        # 60c3f0 <global_barrierPtr>
 */
void
thread_shutdown ()
{
    /* Make secondary threads exit wait() */
    global_doShutdown = TRUE;
  4088f4:	48 c7 05 61 3a 20 00 	movq   $0x1,0x203a61(%rip)        # 60c360 <global_doShutdown>
  4088fb:	01 00 00 00 
    THREAD_BARRIER(global_barrierPtr, 0);
  4088ff:	e8 dc fd ff ff       	callq  4086e0 <thread_barrier>

    long numThread = global_numThread;
  408904:	48 8b 2d e5 39 20 00 	mov    0x2039e5(%rip),%rbp        # 60c2f0 <global_numThread>

    long i;
    for (i = 1; i < numThread; i++) {
  40890b:	48 83 fd 01          	cmp    $0x1,%rbp
  40890f:	7e 22                	jle    408933 <thread_shutdown+0x53>
  408911:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        THREAD_JOIN(global_threads[i]);
  408918:	48 8b 05 71 3a 20 00 	mov    0x203a71(%rip),%rax        # 60c390 <global_threads>
  40891f:	31 f6                	xor    %esi,%esi
  408921:	48 8b 3c d8          	mov    (%rax,%rbx,8),%rdi
    THREAD_BARRIER(global_barrierPtr, 0);

    long numThread = global_numThread;

    long i;
    for (i = 1; i < numThread; i++) {
  408925:	48 83 c3 01          	add    $0x1,%rbx
        THREAD_JOIN(global_threads[i]);
  408929:	e8 b2 83 ff ff       	callq  400ce0 <pthread_join@plt>
    THREAD_BARRIER(global_barrierPtr, 0);

    long numThread = global_numThread;

    long i;
    for (i = 1; i < numThread; i++) {
  40892e:	48 39 eb             	cmp    %rbp,%rbx
  408931:	75 e5                	jne    408918 <thread_shutdown+0x38>
 * =============================================================================
 */
void
thread_barrier_free (thread_barrier_t* barrierPtr)
{
    free(barrierPtr);
  408933:	48 8b 3d b6 3a 20 00 	mov    0x203ab6(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  40893a:	e8 71 83 ff ff       	callq  400cb0 <free@plt>
    }

    THREAD_BARRIER_FREE(global_barrierPtr);
    global_barrierPtr = NULL;

    free(global_threadIds);
  40893f:	48 8b 3d 9a 3a 20 00 	mov    0x203a9a(%rip),%rdi        # 60c3e0 <global_threadIds>
    for (i = 1; i < numThread; i++) {
        THREAD_JOIN(global_threads[i]);
    }

    THREAD_BARRIER_FREE(global_barrierPtr);
    global_barrierPtr = NULL;
  408946:	48 c7 05 9f 3a 20 00 	movq   $0x0,0x203a9f(%rip)        # 60c3f0 <global_barrierPtr>
  40894d:	00 00 00 00 

    free(global_threadIds);
  408951:	e8 5a 83 ff ff       	callq  400cb0 <free@plt>
    global_threadIds = NULL;

    free(global_threads);
  408956:	48 8b 3d 33 3a 20 00 	mov    0x203a33(%rip),%rdi        # 60c390 <global_threads>

    THREAD_BARRIER_FREE(global_barrierPtr);
    global_barrierPtr = NULL;

    free(global_threadIds);
    global_threadIds = NULL;
  40895d:	48 c7 05 78 3a 20 00 	movq   $0x0,0x203a78(%rip)        # 60c3e0 <global_threadIds>
  408964:	00 00 00 00 

    free(global_threads);
  408968:	e8 43 83 ff ff       	callq  400cb0 <free@plt>
    global_threads = NULL;
  40896d:	48 c7 05 18 3a 20 00 	movq   $0x0,0x203a18(%rip)        # 60c390 <global_threads>
  408974:	00 00 00 00 

    global_numThread = 1;
  408978:	48 c7 05 6d 39 20 00 	movq   $0x1,0x20396d(%rip)        # 60c2f0 <global_numThread>
  40897f:	01 00 00 00 
}
  408983:	48 83 c4 08          	add    $0x8,%rsp
  408987:	5b                   	pop    %rbx
  408988:	5d                   	pop    %rbp
  408989:	c3                   	retq   
  40898a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000408990 <thread_start>:
 * -- funcPtr takes one arguments: argPtr
 * =============================================================================
 */
void
thread_start (void (*funcPtr)(void*), void* argPtr)
{
  408990:	48 83 ec 08          	sub    $0x8,%rsp
    global_funcPtr = funcPtr;
  408994:	48 89 3d e5 39 20 00 	mov    %rdi,0x2039e5(%rip)        # 60c380 <global_funcPtr>
static void
threadWait (void* argPtr)
{
    long threadId = *(long*)argPtr;

    THREAD_LOCAL_SET(global_threadId, (long)threadId);
  40899b:	8b 3d 5f 3a 20 00    	mov    0x203a5f(%rip),%edi        # 60c400 <global_threadId>
 */
void
thread_start (void (*funcPtr)(void*), void* argPtr)
{
    global_funcPtr = funcPtr;
    global_argPtr = argPtr;
  4089a1:	48 89 35 c8 39 20 00 	mov    %rsi,0x2039c8(%rip)        # 60c370 <global_argPtr>
static void
threadWait (void* argPtr)
{
    long threadId = *(long*)argPtr;

    THREAD_LOCAL_SET(global_threadId, (long)threadId);
  4089a8:	31 f6                	xor    %esi,%esi
  4089aa:	e8 61 82 ff ff       	callq  400c10 <pthread_setspecific@plt>

    while (1) {
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
  4089af:	48 8b 3d 3a 3a 20 00 	mov    0x203a3a(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  4089b6:	31 f6                	xor    %esi,%esi
  4089b8:	e8 23 fd ff ff       	callq  4086e0 <thread_barrier>
        if (global_doShutdown) {
  4089bd:	48 8b 05 9c 39 20 00 	mov    0x20399c(%rip),%rax        # 60c360 <global_doShutdown>
  4089c4:	48 85 c0             	test   %rax,%rax
  4089c7:	75 1f                	jne    4089e8 <thread_start+0x58>
            break;
        }
        global_funcPtr(global_argPtr);
  4089c9:	48 8b 3d a0 39 20 00 	mov    0x2039a0(%rip),%rdi        # 60c370 <global_argPtr>
  4089d0:	ff 15 aa 39 20 00    	callq  *0x2039aa(%rip)        # 60c380 <global_funcPtr>
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
  4089d6:	48 8b 3d 13 3a 20 00 	mov    0x203a13(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  4089dd:	31 f6                	xor    %esi,%esi
    global_funcPtr = funcPtr;
    global_argPtr = argPtr;

    long threadId = 0; /* primary */
    threadWait((void*)&threadId);
}
  4089df:	48 83 c4 08          	add    $0x8,%rsp
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for start parallel */
        if (global_doShutdown) {
            break;
        }
        global_funcPtr(global_argPtr);
        THREAD_BARRIER(global_barrierPtr, threadId); /* wait for end parallel */
  4089e3:	e9 f8 fc ff ff       	jmpq   4086e0 <thread_barrier>
    global_funcPtr = funcPtr;
    global_argPtr = argPtr;

    long threadId = 0; /* primary */
    threadWait((void*)&threadId);
}
  4089e8:	48 83 c4 08          	add    $0x8,%rsp
  4089ec:	c3                   	retq   
  4089ed:	0f 1f 00             	nopl   (%rax)

00000000004089f0 <thread_getId>:
 * =============================================================================
 */
long
thread_getId()
{
    return (long)THREAD_LOCAL_GET(global_threadId);
  4089f0:	8b 3d 0a 3a 20 00    	mov    0x203a0a(%rip),%edi        # 60c400 <global_threadId>
  4089f6:	e9 f5 81 ff ff       	jmpq   400bf0 <pthread_getspecific@plt>
  4089fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000408a00 <thread_getNumThread>:
 */
long
thread_getNumThread()
{
    return global_numThread;
}
  408a00:	48 8b 05 e9 38 20 00 	mov    0x2038e9(%rip),%rax        # 60c2f0 <global_numThread>
  408a07:	c3                   	retq   
  408a08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  408a0f:	00 

0000000000408a10 <thread_barrier_wait>:
 * -- Call after thread_start() to synchronize threads inside parallel region
 * =============================================================================
 */
void
thread_barrier_wait()
{
  408a10:	48 83 ec 08          	sub    $0x8,%rsp
 * =============================================================================
 */
long
thread_getId()
{
    return (long)THREAD_LOCAL_GET(global_threadId);
  408a14:	8b 3d e6 39 20 00    	mov    0x2039e6(%rip),%edi        # 60c400 <global_threadId>
  408a1a:	e8 d1 81 ff ff       	callq  400bf0 <pthread_getspecific@plt>
thread_barrier_wait()
{
#ifndef SIMULATOR
    long threadId = thread_getId();
#endif /* !SIMULATOR */
    THREAD_BARRIER(global_barrierPtr, threadId);
  408a1f:	48 8b 3d ca 39 20 00 	mov    0x2039ca(%rip),%rdi        # 60c3f0 <global_barrierPtr>
  408a26:	48 89 c6             	mov    %rax,%rsi
}
  408a29:	48 83 c4 08          	add    $0x8,%rsp
thread_barrier_wait()
{
#ifndef SIMULATOR
    long threadId = thread_getId();
#endif /* !SIMULATOR */
    THREAD_BARRIER(global_barrierPtr, threadId);
  408a2d:	e9 ae fc ff ff       	jmpq   4086e0 <thread_barrier>
  408a32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  408a39:	00 00 00 
  408a3c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000408a40 <__libc_csu_fini>:
  408a40:	f3 c3                	repz retq 
  408a42:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
  408a49:	1f 84 00 00 00 00 00 

0000000000408a50 <__libc_csu_init>:
  408a50:	48 89 6c 24 d8       	mov    %rbp,-0x28(%rsp)
  408a55:	4c 89 64 24 e0       	mov    %r12,-0x20(%rsp)
  408a5a:	48 8d 2d 9f 35 20 00 	lea    0x20359f(%rip),%rbp        # 60c000 <__CTOR_LIST__>
  408a61:	4c 8d 25 98 35 20 00 	lea    0x203598(%rip),%r12        # 60c000 <__CTOR_LIST__>
  408a68:	4c 89 6c 24 e8       	mov    %r13,-0x18(%rsp)
  408a6d:	4c 89 74 24 f0       	mov    %r14,-0x10(%rsp)
  408a72:	4c 89 7c 24 f8       	mov    %r15,-0x8(%rsp)
  408a77:	48 89 5c 24 d0       	mov    %rbx,-0x30(%rsp)
  408a7c:	48 83 ec 38          	sub    $0x38,%rsp
  408a80:	4c 29 e5             	sub    %r12,%rbp
  408a83:	41 89 fd             	mov    %edi,%r13d
  408a86:	49 89 f6             	mov    %rsi,%r14
  408a89:	48 c1 fd 03          	sar    $0x3,%rbp
  408a8d:	49 89 d7             	mov    %rdx,%r15
  408a90:	e8 2b 81 ff ff       	callq  400bc0 <_init>
  408a95:	48 85 ed             	test   %rbp,%rbp
  408a98:	74 1c                	je     408ab6 <__libc_csu_init+0x66>
  408a9a:	31 db                	xor    %ebx,%ebx
  408a9c:	0f 1f 40 00          	nopl   0x0(%rax)
  408aa0:	4c 89 fa             	mov    %r15,%rdx
  408aa3:	4c 89 f6             	mov    %r14,%rsi
  408aa6:	44 89 ef             	mov    %r13d,%edi
  408aa9:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  408aad:	48 83 c3 01          	add    $0x1,%rbx
  408ab1:	48 39 eb             	cmp    %rbp,%rbx
  408ab4:	72 ea                	jb     408aa0 <__libc_csu_init+0x50>
  408ab6:	48 8b 5c 24 08       	mov    0x8(%rsp),%rbx
  408abb:	48 8b 6c 24 10       	mov    0x10(%rsp),%rbp
  408ac0:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  408ac5:	4c 8b 6c 24 20       	mov    0x20(%rsp),%r13
  408aca:	4c 8b 74 24 28       	mov    0x28(%rsp),%r14
  408acf:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15
  408ad4:	48 83 c4 38          	add    $0x38,%rsp
  408ad8:	c3                   	retq   
  408ad9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000408ae0 <__do_global_ctors_aux>:
  408ae0:	55                   	push   %rbp
  408ae1:	48 89 e5             	mov    %rsp,%rbp
  408ae4:	53                   	push   %rbx
  408ae5:	bb 00 c0 60 00       	mov    $0x60c000,%ebx
  408aea:	48 83 ec 08          	sub    $0x8,%rsp
  408aee:	48 8b 05 0b 35 20 00 	mov    0x20350b(%rip),%rax        # 60c000 <__CTOR_LIST__>
  408af5:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  408af9:	74 14                	je     408b0f <__do_global_ctors_aux+0x2f>
  408afb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
  408b00:	48 83 eb 08          	sub    $0x8,%rbx
  408b04:	ff d0                	callq  *%rax
  408b06:	48 8b 03             	mov    (%rbx),%rax
  408b09:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  408b0d:	75 f1                	jne    408b00 <__do_global_ctors_aux+0x20>
  408b0f:	48 83 c4 08          	add    $0x8,%rsp
  408b13:	5b                   	pop    %rbx
  408b14:	5d                   	pop    %rbp
  408b15:	c3                   	retq   
  408b16:	66 90                	xchg   %ax,%ax

Disassembly of section .fini:

0000000000408b18 <_fini>:
  408b18:	48 83 ec 08          	sub    $0x8,%rsp
  408b1c:	e8 5f 8c ff ff       	callq  401780 <__do_global_dtors_aux>
  408b21:	48 83 c4 08          	add    $0x8,%rsp
  408b25:	c3                   	retq   
